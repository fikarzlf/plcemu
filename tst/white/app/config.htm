<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:#include "plclib.h"
 10:        -:    5:
 11:        -:    6:const char * Config_vars[N_CONFIG_VARIABLES] = {
 12:        -:    7:    "STEP",
 13:        -:    8:    "PIPE",
 14:        -:    9:    "SIGENABLE",
 15:        -:   10:    "PAGELEN",
 16:        -:   11:    "PAGEWIDTH",
 17:        -:   12:    "HW",
 18:        -:   13:    "NT",
 19:        -:   14:    "NS",
 20:        -:   15:    "NR",
 21:        -:   16:    "NM",
 22:        -:   17:    "NDI",
 23:        -:   18:    "NDQ",
 24:        -:   19:    "NAI",
 25:        -:   20:    "NAQ",
 26:        -:   21:    "RESPONSE",
 27:        -:   22:    "USPACE",
 28:        -:   23:    "COMEDI",
 29:        -:   24:    "SIM",
 30:        -:   25:    "IL",
 31:        -:   26:    "LD",
 32:        -:   27:    //sequences
 33:        -:   28:    "AI",
 34:        -:   29:    "AQ",
 35:        -:   30:    "DI",
 36:        -:   31:    "DQ",
 37:        -:   32:    "MVAR",
 38:        -:   33:    "MREG",
 39:        -:   34:    "TIMER",
 40:        -:   35:    "PULSE"
 41:        -:   36:};
 42:        -:   37:
 43:        -:   38:const char * Variable_params[N_VARIABLE_PARAMS] = {
 44:        -:   39:    "INDEX",
 45:        -:   40:    "ID",
 46:        -:   41:    "VALUE",
 47:        -:   42:    "MIN",
 48:        -:   43:    "MAX"
 49:        -:   44:};
 50:        -:   45:
 51:function yaml_config_error called 0 returned 00locks executed 0%
 52:<font color=red>    #####:   46:static void yaml_config_error(yaml_parser_t parser){</font>
 53:        -:   47:
 54:        -:   48:    //print line
 55:<font color=red>    #####:   49:}</font>
 56:        -:   50:
 57:function yaml_parser_error called 2 returned 1000locks executed 22%
 58:        2:   51:static void yaml_parser_error(yaml_parser_t parser){
 59:        -:   52:
 60:        2:   53:     switch (parser.error)
 61:        -:   54:     {
 62:        -:   55:        case YAML_MEMORY_ERROR:
 63:<font color=red>    #####:   56:            plc_log( </font>
 64:        -:   57:            "Memory error: Not enough memory for parsing");
 65:<font color=red>    #####:   58:            break;</font>
 66:        -:   59:
 67:        -:   60:        case YAML_READER_ERROR:
 68:<font color=red>    #####:   61:            if (parser.problem_value != -1) {</font>
 69:<font color=red>    #####:   62:                plc_log( </font>
 70:        -:   63:                "Reader error: : #0 at 0", 
 71:        -:   64:                parser.problem,
 72:        -:   65:                parser.problem_value, 
 73:        -:   66:                parser.problem_offset);
 74:        -:   67:            }
 75:        -:   68:            else {
 76:<font color=red>    #####:   69:                plc_log( </font>
 77:        -:   70:                "Reader error:  at 0", 
 78:        -:   71:                parser.problem,
 79:        -:   72:                parser.problem_offset);
 80:        -:   73:            }
 81:<font color=red>    #####:   74:            break;</font>
 82:        -:   75:
 83:        -:   76:        case YAML_SCANNER_ERROR:
 84:<font color=red>    #####:   77:            if (parser.context) {</font>
 85:<font color=red>    #####:   78:                plc_log( </font>
 86:        -:   79:                "Scanner error:  at line 0, column 0"
 87:        -:   80:                        " at line 0, column 0", 
 88:        -:   81:                        parser.context,
 89:<font color=red>    #####:   82:                        parser.context_mark.line+1,</font>
 90:<font color=red>    #####:   83:                        parser.context_mark.column+1,</font>
 91:        -:   84:                        parser.problem, 
 92:<font color=red>    #####:   85:                        parser.problem_mark.line+1,</font>
 93:<font color=red>    #####:   86:                        parser.problem_mark.column+1);</font>
 94:        -:   87:            }
 95:        -:   88:            else {
 96:<font color=red>    #####:   89:                plc_log( </font>
 97:        -:   90:                "Scanner error:  at line 0, column 0",
 98:<font color=red>    #####:   91:                        parser.problem, parser.problem_mark.line+1,</font>
 99:<font color=red>    #####:   92:                        parser.problem_mark.column+1);</font>
100:        -:   93:            }
101:<font color=red>    #####:   94:            break;</font>
102:        -:   95:
103:        -:   96:        case YAML_PARSER_ERROR:
104:<font color=red>    #####:   97:            if (parser.context) {</font>
105:<font color=red>    #####:   98:                plc_log( </font>
106:        -:   99:                "Parser error:  at line 0, column 0"
107:        -:  100:                        " at line 0, column 0", 
108:        -:  101:                        parser.context,
109:<font color=red>    #####:  102:                        parser.context_mark.line+1,</font>
110:<font color=red>    #####:  103:                        parser.context_mark.column+1,</font>
111:        -:  104:                        parser.problem, 
112:<font color=red>    #####:  105:                        parser.problem_mark.line+1,</font>
113:<font color=red>    #####:  106:                        parser.problem_mark.column+1);</font>
114:        -:  107:            }
115:        -:  108:            else {
116:<font color=red>    #####:  109:                plc_log( </font>
117:        -:  110:                "Parser error:  at line 0, column 0",
118:        -:  111:                        parser.problem, 
119:<font color=red>    #####:  112:                        parser.problem_mark.line+1,</font>
120:<font color=red>    #####:  113:                        parser.problem_mark.column+1);</font>
121:        -:  114:            }
122:<font color=red>    #####:  115:            break;</font>
123:        -:  116:
124:        -:  117:        default:
125:        -:  118:            /* Couldn't happen. */
126:        2:  119:            plc_log( 
127:        -:  120:            "Internal error\n");
128:        2:  121:            break;
129:        -:  122:    }
130:        2:  123:}
131:        -:  124:
132:function new_entry_int called 72 returned 1000locks executed 100%
133:       72:  125:static entry_t new_entry_int(int i, char * name) {
134:        -:  126:
135:       72:  127:	entry_t r = (entry_t)malloc(sizeof(struct entry));
136:       72:  128:	r-&gt;type_tag = ENTRY_INT;
137:       72:  129:	r-&gt;name = name;
138:       72:  130:	r-&gt;e.scalar_int = i;
139:        -:  131:
140:       72:  132:	return r;
141:        -:  133:}
142:        -:  134:
143:function new_entry_str called 32 returned 1000locks executed 100%
144:       32:  135:static entry_t new_entry_str(char * str, char * name) {
145:        -:  136:
146:       32:  137:	entry_t r = (entry_t)malloc(sizeof(struct entry));
147:       32:  138:	r-&gt;type_tag = ENTRY_STR;
148:       32:  139:	r-&gt;name = name;
149:       32:  140:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
150:       32:  141:    sprintf(r-&gt;e.scalar_str, "", str);
151:       32:  142:	return r;
152:        -:  143:}
153:        -:  144:
154:function new_entry_map called 32 returned 1000locks executed 100%
155:       32:  145:static entry_t new_entry_map(config_t map, char * name) {
156:        -:  146:	
157:       32:  147:	entry_t r = (entry_t)malloc(sizeof(struct entry));
158:       32:  148:	r-&gt;type_tag = ENTRY_MAP;
159:       32:  149:	r-&gt;name = name;
160:       32:  150:	r-&gt;e.conf = map;
161:        -:  151:
162:       32:  152:	return r;
163:        -:  153:}
164:        -:  154:
165:function new_entry_seq called 64 returned 1000locks executed 100%
166:       64:  155:static entry_t new_entry_seq(sequence_t seq, char * name) {
167:        -:  156:	
168:       64:  157:	entry_t r = (entry_t)malloc(sizeof(struct entry));
169:       64:  158:	r-&gt;type_tag = ENTRY_SEQ;
170:       64:  159:	r-&gt;name = name;
171:       64:  160:	r-&gt;e.seq = seq;
172:        -:  161:
173:       64:  162:	return r;
174:        -:  163:}
175:        -:  164:
176:function new_entry_null called 0 returned 00locks executed 0%
177:<font color=red>    #####:  165:static entry_t new_entry_null() {</font>
178:<font color=red>    #####:  166:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
179:<font color=red>    #####:  167:	r-&gt;type_tag = ENTRY_NONE;</font>
180:<font color=red>    #####:  168:	r-&gt;name = "";</font>
181:<font color=red>    #####:  169:	r-&gt;e.scalar_int = 0;</font>
182:        -:  170:
183:<font color=red>    #####:  171:	return r;</font>
184:        -:  172:}
185:        -:  173:
186:function update_entry called 200 returned 1000locks executed 80%
187:      200:  174:static config_t update_entry(
188:        -:  175:    unsigned int key, 
189:        -:  176:    const entry_t item,
190:        -:  177:    const config_t conf) {
191:        -:  178:    
192:      400:  179:    if( conf == NULL ||
193:      200:  180:        key &gt;= conf-&gt;size) {
194:        -:  181:    
195:<font color=red>    #####:  182:        return conf;</font>
196:        -:  183:    } else {
197:        -:  184:    
198:      200:  185:        config_t r = conf;
199:      200:  186:        r-&gt;map[key] = item;
200:        -:  187:        
201:      200:  188:        return r;
202:        -:  189:    }
203:        -:  190:}
204:        -:  191:
205:function get_entry called 90 returned 1000locks executed 100%
206:       90:  192:entry_t get_entry(int key, const config_t conf){
207:        -:  193:
208:       90:  194:    if(conf == NULL || 
209:       80:  195:        key &lt; 0 || 
210:       80:  196:        key &gt; conf-&gt;size) {
211:        -:  197:        
212:       10:  198:        return NULL;    
213:        -:  199:    }
214:        -:  200:    
215:       80:  201:    return conf-&gt;map[key];
216:        -:  202:}
217:        -:  203:
218:function get_var_key called 10 returned 1000locks executed 86%
219:       10:  204:int get_var_key(const char * name){
220:       30:  205:    for(int i = 0; i &lt; N_VARIABLE_PARAMS; i++) {
221:       30:  206:        if(!strcmp(name, Variable_params[i])) {
222:        -:  207:            
223:       10:  208:            return i;
224:        -:  209:        }
225:        -:  210:    }
226:        -:  211:    
227:<font color=red>    #####:  212:    return PLC_ERR;</font>
228:        -:  213:}
229:        -:  214:
230:function get_key called 28 returned 1000locks executed 100%
231:       28:  215:int get_key(const char * name, const config_t where) {
232:       28:  216:     if(where != NULL){
233:        -:  217:    
234:      216:  218:        for(int i = 0; i &lt; where-&gt;size; i++) {
235:      318:  219:            if( where-&gt;map[i] != NULL &&
236:      104:  220:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
237:        -:  221:                
238:       26:  222:                return i;
239:        -:  223:            }
240:        -:  224:        }
241:        -:  225:    }
242:        -:  226:    
243:        2:  227:    return PLC_ERR;  
244:        -:  228:}
245:        -:  229:
246:function new_config called 40 returned 1000locks executed 100%
247:       40:  230:config_t new_config(int size) {
248:       40:  231:    config_t r = (config_t)malloc(sizeof(struct config));
249:       40:  232:	memset(r, 0, sizeof(struct config));
250:       40:  233:	r-&gt;size = size;
251:       40:  234:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
252:       40:  235:    memset(r-&gt;map, 0, size*sizeof(struct entry));
253:        -:  236:    
254:       40:  237:	return r;
255:        -:  238:}
256:        -:  239:
257:function new_sequence called 64 returned 1000locks executed 100%
258:       64:  240:sequence_t new_sequence(int size) {
259:       64:  241:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
260:       64:  242:	memset(r, 0, sizeof(struct sequence));
261:       64:  243:	r-&gt;size = size;
262:       64:  244:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
263:       64:  245:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
264:        -:  246:	/*
265:        -:  247:	int i = 0;
266:        -:  248:	for(; i &lt; size; i++){
267:        -:  249:	     
268:        -:  250:	}
269:        -:  251:    */
270:       64:  252:	return r;
271:        -:  253:}
272:        -:  254:
273:function init_config called 8 returned 1000locks executed 100%
274:        8:  255:config_t init_config(){
275:        -:  256: //note: in a c++ implementation this all can be done automatically 
276:        -:  257: //using a hashmap
277:        8:  258:    config_t conf = new_config(N_CONFIG_VARIABLES);
278:        -:  259:   
279:        8:  260:    config_t uspace = new_config(N_USPACE_VARS);
280:        -:  261:        
281:        8:  262:    uspace = update_entry(
282:        -:  263:        USPACE_BASE,
283:        -:  264:	    new_entry_int(50176, "USPACE_BASE"),
284:        -:  265:	    uspace);
285:        -:  266:	
286:        8:  267:	uspace = update_entry(
287:        -:  268:	    USPACE_WR, 
288:        -:  269:	    new_entry_int(0, "USPACE_WR"),
289:        -:  270:	    uspace);
290:        -:  271:	    
291:        8:  272:	uspace = update_entry(
292:        -:  273:	    USPACE_RD, 
293:        -:  274:	    new_entry_int(8, "USPACE_RD"),
294:        -:  275:	    uspace);
295:        -:  276:	
296:        8:  277:	config_t subdev = new_config(N_SUBDEV_VARS);
297:        -:  278:	
298:        8:  279:    subdev = update_entry(
299:        -:  280:        SUBDEV_IN,
300:        -:  281:	    new_entry_int(0, "SUBDEV_IN"),
301:        -:  282:	    subdev);
302:        -:  283:	    
303:        8:  284:	subdev = update_entry(
304:        -:  285:	    SUBDEV_OUT,
305:        -:  286:	    new_entry_int(1, "SUBDEV_OUT"),
306:        -:  287:	    subdev);
307:        -:  288:	    
308:        8:  289:    subdev = update_entry(
309:        -:  290:        SUBDEV_ADC, 
310:        -:  291:	    new_entry_int(2, "SUBDEV_ADC"),
311:        -:  292:	    subdev);
312:        -:  293:	    
313:        8:  294:	subdev = update_entry(
314:        -:  295:	    SUBDEV_DAC, 
315:        -:  296:	    new_entry_int(3, "SUBDEV_DAC"),
316:        -:  297:	    subdev);
317:        -:  298:	
318:        8:  299:	config_t comedi = new_config(N_COMEDI_VARS);
319:        -:  300:	
320:        8:  301:	comedi = update_entry(
321:        -:  302:	    COMEDI_FILE,
322:        -:  303:	    new_entry_int(0, "COMEDI_FILE"),
323:        -:  304:	    comedi);
324:        -:  305:	    
325:        8:  306:	comedi = update_entry(
326:        -:  307:	    COMEDI_SUBDEV, 
327:        -:  308:	    new_entry_map(subdev, "COMEDI_SUBDEV"),
328:        -:  309:	    comedi);
329:        -:  310:    
330:        8:  311:    config_t sim = new_config(N_SIM_VARS);
331:        -:  312:    
332:        8:  313:    sim = update_entry(
333:        -:  314:        SIM_INPUT,
334:        -:  315:        new_entry_str("sim.in", "SIM_INPUT"), 
335:        -:  316:        sim);
336:        -:  317:        
337:        8:  318:    sim = update_entry(
338:        -:  319:        SIM_OUTPUT,
339:        -:  320:        new_entry_str("sim.out", "SIM_OUTPUT"),
340:        -:  321:        sim);    
341:        -:  322:
342:        8:  323:    conf = update_entry(
343:        -:  324:        CONFIG_STEP,
344:        -:  325:        new_entry_int(1, "STEP"),
345:        -:  326:        conf);
346:        -:  327:    
347:        8:  328:    conf = update_entry(
348:        -:  329:        CONFIG_PIPE,
349:        -:  330:        new_entry_str("plcpipe", "PIPE"),
350:        -:  331:        conf);
351:        -:  332:    
352:        8:  333:    conf = update_entry(
353:        -:  334:        CONFIG_HW,
354:        -:  335:        new_entry_str("STDI/O", "HW"),
355:        -:  336:        conf);
356:        -:  337:        
357:        8:  338:    conf = update_entry(
358:        -:  339:        CONFIG_USPACE,
359:        -:  340:        new_entry_map(uspace, "USPACE"),
360:        -:  341:        conf);
361:        -:  342:    
362:        8:  343:    conf = update_entry(
363:        -:  344:        CONFIG_COMEDI,
364:        -:  345:        new_entry_map(comedi, "COMEDI"),
365:        -:  346:        conf);
366:        -:  347:    
367:        8:  348:    conf = update_entry(
368:        -:  349:        CONFIG_SIM,
369:        -:  350:        new_entry_map(sim, "SIM"),
370:        -:  351:        conf);
371:        -:  352:   /*******************************************/
372:        -:  353:   
373:        8:  354:    conf = update_entry(
374:        -:  355:        CONFIG_TIMER,
375:        -:  356:        new_entry_seq(new_sequence(4), "TIMERS"),
376:        -:  357:        conf);
377:        -:  358:    
378:        8:  359:    conf = update_entry(
379:        -:  360:        CONFIG_PULSE,
380:        -:  361:        new_entry_seq(new_sequence(4), "PULSES"),
381:        -:  362:        conf);
382:        -:  363:        
383:        8:  364:    conf = update_entry(
384:        -:  365:        CONFIG_MREG,
385:        -:  366:        new_entry_seq(new_sequence(4), "MREG"),
386:        -:  367:        conf);
387:        -:  368:        
388:        8:  369:    conf = update_entry(
389:        -:  370:        CONFIG_MVAR,
390:        -:  371:        new_entry_seq(new_sequence(4), "MVAR"),
391:        -:  372:        conf);
392:        -:  373:    
393:        8:  374:    conf = update_entry(
394:        -:  375:        CONFIG_DI,
395:        -:  376:        new_entry_seq(new_sequence(8), "DI"),
396:        -:  377:        conf);
397:        -:  378: 
398:        8:  379:    conf = update_entry(
399:        -:  380:        CONFIG_DQ,
400:        -:  381:        new_entry_seq(new_sequence(8), "DQ"),
401:        -:  382:        conf);
402:        -:  383:    
403:        8:  384:    conf = update_entry(
404:        -:  385:        CONFIG_AI,
405:        -:  386:        new_entry_seq(new_sequence(8), "AI"),
406:        -:  387:        conf);
407:        -:  388:    
408:        8:  389:    conf = update_entry(
409:        -:  390:        CONFIG_AQ,
410:        -:  391:        new_entry_seq(new_sequence(8), "AQ"),
411:        -:  392:        conf);
412:        -:  393:
413:        8:  394:    return conf;
414:        -:  395:}
415:        -:  396:
416:function clear_config called 4 returned 1000locks executed 100%
417:        4:  397:void clear_config(config_t *c){
418:        -:  398:
419:        4:  399:}
420:        -:  400:
421:function log_yml_event called 0 returned 00locks executed 0%
422:<font color=red>    #####:  401:static int log_yml_event(yaml_event_t event){</font>
423:        -:  402:
424:<font color=red>    #####:  403:    switch(event.type){ </font>
425:        -:  404:    
426:        -:  405:        case YAML_NO_EVENT: 
427:<font color=red>    #####:  406:        	plc_log("No event!"); </font>
428:<font color=red>    #####:  407:            break;</font>
429:        -:  408:    /* Stream start/end */
430:        -:  409:        case YAML_STREAM_START_EVENT: 
431:<font color=red>    #####:  410:        	plc_log("STREAM START"); </font>
432:<font color=red>    #####:  411:            break;</font>
433:        -:  412:        case YAML_STREAM_END_EVENT: 
434:<font color=red>    #####:  413:        	plc_log("STREAM END");   </font>
435:<font color=red>    #####:  414:            break;</font>
436:        -:  415:    /* Block delimeters */
437:        -:  416:        case YAML_DOCUMENT_START_EVENT: 
438:<font color=red>    #####:  417:        	plc_log("Start Document"); </font>
439:<font color=red>    #####:  418:            break;</font>
440:        -:  419:        case YAML_DOCUMENT_END_EVENT: 
441:<font color=red>    #####:  420:        	plc_log("End Document");   </font>
442:<font color=red>    #####:  421:            break;</font>
443:        -:  422:        case YAML_SEQUENCE_START_EVENT: 
444:<font color=red>    #####:  423:        	plc_log("Start Sequence"); </font>
445:<font color=red>    #####:  424:            break;</font>
446:        -:  425:        case YAML_SEQUENCE_END_EVENT: 
447:<font color=red>    #####:  426:        	plc_log("End Sequence");</font>
448:<font color=red>    #####:  427:            break;</font>
449:        -:  428:        case YAML_MAPPING_START_EVENT: 
450:<font color=red>    #####:  429:        	plc_log("Start Mapping");         </font>
451:<font color=red>    #####:  430:            break;</font>
452:        -:  431:        case YAML_MAPPING_END_EVENT: 
453:<font color=red>    #####:  432:        	plc_log("End Mapping");      </font>
454:<font color=red>    #####:  433:            break;</font>
455:        -:  434:    /* Data */
456:        -:  435:        case YAML_ALIAS_EVENT:  
457:<font color=red>    #####:  436:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
458:<font color=red>    #####:  437:            break;</font>
459:        -:  438:        case YAML_SCALAR_EVENT: 
460:<font color=red>    #####:  439:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
461:<font color=red>    #####:  440:        	break;</font>
462:        -:  441:        default:
463:<font color=red>    #####:  442:            plc_log("default?");</font>
464:        -:  443:    }
465:<font color=red>    #####:  444:    return PLC_OK;</font>
466:        -:  445:}
467:        -:  446:
468:function strdup_r called 18 returned 1000locks executed 100%
469:       18:  447:char * strdup_r(const char * dest, const char * src) {
470:        -:  448://strdup with realloc
471:       18:  449:    char * r = (dest == NULL)?(char *)malloc(sizeof(src)):dest;
472:        -:  450:        
473:       18:  451:    realloc(r, sizeof(src));
474:       18:  452:    memset(r, 0, sizeof(src));
475:       18:  453:    sprintf(r, "", src);
476:        -:  454:    
477:       18:  455:    return r;
478:        -:  456:}
479:        -:  457:
480:function store_value called 26 returned 1000locks executed 85%
481:       26:  458:int store_value(BYTE key, const char * value, config_t * c){
482:        -:  459:
483:        -:  460:    entry_t e; 
484:       26:  461:    if( c == NULL) 
485:<font color=red>    #####:  462:        return PLC_ERR;</font>
486:        -:  463:    
487:       26:  464:    e = get_entry(key, *c);
488:        -:  465:    
489:       26:  466:    if(e == NULL)
490:        2:  467:        return PLC_ERR;
491:        -:  468:        
492:       24:  469:    switch(e-&gt;type_tag){
493:        -:  470:         case ENTRY_INT:
494:       16:  471:            e-&gt;e.scalar_int = atoi(value);
495:       16:  472:            break;
496:        -:  473:         
497:        -:  474:         case ENTRY_STR:
498:        -:  475:         
499:        8:  476:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
500:        8:  477:            break;
501:        -:  478:            
502:<font color=red>    #####:  479:         default: return PLC_ERR;</font>
503:        -:  480:    }    
504:       24:  481:    return PLC_OK;
505:        -:  482:}
506:        -:  483:
507:function store_seq_value called 14 returned 1000locks executed 89%
508:       14:  484:int store_seq_value(BYTE seq,
509:        -:  485:                    BYTE idx, 
510:        -:  486:                    BYTE key, 
511:        -:  487:                    const char * value, 
512:        -:  488:                    config_t * c){
513:        -:  489:                    
514:       14:  490:    entry_t s = (*c)-&gt;map[seq];
515:        -:  491:    
516:       26:  492:    if( s == NULL ||
517:       24:  493:        s-&gt;type_tag != ENTRY_SEQ ||
518:       12:  494:        idx &gt;= s-&gt;e.seq-&gt;size) {
519:        -:  495:        
520:        2:  496:        return PLC_ERR;
521:        -:  497:    }            
522:        -:  498:    
523:       12:  499:    variable_t vars = s-&gt;e.seq-&gt;vars;
524:        -:  500:    
525:       12:  501:    switch(key) {
526:        -:  502:        case VARIABLE_INDEX: 
527:<font color=red>    #####:  503:            vars[idx].index = atoi(value);</font>
528:<font color=red>    #####:  504:            break;</font>
529:        -:  505:            
530:        -:  506:        case VARIABLE_ID: 
531:        2:  507:            vars[idx].name = strdup_r(vars[idx].name, value);
532:        2:  508:            break;
533:        -:  509:            
534:        -:  510:        case VARIABLE_VALUE: 
535:        2:  511:            vars[idx].value = strdup_r(vars[idx].value, value);
536:        2:  512:            break;
537:        -:  513:            
538:        -:  514:        case VARIABLE_MAX: 
539:        4:  515:            vars[idx].max = strdup_r(vars[idx].max, value);
540:        4:  516:            break; 
541:        -:  517:            
542:        -:  518:        case VARIABLE_MIN: 
543:        2:  519:            vars[idx].min = strdup_r(vars[idx].min, value);
544:        2:  520:            break;         
545:        -:  521:               
546:        -:  522:        default: 
547:        2:  523:            return PLC_ERR;    
548:        -:  524:    }
549:        -:  525:        
550:       10:  526:    return PLC_OK;                       
551:        -:  527:}
552:        -:  528:
553:function process called 30 returned 1000locks executed 96%
554:       30:  529:int process(int sequence, 
555:        -:  530:            yaml_parser_t *parser, 
556:        -:  531:            config_t conf){
557:        -:  532:             
558:       30:  533:     int ret = PLC_OK;
559:       30:  534:     BYTE storage = STORE_KEY;   
560:       30:  535:     int done = FALSE;
561:       30:  536:     int key = PLC_ERR;
562:       30:  537:     int found_seq = sequence &gt; PLC_ERR;
563:       30:  538:     int idx = PLC_ERR;
564:        -:  539:     yaml_event_t event;
565:       30:  540:     memset(&event, 0, sizeof(event));
566:        -:  541:     
567:       30:  542:     if(parser == NULL
568:        -:  543://     || parser-&gt;context == NULL 
569:       26:  544:     || conf == NULL)
570:        -:  545:     
571:        4:  546:        return PLC_ERR;
572:        -:  547:           
573:      182:  548:     while(done == FALSE){
574:        -:  549:     
575:      130:  550:        if (!yaml_parser_parse(parser, &event)){   
576:        2:  551:                yaml_parser_error(*parser);
577:        2:  552:                ret = PLC_ERR;
578:        -:  553:        } else {
579:        -:  554:   
580:      128:  555:            switch(event.type){
581:        -:  556:            
582:        -:  557:                case YAML_SCALAR_EVENT: {
583:       60:  558:                    char * val = (char *)event.data.scalar.value;
584:        -:  559:                    
585:       60:  560:                    if(storage == STORE_KEY) {
586:       34:  561:                        if(found_seq) {
587:        -:  562:                            
588:       10:  563:                            key = get_var_key(val);
589:        -:  564:                        } else {
590:        -:  565:                        
591:       24:  566:                            key = get_key(val,conf);    
592:        -:  567:                        }
593:       34:  568:                        storage = STORE_VAL;
594:        -:  569:                    } else {
595:        -:  570:   
596:       26:  571:                        if(found_seq) {
597:        -:  572:                        
598:       10:  573:                            if(key == VARIABLE_INDEX){
599:        -:  574:                             
600:        2:  575:                                 idx = atoi(val);
601:        -:  576:                            } else {  
602:        -:  577:                             
603:        8:  578:                                ret = store_seq_value(
604:        -:  579:                                         sequence, 
605:        -:  580:                                         idx, 
606:        -:  581:                                         key, 
607:        -:  582:                                         val, 
608:        -:  583:                                         &conf);       
609:        -:  584:                            }   
610:        -:  585:                        } else {
611:        -:  586:                        
612:       16:  587:                            ret = store_value(key, val, &conf);
613:        -:  588:                        }
614:       26:  589:                        storage = STORE_KEY;    
615:        -:  590:                    }
616:       60:  591:                }   break;
617:        -:  592:                
618:        -:  593:                case YAML_SEQUENCE_START_EVENT:
619:        -:  594:                
620:        2:  595:                    found_seq = TRUE;
621:        2:  596:                    break;
622:        -:  597:                
623:        -:  598:                case YAML_SEQUENCE_END_EVENT:
624:        -:  599:                
625:        2:  600:                    found_seq = FALSE;
626:        2:  601:                    break;
627:        -:  602:                
628:        -:  603:                case YAML_MAPPING_START_EVENT: {
629:        -:  604:                    
630:       16:  605:                    entry_t c = get_entry(key, conf);
631:       24:  606:                    if( c != NULL &&
632:        8:  607:                        c-&gt;type_tag == ENTRY_MAP) {
633:        -:  608:                    
634:        6:  609:                        ret = process(
635:        -:  610:                            found_seq?key:-1, 
636:        -:  611:                            parser, 
637:        -:  612:                            c-&gt;e.conf);
638:        -:  613:                        
639:        -:  614:                    } else {
640:        -:  615:                    
641:       10:  616:                        ret = process(
642:        -:  617:                            found_seq?key:-1, 
643:        -:  618:                            parser, 
644:        -:  619:                            conf);
645:        -:  620:                    }
646:       16:  621:                    storage = STORE_KEY;
647:        -:  622:                    
648:       16:  623:                }   break;
649:        -:  624:                    
650:        -:  625:                case YAML_MAPPING_END_EVENT:
651:        -:  626:                case YAML_STREAM_END_EVENT:     
652:        -:  627:                    
653:       24:  628:                    done = TRUE;
654:       24:  629:                    break;
655:        -:  630:                    
656:        -:  631:                case YAML_NO_EVENT:
657:<font color=red>    #####:  632:                    ret = PLC_ERR;</font>
658:<font color=red>    #####:  633:                    break;    </font>
659:        -:  634:                    
660:       24:  635:                default: break;    
661:        -:  636:            }
662:        -:  637:         }
663:      130:  638:         if(ret &lt; PLC_OK) {
664:        2:  639:             done = TRUE;
665:        -:  640:             //log_yml_event(event);
666:        -:  641:         }                                              
667:      130:  642:         yaml_event_delete(&event);   
668:        -:  643:     }
669:        -:  644:     
670:       26:  645:     return ret;
671:        -:  646:}
672:        -:  647:             
673:function load_config_yml called 0 returned 00locks executed 0%
674:<font color=red>    #####:  648:int load_config_yml(const char * filename, config_t conf) {</font>
675:        -:  649:    yaml_parser_t parser;
676:        -:  650:    
677:        -:  651:    FILE * fcfg;
678:        -:  652:    char path[MAXSTR];
679:        -:  653:
680:<font color=red>    #####:  654:    memset(path, 0, MAXSTR);</font>
681:<font color=red>    #####:  655:    sprintf(path, "", filename);</font>
682:        -:  656:    
683:<font color=red>    #####:  657:    memset(&parser, 0, sizeof(parser));</font>
684:        -:  658:    
685:<font color=red>    #####:  659:    int r = PLC_OK;</font>
686:        -:  660:    
687:<font color=red>    #####:  661:    if (!yaml_parser_initialize(&parser)) {</font>
688:<font color=red>    #####:  662:        yaml_parser_error(parser);</font>
689:<font color=red>    #####:  663:        return PLC_ERR;    </font>
690:        -:  664:    }
691:<font color=red>    #####:  665:    if ((fcfg = fopen(path, "r"))) {</font>
692:<font color=red>    #####:  666:        plc_log("Looking for configuration from  ...", path);</font>
693:<font color=red>    #####:  667:        yaml_parser_set_input_file(&parser, fcfg);</font>
694:<font color=red>    #####:  668:        r = process(PLC_ERR, &parser, conf);</font>
695:<font color=red>    #####:  669:        if(r &lt; PLC_OK)</font>
696:<font color=red>    #####:  670:            plc_log( "Configuration error ");</font>
697:<font color=red>    #####:  671:        fclose(fcfg);</font>
698:        -:  672:    } else {
699:<font color=red>    #####:  673:        r = PLC_ERR;</font>
700:<font color=red>    #####:  674:        plc_log("Could not open file ", filename);</font>
701:        -:  675:    }
702:<font color=red>    #####:  676:    yaml_parser_delete(&parser);</font>
703:<font color=red>    #####:  677:    return r;</font>
704:        -:  678:}
705:        -:  679:
706:function emit_variable called 96 returned 1000locks executed 7%
707:       96:  680:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
708:        -:  681:    yaml_event_t evt;
709:       96:  682:    if( var-&gt;name != NULL &&
710:<font color=red>    #####:  683:        var-&gt;name[0]) {</font>
711:        -:  684:       
712:        -:  685:       char idx[4];
713:<font color=red>    #####:  686:       memset(idx, 0, 4);</font>
714:        -:  687:    
715:<font color=red>    #####:  688:       yaml_mapping_start_event_initialize(</font>
716:        -:  689:    			        &evt,
717:        -:  690:    			        NULL,
718:        -:  691:    			        NULL,
719:        -:  692:    			        FALSE,
720:        -:  693:    			        YAML_BLOCK_MAPPING_STYLE);
721:        -:  694:    	 	    
722:<font color=red>    #####:  695:       yaml_emitter_emit(emitter, &evt);</font>
723:        -:  696:    		//log_yml_event(evt);
724:        -:  697:    		            
725:<font color=red>    #####:  698:       yaml_scalar_event_initialize(</font>
726:        -:  699:                        	&evt,
727:        -:  700:                    	    NULL,
728:        -:  701:                    		NULL,
729:        -:  702:                    		"INDEX",
730:        -:  703:                    		5,
731:        -:  704:                    		TRUE,
732:        -:  705:                    		TRUE, 
733:        -:  706:                    		YAML_PLAIN_SCALAR_STYLE); 
734:<font color=red>    #####:  707:       yaml_emitter_emit(emitter, &evt);</font>
735:        -:  708:                    		
736:<font color=red>    #####:  709:       sprintf(idx, "0", var-&gt;index);		</font>
737:<font color=red>    #####:  710:       yaml_scalar_event_initialize(</font>
738:        -:  711:                        	&evt,
739:        -:  712:                    	    NULL,
740:        -:  713:                    		NULL,
741:        -:  714:                    		(unsigned char *)idx,
742:<font color=red>    #####:  715:                    		strlen(idx),</font>
743:        -:  716:                    		TRUE,
744:        -:  717:                    		TRUE, 
745:        -:  718:                    		YAML_PLAIN_SCALAR_STYLE); 	
746:<font color=red>    #####:  719:       yaml_emitter_emit(emitter, &evt);</font>
747:        -:  720:    		            
748:        -:  721:   
749:<font color=red>    #####:  722:       yaml_scalar_event_initialize(</font>
750:        -:  723:                        	&evt,
751:        -:  724:                    	    NULL,
752:        -:  725:                    		NULL,
753:        -:  726:                    		"ID",
754:        -:  727:                    		2,
755:        -:  728:                    		TRUE,
756:        -:  729:                    		TRUE, 
757:        -:  730:                    		YAML_PLAIN_SCALAR_STYLE); 
758:<font color=red>    #####:  731:       yaml_emitter_emit(emitter, &evt);</font>
759:        -:  732:                    			
760:<font color=red>    #####:  733:       yaml_scalar_event_initialize(</font>
761:        -:  734:                        	&evt,
762:        -:  735:                    	    NULL,
763:        -:  736:                    		NULL,
764:<font color=red>    #####:  737:                    		(unsigned char *)var-&gt;name,</font>
765:<font color=red>    #####:  738:                    		strlen(var-&gt;name),</font>
766:        -:  739:                    		TRUE,
767:        -:  740:                    		TRUE, 
768:        -:  741:                    		YAML_PLAIN_SCALAR_STYLE); 	
769:<font color=red>    #####:  742:       yaml_emitter_emit(emitter, &evt);</font>
770:        -:  743:
771:<font color=red>    #####:  744:       yaml_scalar_event_initialize(</font>
772:        -:  745:                        	&evt,
773:        -:  746:                    	    NULL,
774:        -:  747:                    		NULL,
775:        -:  748:                    		"VALUE",
776:        -:  749:                    		5,
777:        -:  750:                    		TRUE,
778:        -:  751:                    		TRUE, 
779:        -:  752:                    		YAML_PLAIN_SCALAR_STYLE); 
780:<font color=red>    #####:  753:       yaml_emitter_emit(emitter, &evt);</font>
781:        -:  754:                    			
782:<font color=red>    #####:  755:       yaml_scalar_event_initialize(</font>
783:        -:  756:                        	&evt,
784:        -:  757:                    	    NULL,
785:        -:  758:                    		NULL,
786:<font color=red>    #####:  759:                    		(unsigned char *)var-&gt;value,</font>
787:<font color=red>    #####:  760:                    		strlen(var-&gt;value),</font>
788:        -:  761:                    		TRUE,
789:        -:  762:                    		TRUE, 
790:        -:  763:                    		YAML_PLAIN_SCALAR_STYLE); 	
791:<font color=red>    #####:  764:        yaml_emitter_emit(emitter, &evt);</font>
792:<font color=red>    #####:  765:        if(strcmp(var-&gt;min, var-&gt;max)) {</font>
793:<font color=red>    #####:  766:            yaml_scalar_event_initialize(</font>
794:        -:  767:                        	&evt,
795:        -:  768:                    	    NULL,
796:        -:  769:                    		NULL,
797:        -:  770:                    		"MIN",
798:        -:  771:                    		3,
799:        -:  772:                    		TRUE,
800:        -:  773:                    		TRUE, 
801:        -:  774:                    		YAML_PLAIN_SCALAR_STYLE); 
802:<font color=red>    #####:  775:            yaml_emitter_emit(emitter, &evt);</font>
803:        -:  776:                    			
804:<font color=red>    #####:  777:            yaml_scalar_event_initialize(</font>
805:        -:  778:                        	&evt,
806:        -:  779:                    	    NULL,
807:        -:  780:                    		NULL,
808:<font color=red>    #####:  781:                    		(unsigned char *)var-&gt;min,</font>
809:<font color=red>    #####:  782:                    		strlen(var-&gt;min),</font>
810:        -:  783:                    		TRUE,
811:        -:  784:                    		TRUE, 
812:        -:  785:                    		YAML_PLAIN_SCALAR_STYLE); 	
813:<font color=red>    #####:  786:            yaml_emitter_emit(emitter, &evt);</font>
814:        -:  787:
815:<font color=red>    #####:  788:            yaml_scalar_event_initialize(</font>
816:        -:  789:                        	&evt,
817:        -:  790:                    	    NULL,
818:        -:  791:                    		NULL,
819:        -:  792:                    		"MAX",
820:        -:  793:                    		3,
821:        -:  794:                    		TRUE,
822:        -:  795:                    		TRUE, 
823:        -:  796:                    		YAML_PLAIN_SCALAR_STYLE); 
824:<font color=red>    #####:  797:            yaml_emitter_emit(emitter, &evt);</font>
825:        -:  798:                    			
826:<font color=red>    #####:  799:            yaml_scalar_event_initialize(</font>
827:        -:  800:                        	&evt,
828:        -:  801:                    	    NULL,
829:        -:  802:                    		NULL,
830:<font color=red>    #####:  803:                    		(unsigned char *)var-&gt;max,</font>
831:<font color=red>    #####:  804:                    		strlen(var-&gt;max),</font>
832:        -:  805:                    		TRUE,
833:        -:  806:                    		TRUE, 
834:        -:  807:                    		YAML_PLAIN_SCALAR_STYLE); 	
835:<font color=red>    #####:  808:            yaml_emitter_emit(emitter, &evt);</font>
836:        -:  809:        }       
837:<font color=red>    #####:  810:        yaml_mapping_end_event_initialize(&evt); 	</font>
838:<font color=red>    #####:  811:        yaml_emitter_emit(emitter, &evt); </font>
839:        -:  812:    }
840:       96:  813:} 
841:        -:  814:
842:function emit_entry called 50 returned 1000locks executed 97%
843:       50:  815:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
844:       50:  816:    int i = 0;
845:        -:  817:    yaml_event_t evt;
846:        -:  818:     
847:      100:  819:    yaml_scalar_event_initialize(
848:        -:  820:    	&evt,
849:        -:  821:	    NULL,
850:        -:  822:		NULL,
851:       50:  823:		(unsigned char *)entry-&gt;name,
852:       50:  824:		strlen(entry-&gt;name),
853:        -:  825:		TRUE,
854:        -:  826:		TRUE, 
855:        -:  827:		YAML_PLAIN_SCALAR_STYLE); 	
856:        -:  828:		
857:       50:  829:	yaml_emitter_emit(emitter, &evt);
858:        -:  830:	//log_yml_event(evt);
859:        -:  831:	char buf[TINYBUF];
860:       50:  832:	memset(buf, 0, TINYBUF);
861:       50:  833:	entry_t iter = NULL;
862:       50:  834:	variable_t viter = NULL;
863:        -:  835:	
864:       50:  836:	switch (entry-&gt;type_tag){
865:        -:  837:	
866:        -:  838:		case ENTRY_STR:
867:        -:  839:		
868:       16:  840:			yaml_scalar_event_initialize(
869:        -:  841:    		&evt,
870:        -:  842:	    	NULL,
871:        -:  843:			NULL,
872:        8:  844:			(unsigned char *)entry-&gt;e.scalar_str,
873:        8:  845:			strlen(entry-&gt;e.scalar_str),
874:        -:  846:			TRUE,
875:        -:  847:			TRUE, 
876:        -:  848:			YAML_PLAIN_SCALAR_STYLE); 	
877:        -:  849:		
878:        8:  850:			yaml_emitter_emit(emitter, &evt); 
879:        -:  851:			//log_yml_event(evt);		
880:        8:  852:			break;
881:        -:  853:		
882:        -:  854:		case ENTRY_INT:
883:        -:  855:			
884:       18:  856:			sprintf(buf, "0", entry-&gt;e.scalar_int);
885:       18:  857:			yaml_scalar_event_initialize(
886:        -:  858:    		&evt,
887:        -:  859:	    	NULL,
888:        -:  860:			NULL,
889:        -:  861:			(unsigned char *)buf,
890:       18:  862:			strlen(buf),
891:        -:  863:			TRUE,
892:        -:  864:			TRUE, 
893:        -:  865:			YAML_PLAIN_SCALAR_STYLE); 	
894:        -:  866:		
895:       18:  867:			yaml_emitter_emit(emitter, &evt);
896:        -:  868:			//log_yml_event(evt); 		
897:       18:  869:			break;
898:        -:  870:				 
899:        -:  871:		case ENTRY_MAP:
900:        -:  872:		
901:        8:  873:		    yaml_mapping_start_event_initialize(
902:        -:  874:    			&evt,
903:        -:  875:    			NULL,
904:        -:  876:    			NULL,
905:        -:  877:    			FALSE,
906:        -:  878:    			YAML_BLOCK_MAPPING_STYLE);
907:        -:  879:    	 	    
908:        8:  880:    		yaml_emitter_emit(emitter, &evt);
909:        -:  881:    		//log_yml_event(evt);
910:        8:  882:    		iter = *(entry-&gt;e.conf-&gt;map);
911:        -:  883:    		
912:       38:  884:			while(i &lt; entry-&gt;e.conf-&gt;size){
913:       22:  885:			    if(iter != NULL) {
914:       22:  886:				    emit_entry(iter, emitter);  
915:        -:  887:				}
916:       22:  888:				iter = (entry-&gt;e.conf-&gt;map)[++i];
917:        -:  889:			}	
918:        8:  890:			yaml_mapping_end_event_initialize(&evt); 	
919:        8:  891:    		yaml_emitter_emit(emitter, &evt); 
920:        -:  892:    		//log_yml_event(evt);
921:        8:  893:			break;
922:        -:  894:		
923:        -:  895:		case ENTRY_SEQ:
924:       16:  896:		  yaml_sequence_start_event_initialize(
925:        -:  897:    			&evt,
926:        -:  898:    			NULL,
927:        -:  899:    			NULL,
928:        -:  900:    			TRUE,
929:        -:  901:    			YAML_BLOCK_SEQUENCE_STYLE);
930:        -:  902:    		//log_yml_event(evt);
931:       16:  903:    	    yaml_emitter_emit(emitter, &evt); 	
932:        -:  904:		//emit size as int
933:        -:  905:		  
934:       16:  906:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
935:       16:  907:			yaml_scalar_event_initialize(
936:        -:  908:    		&evt,
937:        -:  909:	    	NULL,
938:        -:  910:			NULL,
939:        -:  911:			(unsigned char *)buf,
940:       16:  912:			strlen(buf),
941:        -:  913:			TRUE,
942:        -:  914:			TRUE, 
943:        -:  915:			YAML_PLAIN_SCALAR_STYLE); 	
944:        -:  916:		
945:       16:  917:			yaml_emitter_emit(emitter, &evt);
946:        -:  918:			//log_yml_event(evt); 		
947:        -:  919:			//emit values as map
948:       16:  920:			viter = entry-&gt;e.seq-&gt;vars;
949:        -:  921:    		
950:       16:  922:    		i = 0;
951:      128:  923:			while(i &lt; entry-&gt;e.seq-&gt;size){
952:       96:  924:			    if(viter != NULL) {
953:       96:  925:				   emit_variable(viter, emitter);
954:        -:  926:				}
955:       96:  927:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
956:        -:  928:			}	
957:        -:  929:			
958:       16:  930:			yaml_sequence_end_event_initialize(&evt); 	
959:       16:  931:    		yaml_emitter_emit(emitter, &evt); 
960:        -:  932:    		//log_yml_event(evt);
961:       16:  933:			break;
962:        -:  934:			
963:<font color=red>    #####:  935:		default:break;</font>
964:        -:  936:	}
965:        -:  937:	
966:       50:  938:}
967:        -:  939:
968:function emit called 2 returned 1000locks executed 100%
969:        2:  940:int emit(yaml_emitter_t *emitter, const config_t conf) {
970:        2:  941:    int r = PLC_OK;     
971:        -:  942:   
972:        -:  943:    yaml_event_t evt;
973:        -:  944:    char val[MAXSTR];
974:        2:  945:    memset(val,0,MAXSTR);
975:        -:  946:    //doc start
976:        2:  947:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, FALSE); 
977:        2:  948:	yaml_emitter_emit(emitter, &evt); 		
978:        -:  949:   // log_yml_event(evt);
979:        -:  950:    
980:        2:  951:    yaml_mapping_start_event_initialize(
981:        -:  952:    	&evt,
982:        -:  953:    	NULL,
983:        -:  954:    	NULL,
984:        -:  955:    	FALSE,
985:        -:  956:    	YAML_BLOCK_MAPPING_STYLE);
986:        -:  957:    	 	    
987:        2:  958:    yaml_emitter_emit(emitter, &evt);
988:        -:  959:   // log_yml_event(evt);
989:        -:  960:    
990:        -:  961:     
991:        2:  962:    entry_map_t config_map = conf-&gt;map;
992:        2:  963:    entry_t iter = *config_map;
993:        2:  964:    int i = 0;
994:       60:  965:    while(i &lt; N_CONFIG_VARIABLES) {
995:       56:  966:        if(iter != NULL){
996:       28:  967:    	    emit_entry(iter, emitter);
997:        -:  968:    	}
998:       56:  969:    	iter = config_map[++i];
999:        -:  970:    }
1000:        -:  971:   
1001:        -:  972:    //mapping end
1002:        2:  973:    yaml_mapping_end_event_initialize(&evt); 	
1003:        2:  974:    yaml_emitter_emit(emitter, &evt); 		
1004:        -:  975:    //log_yml_event(evt);
1005:        -:  976:    
1006:        -:  977:    //doc end
1007:        2:  978:    yaml_document_end_event_initialize(&evt,FALSE);
1008:        2:  979:    yaml_emitter_emit(emitter, &evt);
1009:        -:  980:    //log_yml_event(evt); 		
1010:        2:  981:    yaml_event_delete(&evt); 	
1011:        2:  982:    return r;
1012:        -:  983:}
1013:        -:  984:
1014:function save_config_yml called 0 returned 00locks executed 0%
1015:<font color=red>    #####:  985:int save_config_yml(const char * filename, const config_t conf) {</font>
1016:        -:  986:    
1017:        -:  987:    yaml_emitter_t emitter;
1018:        -:  988:    yaml_event_t event;
1019:        -:  989:    
1020:        -:  990:    FILE * fcfg;
1021:        -:  991:    char path[MAXSTR];
1022:<font color=red>    #####:  992:    int r = PLC_OK;</font>
1023:        -:  993:    
1024:<font color=red>    #####:  994:    memset(path, 0, MAXSTR);</font>
1025:<font color=red>    #####:  995:    sprintf(path, "", filename);</font>
1026:        -:  996:
1027:<font color=red>    #####:  997:    if(!yaml_emitter_initialize(&emitter)){</font>
1028:<font color=red>    #####:  998:        return PLC_ERR;    </font>
1029:        -:  999:    }
1030:<font color=red>    #####: 1000:    if ((fcfg = fopen(path, "wb"))) {</font>
1031:<font color=red>    #####: 1001:         plc_log("Save configuration to  ...", path);</font>
1032:        -: 1002:         
1033:<font color=red>    #####: 1003:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1034:<font color=red>    #####: 1004:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1035:        -: 1005:         
1036:<font color=red>    #####: 1006:         r = yaml_emitter_emit(&emitter, &event);</font>
1037:        -: 1007:         
1038:<font color=red>    #####: 1008:         if(r)</font>
1039:<font color=red>    #####: 1009:            r = emit(&emitter, conf);</font>
1040:<font color=red>    #####: 1010:         if(r){</font>
1041:<font color=red>    #####: 1011:            yaml_stream_end_event_initialize(&event);</font>
1042:<font color=red>    #####: 1012:            r = yaml_emitter_emit(&emitter, &event);   </font>
1043:        -: 1013:         }
1044:        -: 1014:            
1045:<font color=red>    #####: 1015:         if(r &lt; PLC_OK)</font>
1046:<font color=red>    #####: 1016:            plc_log( "Configuration error ");</font>
1047:        -: 1017:            
1048:<font color=red>    #####: 1018:         fclose(fcfg);</font>
1049:        -: 1019:    } else {
1050:<font color=red>    #####: 1020:        r = PLC_ERR;</font>
1051:<font color=red>    #####: 1021:        plc_log("Could not open file  for write", filename);</font>
1052:        -: 1022:    }
1053:<font color=red>    #####: 1023:    yaml_emitter_delete(&emitter);</font>
1054:<font color=red>    #####: 1024:    return r;</font>
1055:        -: 1025:}
1056:        -: 1026:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
