<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:#include "plclib.h"
 10:        -:    5:
 11:        -:    6:const char * Config_vars[N_CONFIG_VARIABLES] = {
 12:        -:    7:    "STEP",
 13:        -:    8:    "PIPE",
 14:        -:    9:    "SIGENABLE",
 15:        -:   10:    "PAGELEN",
 16:        -:   11:    "PAGEWIDTH",
 17:        -:   12:    "HW",
 18:        -:   13:    "NT",
 19:        -:   14:    "NS",
 20:        -:   15:    "NR",
 21:        -:   16:    "NM",
 22:        -:   17:    "NDI",
 23:        -:   18:    "NDQ",
 24:        -:   19:    "NAI",
 25:        -:   20:    "NAQ",
 26:        -:   21:    "RESPONSE",
 27:        -:   22:    "USPACE",
 28:        -:   23:    "COMEDI",
 29:        -:   24:    "SIM",
 30:        -:   25:    "IL",
 31:        -:   26:    "LD",
 32:        -:   27:    //sequences
 33:        -:   28:    "AI",
 34:        -:   29:    "AQ",
 35:        -:   30:    "DI",
 36:        -:   31:    "DQ",
 37:        -:   32:    "MVAR",
 38:        -:   33:    "MREG",
 39:        -:   34:    "TIMER",
 40:        -:   35:    "PULSE"
 41:        -:   36:};
 42:        -:   37:
 43:        -:   38:const char * Variable_params[N_VARIABLE_PARAMS] = {
 44:        -:   39:    "INDEX",
 45:        -:   40:    "ID",
 46:        -:   41:    "VALUE",
 47:        -:   42:    "MIN",
 48:        -:   43:    "MAX"
 49:        -:   44:};
 50:        -:   45:
 51:function yaml_config_error called 0 returned 00locks executed 0%
 52:<font color=red>    #####:   46:static void yaml_config_error(yaml_parser_t parser){</font>
 53:        -:   47:
 54:        -:   48:    //print line
 55:<font color=red>    #####:   49:}</font>
 56:        -:   50:
 57:function yaml_parser_error called 2 returned 1000locks executed 22%
 58:        2:   51:static void yaml_parser_error(yaml_parser_t parser){
 59:        -:   52:
 60:        2:   53:     switch (parser.error)
 61:        -:   54:     {
 62:        -:   55:        case YAML_MEMORY_ERROR:
 63:<font color=red>    #####:   56:            plc_log( </font>
 64:        -:   57:            "Memory error: Not enough memory for parsing");
 65:<font color=red>    #####:   58:            break;</font>
 66:        -:   59:
 67:        -:   60:        case YAML_READER_ERROR:
 68:<font color=red>    #####:   61:            if (parser.problem_value != -1) {</font>
 69:<font color=red>    #####:   62:                plc_log( </font>
 70:        -:   63:                "Reader error: : #0 at 0", 
 71:        -:   64:                parser.problem,
 72:        -:   65:                parser.problem_value, 
 73:        -:   66:                parser.problem_offset);
 74:        -:   67:            }
 75:        -:   68:            else {
 76:<font color=red>    #####:   69:                plc_log( </font>
 77:        -:   70:                "Reader error:  at 0", 
 78:        -:   71:                parser.problem,
 79:        -:   72:                parser.problem_offset);
 80:        -:   73:            }
 81:<font color=red>    #####:   74:            break;</font>
 82:        -:   75:
 83:        -:   76:        case YAML_SCANNER_ERROR:
 84:<font color=red>    #####:   77:            if (parser.context) {</font>
 85:<font color=red>    #####:   78:                plc_log( </font>
 86:        -:   79:                "Scanner error:  at line 0, column 0"
 87:        -:   80:                        " at line 0, column 0", 
 88:        -:   81:                        parser.context,
 89:<font color=red>    #####:   82:                        parser.context_mark.line+1,</font>
 90:<font color=red>    #####:   83:                        parser.context_mark.column+1,</font>
 91:        -:   84:                        parser.problem, 
 92:<font color=red>    #####:   85:                        parser.problem_mark.line+1,</font>
 93:<font color=red>    #####:   86:                        parser.problem_mark.column+1);</font>
 94:        -:   87:            }
 95:        -:   88:            else {
 96:<font color=red>    #####:   89:                plc_log( </font>
 97:        -:   90:                "Scanner error:  at line 0, column 0",
 98:<font color=red>    #####:   91:                        parser.problem, parser.problem_mark.line+1,</font>
 99:<font color=red>    #####:   92:                        parser.problem_mark.column+1);</font>
100:        -:   93:            }
101:<font color=red>    #####:   94:            break;</font>
102:        -:   95:
103:        -:   96:        case YAML_PARSER_ERROR:
104:<font color=red>    #####:   97:            if (parser.context) {</font>
105:<font color=red>    #####:   98:                plc_log( </font>
106:        -:   99:                "Parser error:  at line 0, column 0"
107:        -:  100:                        " at line 0, column 0", 
108:        -:  101:                        parser.context,
109:<font color=red>    #####:  102:                        parser.context_mark.line+1,</font>
110:<font color=red>    #####:  103:                        parser.context_mark.column+1,</font>
111:        -:  104:                        parser.problem, 
112:<font color=red>    #####:  105:                        parser.problem_mark.line+1,</font>
113:<font color=red>    #####:  106:                        parser.problem_mark.column+1);</font>
114:        -:  107:            }
115:        -:  108:            else {
116:<font color=red>    #####:  109:                plc_log( </font>
117:        -:  110:                "Parser error:  at line 0, column 0",
118:        -:  111:                        parser.problem, 
119:<font color=red>    #####:  112:                        parser.problem_mark.line+1,</font>
120:<font color=red>    #####:  113:                        parser.problem_mark.column+1);</font>
121:        -:  114:            }
122:<font color=red>    #####:  115:            break;</font>
123:        -:  116:
124:        -:  117:        default:
125:        -:  118:            /* Couldn't happen. */
126:        2:  119:            plc_log( 
127:        -:  120:            "Internal error\n");
128:        2:  121:            break;
129:        -:  122:    }
130:        2:  123:}
131:        -:  124:
132:function new_entry_int called 72 returned 1000locks executed 100%
133:       72:  125:static entry_t new_entry_int(int i, char * name) {
134:        -:  126:
135:       72:  127:	entry_t r = (entry_t)malloc(sizeof(struct entry));
136:       72:  128:	r-&gt;type_tag = ENTRY_INT;
137:       72:  129:	r-&gt;name = name;
138:       72:  130:	r-&gt;e.scalar_int = i;
139:        -:  131:
140:       72:  132:	return r;
141:        -:  133:}
142:        -:  134:
143:function new_entry_str called 32 returned 1000locks executed 100%
144:       32:  135:static entry_t new_entry_str(char * str, char * name) {
145:        -:  136:
146:       32:  137:	entry_t r = (entry_t)malloc(sizeof(struct entry));
147:       32:  138:	r-&gt;type_tag = ENTRY_STR;
148:       32:  139:	r-&gt;name = name;
149:       32:  140:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
150:       32:  141:    sprintf(r-&gt;e.scalar_str, "", str);
151:       32:  142:	return r;
152:        -:  143:}
153:        -:  144:
154:function new_entry_map called 32 returned 1000locks executed 100%
155:       32:  145:static entry_t new_entry_map(config_t map, char * name) {
156:        -:  146:	
157:       32:  147:	entry_t r = (entry_t)malloc(sizeof(struct entry));
158:       32:  148:	r-&gt;type_tag = ENTRY_MAP;
159:       32:  149:	r-&gt;name = name;
160:       32:  150:	r-&gt;e.conf = map;
161:        -:  151:
162:       32:  152:	return r;
163:        -:  153:}
164:        -:  154:
165:function new_entry_seq called 64 returned 1000locks executed 100%
166:       64:  155:static entry_t new_entry_seq(sequence_t seq, char * name) {
167:        -:  156:	
168:       64:  157:	entry_t r = (entry_t)malloc(sizeof(struct entry));
169:       64:  158:	r-&gt;type_tag = ENTRY_SEQ;
170:       64:  159:	r-&gt;name = name;
171:       64:  160:	r-&gt;e.seq = seq;
172:        -:  161:
173:       64:  162:	return r;
174:        -:  163:}
175:        -:  164:
176:function new_entry_null called 0 returned 00locks executed 0%
177:<font color=red>    #####:  165:static entry_t new_entry_null() {</font>
178:<font color=red>    #####:  166:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
179:<font color=red>    #####:  167:	r-&gt;type_tag = ENTRY_NONE;</font>
180:<font color=red>    #####:  168:	r-&gt;name = "";</font>
181:<font color=red>    #####:  169:	r-&gt;e.scalar_int = 0;</font>
182:        -:  170:
183:<font color=red>    #####:  171:	return r;</font>
184:        -:  172:}
185:        -:  173:
186:function update_entry called 200 returned 1000locks executed 80%
187:      200:  174:static config_t update_entry(
188:        -:  175:    unsigned int key, 
189:        -:  176:    const entry_t item,
190:        -:  177:    const config_t conf) {
191:        -:  178:    
192:      400:  179:    if( conf == NULL ||
193:      200:  180:        key &gt;= conf-&gt;size) {
194:        -:  181:    
195:<font color=red>    #####:  182:        return conf;</font>
196:        -:  183:    } else {
197:        -:  184:    
198:      200:  185:        config_t r = conf;
199:      200:  186:        r-&gt;map[key] = item;
200:        -:  187:        
201:      200:  188:        return r;
202:        -:  189:    }
203:        -:  190:}
204:        -:  191:
205:function get_entry called 90 returned 1000locks executed 100%
206:       90:  192:entry_t get_entry(int key, const config_t conf){
207:        -:  193:
208:       90:  194:    if(conf == NULL || 
209:       80:  195:        key &lt; 0 || 
210:       80:  196:        key &gt; conf-&gt;size) {
211:        -:  197:        
212:       10:  198:        return NULL;    
213:        -:  199:    }
214:        -:  200:    
215:       80:  201:    return conf-&gt;map[key];
216:        -:  202:}
217:        -:  203:
218:function get_var_key called 10 returned 1000locks executed 86%
219:       10:  204:int get_var_key(const char * name){
220:       30:  205:    for(int i = 0; i &lt; N_VARIABLE_PARAMS; i++) {
221:       30:  206:        if(!strcmp(name, Variable_params[i])) {
222:        -:  207:            
223:       10:  208:            return i;
224:        -:  209:        }
225:        -:  210:    }
226:        -:  211:    
227:<font color=red>    #####:  212:    return PLC_ERR;</font>
228:        -:  213:}
229:        -:  214:
230:function get_key called 28 returned 1000locks executed 100%
231:       28:  215:int get_key(const char * name, const config_t where) {
232:       28:  216:     if(where != NULL){
233:        -:  217:    
234:      216:  218:        for(int i = 0; i &lt; where-&gt;size; i++) {
235:      318:  219:            if( where-&gt;map[i] != NULL &&
236:      104:  220:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
237:        -:  221:                
238:       26:  222:                return i;
239:        -:  223:            }
240:        -:  224:        }
241:        -:  225:    }
242:        -:  226:    
243:        2:  227:    return PLC_ERR;  
244:        -:  228:}
245:        -:  229:
246:function new_config called 40 returned 1000locks executed 100%
247:       40:  230:config_t new_config(int size) {
248:       40:  231:    config_t r = (config_t)malloc(sizeof(struct config));
249:       40:  232:	memset(r, 0, sizeof(struct config));
250:       40:  233:	r-&gt;size = size;
251:       40:  234:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
252:       40:  235:    memset(r-&gt;map, 0, size*sizeof(struct entry));
253:        -:  236:    
254:       40:  237:	return r;
255:        -:  238:}
256:        -:  239:
257:function new_sequence called 64 returned 1000locks executed 100%
258:       64:  240:sequence_t new_sequence(int size) {
259:       64:  241:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
260:       64:  242:	memset(r, 0, sizeof(struct sequence));
261:       64:  243:	r-&gt;size = size;
262:       64:  244:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
263:       64:  245:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
264:        -:  246:	
265:       64:  247:	return r;
266:        -:  248:}
267:        -:  249:
268:function init_config called 8 returned 1000locks executed 100%
269:        8:  250:config_t init_config(){
270:        -:  251: //note: in a c++ implementation this all can be done automatically 
271:        -:  252: //using a hashmap
272:        8:  253:    config_t conf = new_config(N_CONFIG_VARIABLES);
273:        -:  254:   
274:        8:  255:    config_t uspace = new_config(N_USPACE_VARS);
275:        -:  256:        
276:        8:  257:    uspace = update_entry(
277:        -:  258:        USPACE_BASE,
278:        -:  259:	    new_entry_int(50176, "USPACE_BASE"),
279:        -:  260:	    uspace);
280:        -:  261:	
281:        8:  262:	uspace = update_entry(
282:        -:  263:	    USPACE_WR, 
283:        -:  264:	    new_entry_int(0, "USPACE_WR"),
284:        -:  265:	    uspace);
285:        -:  266:	    
286:        8:  267:	uspace = update_entry(
287:        -:  268:	    USPACE_RD, 
288:        -:  269:	    new_entry_int(8, "USPACE_RD"),
289:        -:  270:	    uspace);
290:        -:  271:	
291:        8:  272:	config_t subdev = new_config(N_SUBDEV_VARS);
292:        -:  273:	
293:        8:  274:    subdev = update_entry(
294:        -:  275:        SUBDEV_IN,
295:        -:  276:	    new_entry_int(0, "SUBDEV_IN"),
296:        -:  277:	    subdev);
297:        -:  278:	    
298:        8:  279:	subdev = update_entry(
299:        -:  280:	    SUBDEV_OUT,
300:        -:  281:	    new_entry_int(1, "SUBDEV_OUT"),
301:        -:  282:	    subdev);
302:        -:  283:	    
303:        8:  284:    subdev = update_entry(
304:        -:  285:        SUBDEV_ADC, 
305:        -:  286:	    new_entry_int(2, "SUBDEV_ADC"),
306:        -:  287:	    subdev);
307:        -:  288:	    
308:        8:  289:	subdev = update_entry(
309:        -:  290:	    SUBDEV_DAC, 
310:        -:  291:	    new_entry_int(3, "SUBDEV_DAC"),
311:        -:  292:	    subdev);
312:        -:  293:	
313:        8:  294:	config_t comedi = new_config(N_COMEDI_VARS);
314:        -:  295:	
315:        8:  296:	comedi = update_entry(
316:        -:  297:	    COMEDI_FILE,
317:        -:  298:	    new_entry_int(0, "COMEDI_FILE"),
318:        -:  299:	    comedi);
319:        -:  300:	    
320:        8:  301:	comedi = update_entry(
321:        -:  302:	    COMEDI_SUBDEV, 
322:        -:  303:	    new_entry_map(subdev, "COMEDI_SUBDEV"),
323:        -:  304:	    comedi);
324:        -:  305:    
325:        8:  306:    config_t sim = new_config(N_SIM_VARS);
326:        -:  307:    
327:        8:  308:    sim = update_entry(
328:        -:  309:        SIM_INPUT,
329:        -:  310:        new_entry_str("sim.in", "SIM_INPUT"), 
330:        -:  311:        sim);
331:        -:  312:        
332:        8:  313:    sim = update_entry(
333:        -:  314:        SIM_OUTPUT,
334:        -:  315:        new_entry_str("sim.out", "SIM_OUTPUT"),
335:        -:  316:        sim);    
336:        -:  317:
337:        8:  318:    conf = update_entry(
338:        -:  319:        CONFIG_STEP,
339:        -:  320:        new_entry_int(1, "STEP"),
340:        -:  321:        conf);
341:        -:  322:    
342:        8:  323:    conf = update_entry(
343:        -:  324:        CONFIG_PIPE,
344:        -:  325:        new_entry_str("plcpipe", "PIPE"),
345:        -:  326:        conf);
346:        -:  327:    
347:        8:  328:    conf = update_entry(
348:        -:  329:        CONFIG_HW,
349:        -:  330:        new_entry_str("STDI/O", "HW"),
350:        -:  331:        conf);
351:        -:  332:        
352:        8:  333:    conf = update_entry(
353:        -:  334:        CONFIG_USPACE,
354:        -:  335:        new_entry_map(uspace, "USPACE"),
355:        -:  336:        conf);
356:        -:  337:    
357:        8:  338:    conf = update_entry(
358:        -:  339:        CONFIG_COMEDI,
359:        -:  340:        new_entry_map(comedi, "COMEDI"),
360:        -:  341:        conf);
361:        -:  342:    
362:        8:  343:    conf = update_entry(
363:        -:  344:        CONFIG_SIM,
364:        -:  345:        new_entry_map(sim, "SIM"),
365:        -:  346:        conf);
366:        -:  347:   /*******************************************/
367:        -:  348:   
368:        8:  349:    conf = update_entry(
369:        -:  350:        CONFIG_TIMER,
370:        -:  351:        new_entry_seq(new_sequence(4), "TIMERS"),
371:        -:  352:        conf);
372:        -:  353:    
373:        8:  354:    conf = update_entry(
374:        -:  355:        CONFIG_PULSE,
375:        -:  356:        new_entry_seq(new_sequence(4), "PULSES"),
376:        -:  357:        conf);
377:        -:  358:        
378:        8:  359:    conf = update_entry(
379:        -:  360:        CONFIG_MREG,
380:        -:  361:        new_entry_seq(new_sequence(4), "MREG"),
381:        -:  362:        conf);
382:        -:  363:        
383:        8:  364:    conf = update_entry(
384:        -:  365:        CONFIG_MVAR,
385:        -:  366:        new_entry_seq(new_sequence(4), "MVAR"),
386:        -:  367:        conf);
387:        -:  368:    
388:        8:  369:    conf = update_entry(
389:        -:  370:        CONFIG_DI,
390:        -:  371:        new_entry_seq(new_sequence(8), "DI"),
391:        -:  372:        conf);
392:        -:  373: 
393:        8:  374:    conf = update_entry(
394:        -:  375:        CONFIG_DQ,
395:        -:  376:        new_entry_seq(new_sequence(8), "DQ"),
396:        -:  377:        conf);
397:        -:  378:    
398:        8:  379:    conf = update_entry(
399:        -:  380:        CONFIG_AI,
400:        -:  381:        new_entry_seq(new_sequence(8), "AI"),
401:        -:  382:        conf);
402:        -:  383:    
403:        8:  384:    conf = update_entry(
404:        -:  385:        CONFIG_AQ,
405:        -:  386:        new_entry_seq(new_sequence(8), "AQ"),
406:        -:  387:        conf);
407:        -:  388:
408:        8:  389:    return conf;
409:        -:  390:}
410:        -:  391:
411:function clear_config called 4 returned 1000locks executed 100%
412:        4:  392:config_t clear_config(config_t c){
413:        -:  393:
414:        4:  394:    return (config_t)NULL;
415:        -:  395:}
416:        -:  396:
417:function log_yml_event called 0 returned 00locks executed 0%
418:<font color=red>    #####:  397:static int log_yml_event(yaml_event_t event){</font>
419:        -:  398:
420:<font color=red>    #####:  399:    switch(event.type){ </font>
421:        -:  400:    
422:        -:  401:        case YAML_NO_EVENT: 
423:<font color=red>    #####:  402:        	plc_log("No event!"); </font>
424:<font color=red>    #####:  403:            break;</font>
425:        -:  404:    /* Stream start/end */
426:        -:  405:        case YAML_STREAM_START_EVENT: 
427:<font color=red>    #####:  406:        	plc_log("STREAM START"); </font>
428:<font color=red>    #####:  407:            break;</font>
429:        -:  408:        case YAML_STREAM_END_EVENT: 
430:<font color=red>    #####:  409:        	plc_log("STREAM END");   </font>
431:<font color=red>    #####:  410:            break;</font>
432:        -:  411:    /* Block delimeters */
433:        -:  412:        case YAML_DOCUMENT_START_EVENT: 
434:<font color=red>    #####:  413:        	plc_log("Start Document"); </font>
435:<font color=red>    #####:  414:            break;</font>
436:        -:  415:        case YAML_DOCUMENT_END_EVENT: 
437:<font color=red>    #####:  416:        	plc_log("End Document");   </font>
438:<font color=red>    #####:  417:            break;</font>
439:        -:  418:        case YAML_SEQUENCE_START_EVENT: 
440:<font color=red>    #####:  419:        	plc_log("Start Sequence"); </font>
441:<font color=red>    #####:  420:            break;</font>
442:        -:  421:        case YAML_SEQUENCE_END_EVENT: 
443:<font color=red>    #####:  422:        	plc_log("End Sequence");</font>
444:<font color=red>    #####:  423:            break;</font>
445:        -:  424:        case YAML_MAPPING_START_EVENT: 
446:<font color=red>    #####:  425:        	plc_log("Start Mapping");         </font>
447:<font color=red>    #####:  426:            break;</font>
448:        -:  427:        case YAML_MAPPING_END_EVENT: 
449:<font color=red>    #####:  428:        	plc_log("End Mapping");      </font>
450:<font color=red>    #####:  429:            break;</font>
451:        -:  430:    /* Data */
452:        -:  431:        case YAML_ALIAS_EVENT:  
453:<font color=red>    #####:  432:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
454:<font color=red>    #####:  433:            break;</font>
455:        -:  434:        case YAML_SCALAR_EVENT: 
456:<font color=red>    #####:  435:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
457:<font color=red>    #####:  436:        	break;</font>
458:        -:  437:        default:
459:<font color=red>    #####:  438:            plc_log("default?");</font>
460:        -:  439:    }
461:<font color=red>    #####:  440:    return PLC_OK;</font>
462:        -:  441:}
463:        -:  442:
464:function strdup_r called 18 returned 1000locks executed 100%
465:       18:  443:char * strdup_r(const char * dest, const char * src) {
466:        -:  444://strdup with realloc
467:       18:  445:    char * r = (dest == NULL)?(char *)malloc(sizeof(src)):dest;
468:        -:  446:        
469:       18:  447:    realloc(r, sizeof(src));
470:       18:  448:    memset(r, 0, sizeof(src));
471:       18:  449:    sprintf(r, "", src);
472:        -:  450:    
473:       18:  451:    return r;
474:        -:  452:}
475:        -:  453:
476:function store_value called 26 returned 1000locks executed 85%
477:       26:  454:config_t store_value(BYTE key, const char * value, config_t config){
478:        -:  455:
479:        -:  456:    entry_t e; 
480:       26:  457:    if( config == NULL) {
481:        -:  458:    
482:<font color=red>    #####:  459:        return NULL;</font>
483:        -:  460:    }
484:        -:  461:    
485:       26:  462:    config_t conf = config;
486:       26:  463:    e = get_entry(key, conf);
487:        -:  464:    
488:       26:  465:    if(e == NULL) {
489:        2:  466:        conf-&gt;err = PLC_ERR;
490:        -:  467:        
491:        2:  468:        return conf;
492:        -:  469:    }
493:        -:  470:    
494:       24:  471:    switch(e-&gt;type_tag){
495:        -:  472:         case ENTRY_INT:
496:       16:  473:            e-&gt;e.scalar_int = atoi(value);
497:       16:  474:            break;
498:        -:  475:         
499:        -:  476:         case ENTRY_STR:
500:        -:  477:         
501:        8:  478:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
502:        8:  479:            break;
503:        -:  480:            
504:<font color=red>    #####:  481:         default: return PLC_ERR;</font>
505:        -:  482:    }        
506:       24:  483:    conf-&gt;map[key] = e;
507:        -:  484:       
508:       24:  485:    return conf;
509:        -:  486:}
510:        -:  487:
511:function store_seq_value called 14 returned 1000locks executed 100%
512:       14:  488:config_t store_seq_value(BYTE seq,
513:        -:  489:                    BYTE idx, 
514:        -:  490:                    BYTE key, 
515:        -:  491:                    const char * value, 
516:        -:  492:                    config_t config){
517:        -:  493:                    
518:       14:  494:    config_t conf = config;                
519:       14:  495:    entry_t s = conf-&gt;map[seq];
520:        -:  496:    
521:       26:  497:    if( s == NULL ||
522:       24:  498:        s-&gt;type_tag != ENTRY_SEQ ||
523:       12:  499:        idx &gt;= s-&gt;e.seq-&gt;size) {
524:        -:  500:        
525:        2:  501:        conf-&gt;err = PLC_ERR;
526:        -:  502:        
527:        2:  503:        return conf;
528:        -:  504:    }            
529:        -:  505:    
530:       36:  506:    variable_t var = &(conf-&gt;map[seq]
531:       12:  507:                            -&gt;e.seq
532:       24:  508:                            -&gt;vars[idx]);
533:        -:  509:    
534:       12:  510:    conf-&gt;map[seq]
535:       12:  511:                -&gt;e.seq
536:       12:  512:                -&gt;vars[idx].index = idx;
537:        -:  513:     
538:       12:  514:    switch(key) {
539:        -:  515:                
540:        -:  516:        case VARIABLE_ID: 
541:        -:  517:            
542:        2:  518:            conf-&gt;map[seq]
543:        2:  519:                -&gt;e.seq
544:        2:  520:                -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
545:        2:  521:            break;
546:        -:  522:            
547:        -:  523:        case VARIABLE_VALUE: 
548:        2:  524:            conf-&gt;map[seq]
549:        2:  525:                -&gt;e.seq
550:        2:  526:                -&gt;vars[idx].value = strdup_r(var-&gt;value, value);
551:        2:  527:            break;
552:        -:  528:            
553:        -:  529:        case VARIABLE_MAX: 
554:        4:  530:            conf-&gt;map[seq]
555:        4:  531:                -&gt;e.seq
556:        4:  532:                -&gt;vars[idx].max = strdup_r(var-&gt;max, value);
557:        4:  533:            break; 
558:        -:  534:            
559:        -:  535:        case VARIABLE_MIN: 
560:        2:  536:            conf-&gt;map[seq]
561:        2:  537:                -&gt;e.seq
562:        2:  538:                -&gt;vars[idx].min = strdup_r(var-&gt;min, value);
563:        2:  539:            break;         
564:        -:  540:               
565:        -:  541:        default: case VARIABLE_INDEX: 
566:        -:  542:         
567:        2:  543:            conf-&gt;err = PLC_ERR;    
568:        -:  544:    }
569:        -:  545:   
570:       12:  546:    return conf;                       
571:        -:  547:}
572:        -:  548:
573:function process_scalar called 60 returned 1000locks executed 100%
574:       60:  549:static config_t process_scalar(
575:        -:  550:                   yaml_event_t event,
576:        -:  551:                   int sequence, 
577:        -:  552:                   BYTE * storage,
578:        -:  553:                   int * key,
579:        -:  554:                   int * idx,
580:        -:  555:                   config_t config){
581:        -:  556:    
582:       60:  557:    config_t conf = config;
583:       60:  558:    char * val = (char *)event.data.scalar.value;
584:       60:  559:    int found_seq = sequence &gt; PLC_ERR;
585:        -:  560:                    
586:       60:  561:    if(*storage == STORE_KEY) {
587:       34:  562:         if(found_seq) {
588:        -:  563:                            
589:       10:  564:             *key = get_var_key(val);         
590:        -:  565:         } else {
591:        -:  566:                        
592:       24:  567:             *key = get_key(val,conf);    
593:        -:  568:         }
594:        -:  569:         
595:       34:  570:         *storage = STORE_VAL;
596:        -:  571:    } else {
597:       26:  572:        if(found_seq) {            
598:       10:  573:            if(*key == VARIABLE_INDEX){
599:        -:  574:                             
600:        2:  575:                *idx = atoi(val);
601:        -:  576:            } else {  
602:        -:  577:                             
603:       16:  578:                conf = store_seq_value(sequence, 
604:        8:  579:                                      *idx, 
605:        8:  580:                                      *key, 
606:        -:  581:                                      val, 
607:        -:  582:                                      conf);       
608:        -:  583:            }   
609:        -:  584:        } else {
610:        -:  585:                        
611:       16:  586:        conf = store_value(*key, val, conf);
612:        -:  587:        }
613:        -:  588://swap storage to process val after key and vice versa        
614:       26:  589:        *storage = STORE_KEY;     
615:        -:  590:    }                 
616:        -:  591:      
617:       60:  592:    return conf;                       
618:        -:  593:}
619:        -:  594:
620:function process_mapping called 16 returned 1000locks executed 93%
621:       16:  595:static config_t process_mapping(
622:        -:  596:                    int found_seq,
623:        -:  597:                    int key,
624:        -:  598:                    BYTE * storage,
625:        -:  599:                    yaml_parser_t *parser,
626:        -:  600:                    config_t config){
627:        -:  601:    
628:       16:  602:    config_t conf = config;                
629:       16:  603:    entry_t c = get_entry(key, conf);
630:       24:  604:    if( c != NULL &&
631:        8:  605:        c-&gt;type_tag == ENTRY_MAP) {
632:        -:  606:                    
633:        6:  607:                        c-&gt;e.conf = process(
634:        -:  608:                            found_seq?key:PLC_ERR, 
635:        -:  609:                            parser, 
636:        -:  610:                            c-&gt;e.conf);
637:        -:  611:                        
638:        6:  612:                        conf-&gt;map[key] = c;
639:        -:  613:                    } else {
640:        -:  614:                    
641:       10:  615:                        conf = process(
642:        -:  616:                            found_seq?key:PLC_ERR, 
643:        -:  617:                            parser, 
644:        -:  618:                            conf);
645:        -:  619:    }
646:        -:  620:    
647:       16:  621:    *storage = STORE_KEY;
648:       16:  622:    return conf;    
649:        -:  623:} 
650:        -:  624:
651:function process called 30 returned 1000locks executed 97%
652:       30:  625:config_t process(int sequence, 
653:        -:  626:            yaml_parser_t *parser, 
654:        -:  627:            config_t configuration){
655:        -:  628:             
656:       30:  629:    config_t config = configuration;
657:       30:  630:    BYTE storage = STORE_KEY;   
658:       30:  631:    int done = FALSE;
659:       30:  632:    int key = PLC_ERR;
660:       30:  633:    int found_seq = sequence &gt; PLC_ERR;
661:       30:  634:    int idx = PLC_ERR;
662:        -:  635:    yaml_event_t event;
663:       30:  636:    memset(&event, 0, sizeof(event));
664:        -:  637:    
665:       30:  638:    if(config == NULL) {
666:        -:  639:     
667:        2:  640:        return NULL;
668:        -:  641:     }
669:        -:  642:     
670:       28:  643:     if(parser == NULL) {
671:        2:  644:        config-&gt;err = PLC_ERR;
672:        -:  645:     
673:        2:  646:        return config;
674:        -:  647:     }
675:        -:  648://     || parser-&gt;context == NULL 
676:        -:  649:           
677:      182:  650:     while(done == FALSE){
678:        -:  651:     
679:      130:  652:        if (!yaml_parser_parse(parser, &event)){   
680:        2:  653:                yaml_parser_error(*parser);
681:        2:  654:                config-&gt;err = PLC_ERR;
682:        -:  655:        } else {
683:        -:  656:   
684:      128:  657:            switch(event.type){
685:        -:  658:            
686:        -:  659:                case YAML_SCALAR_EVENT: 
687:        -:  660:                
688:       60:  661:                    config = process_scalar(
689:        -:  662:                        event,
690:        -:  663:                        found_seq?sequence:PLC_ERR,
691:        -:  664:                        &storage,
692:        -:  665:                        &key,
693:        -:  666:                        &idx,
694:        -:  667:                        config);
695:       60:  668:                break;
696:        -:  669:                
697:        -:  670:                case YAML_SEQUENCE_START_EVENT:
698:        -:  671:                
699:        2:  672:                    found_seq = TRUE;
700:        2:  673:                    break;
701:        -:  674:                
702:        -:  675:                case YAML_SEQUENCE_END_EVENT:
703:        -:  676:                
704:        2:  677:                    found_seq = FALSE;
705:        2:  678:                    break;
706:        -:  679:                
707:        -:  680:                case YAML_MAPPING_START_EVENT:/* {
708:        -:  681:                    
709:        -:  682:                    entry_t c = get_entry(key, config);
710:        -:  683:                    if( c != NULL &&
711:        -:  684:                        c-&gt;type_tag == ENTRY_MAP) {
712:        -:  685:                    
713:        -:  686:                        c-&gt;e.conf = process(
714:        -:  687:                            found_seq?key:-1, 
715:        -:  688:                            parser, 
716:        -:  689:                            c-&gt;e.conf);
717:        -:  690:                        
718:        -:  691:                        config-&gt;map[key] = c;
719:        -:  692:                    } else {
720:        -:  693:                    
721:        -:  694:                        config = process(
722:        -:  695:                            found_seq?key:-1, 
723:        -:  696:                            parser, 
724:        -:  697:                            config);
725:        -:  698:                    }
726:        -:  699:                    storage = STORE_KEY;
727:        -:  700:                    
728:        -:  701:                }  */ 
729:       16:  702:                config = process_mapping(
730:        -:  703:                                found_seq,
731:        -:  704:                                key,
732:        -:  705:                                &storage,
733:        -:  706:                                parser,
734:        -:  707:                                config); 
735:        -:  708:                
736:       16:  709:                break;
737:        -:  710:                    
738:        -:  711:                case YAML_MAPPING_END_EVENT:
739:        -:  712:                case YAML_STREAM_END_EVENT:     
740:        -:  713:                    
741:       24:  714:                    done = TRUE;
742:       24:  715:                    break;
743:        -:  716:                    
744:        -:  717:                case YAML_NO_EVENT:
745:<font color=red>    #####:  718:                    config-&gt;err = PLC_ERR;</font>
746:<font color=red>    #####:  719:                    break;    </font>
747:        -:  720:                    
748:       24:  721:                default: break;    
749:        -:  722:            }
750:        -:  723:         }
751:      130:  724:         if(config-&gt;err &lt; PLC_OK) {
752:        2:  725:             done = TRUE;
753:        -:  726:             //log_yml_event(event);
754:        -:  727:         }                                              
755:      130:  728:         yaml_event_delete(&event);   
756:        -:  729:     }
757:        -:  730:     
758:       26:  731:     return config;
759:        -:  732:}
760:        -:  733:             
761:function load_config_yml called 0 returned 00locks executed 0%
762:<font color=red>    #####:  734:config_t load_config_yml(const char * filename, config_t conf) {</font>
763:        -:  735:    yaml_parser_t parser;
764:        -:  736:    
765:        -:  737:    FILE * fcfg;
766:        -:  738:    char path[MAXSTR];
767:        -:  739:
768:<font color=red>    #####:  740:    memset(path, 0, MAXSTR);</font>
769:<font color=red>    #####:  741:    sprintf(path, "", filename);</font>
770:        -:  742:    
771:<font color=red>    #####:  743:    memset(&parser, 0, sizeof(parser));</font>
772:        -:  744:    
773:<font color=red>    #####:  745:    config_t r = conf;</font>
774:        -:  746:    
775:<font color=red>    #####:  747:    if (!yaml_parser_initialize(&parser)) {</font>
776:<font color=red>    #####:  748:        yaml_parser_error(parser);</font>
777:<font color=red>    #####:  749:        return PLC_ERR;    </font>
778:        -:  750:    }
779:<font color=red>    #####:  751:    if ((fcfg = fopen(path, "r"))) {</font>
780:<font color=red>    #####:  752:        plc_log("Looking for configuration from  ...", path);</font>
781:<font color=red>    #####:  753:        yaml_parser_set_input_file(&parser, fcfg);</font>
782:<font color=red>    #####:  754:        r = process(PLC_ERR, &parser, conf);</font>
783:<font color=red>    #####:  755:        if(r-&gt;err &lt; PLC_OK)</font>
784:<font color=red>    #####:  756:            plc_log( "Configuration error ");</font>
785:<font color=red>    #####:  757:        fclose(fcfg);</font>
786:        -:  758:    } else {
787:<font color=red>    #####:  759:        r-&gt;err = PLC_ERR;</font>
788:<font color=red>    #####:  760:        plc_log("Could not open file ", filename);</font>
789:        -:  761:    }
790:<font color=red>    #####:  762:    yaml_parser_delete(&parser);</font>
791:<font color=red>    #####:  763:    return r;</font>
792:        -:  764:}
793:        -:  765:
794:function emit_variable called 96 returned 1000locks executed 7%
795:       96:  766:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
796:        -:  767:    yaml_event_t evt;
797:       96:  768:    if( var-&gt;name != NULL &&
798:<font color=red>    #####:  769:        var-&gt;name[0]) {</font>
799:        -:  770:       
800:        -:  771:       char idx[4];
801:<font color=red>    #####:  772:       memset(idx, 0, 4);</font>
802:        -:  773:    
803:<font color=red>    #####:  774:       yaml_mapping_start_event_initialize(</font>
804:        -:  775:    			        &evt,
805:        -:  776:    			        NULL,
806:        -:  777:    			        NULL,
807:        -:  778:    			        FALSE,
808:        -:  779:    			        YAML_BLOCK_MAPPING_STYLE);
809:        -:  780:    	 	    
810:<font color=red>    #####:  781:       yaml_emitter_emit(emitter, &evt);</font>
811:        -:  782:    		//log_yml_event(evt);
812:        -:  783:    		            
813:<font color=red>    #####:  784:       yaml_scalar_event_initialize(</font>
814:        -:  785:                        	&evt,
815:        -:  786:                    	    NULL,
816:        -:  787:                    		NULL,
817:        -:  788:                    		"INDEX",
818:        -:  789:                    		5,
819:        -:  790:                    		TRUE,
820:        -:  791:                    		TRUE, 
821:        -:  792:                    		YAML_PLAIN_SCALAR_STYLE); 
822:<font color=red>    #####:  793:       yaml_emitter_emit(emitter, &evt);</font>
823:        -:  794:                    		
824:<font color=red>    #####:  795:       sprintf(idx, "0", var-&gt;index);		</font>
825:<font color=red>    #####:  796:       yaml_scalar_event_initialize(</font>
826:        -:  797:                        	&evt,
827:        -:  798:                    	    NULL,
828:        -:  799:                    		NULL,
829:        -:  800:                    		(unsigned char *)idx,
830:<font color=red>    #####:  801:                    		strlen(idx),</font>
831:        -:  802:                    		TRUE,
832:        -:  803:                    		TRUE, 
833:        -:  804:                    		YAML_PLAIN_SCALAR_STYLE); 	
834:<font color=red>    #####:  805:       yaml_emitter_emit(emitter, &evt);</font>
835:        -:  806:    		            
836:        -:  807:   
837:<font color=red>    #####:  808:       yaml_scalar_event_initialize(</font>
838:        -:  809:                        	&evt,
839:        -:  810:                    	    NULL,
840:        -:  811:                    		NULL,
841:        -:  812:                    		"ID",
842:        -:  813:                    		2,
843:        -:  814:                    		TRUE,
844:        -:  815:                    		TRUE, 
845:        -:  816:                    		YAML_PLAIN_SCALAR_STYLE); 
846:<font color=red>    #####:  817:       yaml_emitter_emit(emitter, &evt);</font>
847:        -:  818:                    			
848:<font color=red>    #####:  819:       yaml_scalar_event_initialize(</font>
849:        -:  820:                        	&evt,
850:        -:  821:                    	    NULL,
851:        -:  822:                    		NULL,
852:<font color=red>    #####:  823:                    		(unsigned char *)var-&gt;name,</font>
853:<font color=red>    #####:  824:                    		strlen(var-&gt;name),</font>
854:        -:  825:                    		TRUE,
855:        -:  826:                    		TRUE, 
856:        -:  827:                    		YAML_PLAIN_SCALAR_STYLE); 	
857:<font color=red>    #####:  828:       yaml_emitter_emit(emitter, &evt);</font>
858:        -:  829:
859:<font color=red>    #####:  830:       yaml_scalar_event_initialize(</font>
860:        -:  831:                        	&evt,
861:        -:  832:                    	    NULL,
862:        -:  833:                    		NULL,
863:        -:  834:                    		"VALUE",
864:        -:  835:                    		5,
865:        -:  836:                    		TRUE,
866:        -:  837:                    		TRUE, 
867:        -:  838:                    		YAML_PLAIN_SCALAR_STYLE); 
868:<font color=red>    #####:  839:       yaml_emitter_emit(emitter, &evt);</font>
869:        -:  840:                    			
870:<font color=red>    #####:  841:       yaml_scalar_event_initialize(</font>
871:        -:  842:                        	&evt,
872:        -:  843:                    	    NULL,
873:        -:  844:                    		NULL,
874:<font color=red>    #####:  845:                    		(unsigned char *)var-&gt;value,</font>
875:<font color=red>    #####:  846:                    		strlen(var-&gt;value),</font>
876:        -:  847:                    		TRUE,
877:        -:  848:                    		TRUE, 
878:        -:  849:                    		YAML_PLAIN_SCALAR_STYLE); 	
879:<font color=red>    #####:  850:        yaml_emitter_emit(emitter, &evt);</font>
880:<font color=red>    #####:  851:        if(strcmp(var-&gt;min, var-&gt;max)) {</font>
881:<font color=red>    #####:  852:            yaml_scalar_event_initialize(</font>
882:        -:  853:                        	&evt,
883:        -:  854:                    	    NULL,
884:        -:  855:                    		NULL,
885:        -:  856:                    		"MIN",
886:        -:  857:                    		3,
887:        -:  858:                    		TRUE,
888:        -:  859:                    		TRUE, 
889:        -:  860:                    		YAML_PLAIN_SCALAR_STYLE); 
890:<font color=red>    #####:  861:            yaml_emitter_emit(emitter, &evt);</font>
891:        -:  862:                    			
892:<font color=red>    #####:  863:            yaml_scalar_event_initialize(</font>
893:        -:  864:                        	&evt,
894:        -:  865:                    	    NULL,
895:        -:  866:                    		NULL,
896:<font color=red>    #####:  867:                    		(unsigned char *)var-&gt;min,</font>
897:<font color=red>    #####:  868:                    		strlen(var-&gt;min),</font>
898:        -:  869:                    		TRUE,
899:        -:  870:                    		TRUE, 
900:        -:  871:                    		YAML_PLAIN_SCALAR_STYLE); 	
901:<font color=red>    #####:  872:            yaml_emitter_emit(emitter, &evt);</font>
902:        -:  873:
903:<font color=red>    #####:  874:            yaml_scalar_event_initialize(</font>
904:        -:  875:                        	&evt,
905:        -:  876:                    	    NULL,
906:        -:  877:                    		NULL,
907:        -:  878:                    		"MAX",
908:        -:  879:                    		3,
909:        -:  880:                    		TRUE,
910:        -:  881:                    		TRUE, 
911:        -:  882:                    		YAML_PLAIN_SCALAR_STYLE); 
912:<font color=red>    #####:  883:            yaml_emitter_emit(emitter, &evt);</font>
913:        -:  884:                    			
914:<font color=red>    #####:  885:            yaml_scalar_event_initialize(</font>
915:        -:  886:                        	&evt,
916:        -:  887:                    	    NULL,
917:        -:  888:                    		NULL,
918:<font color=red>    #####:  889:                    		(unsigned char *)var-&gt;max,</font>
919:<font color=red>    #####:  890:                    		strlen(var-&gt;max),</font>
920:        -:  891:                    		TRUE,
921:        -:  892:                    		TRUE, 
922:        -:  893:                    		YAML_PLAIN_SCALAR_STYLE); 	
923:<font color=red>    #####:  894:            yaml_emitter_emit(emitter, &evt);</font>
924:        -:  895:        }       
925:<font color=red>    #####:  896:        yaml_mapping_end_event_initialize(&evt); 	</font>
926:<font color=red>    #####:  897:        yaml_emitter_emit(emitter, &evt); </font>
927:        -:  898:    }
928:       96:  899:} 
929:        -:  900:
930:function emit_entry called 50 returned 1000locks executed 97%
931:       50:  901:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
932:       50:  902:    int i = 0;
933:        -:  903:    yaml_event_t evt;
934:        -:  904:     
935:      100:  905:    yaml_scalar_event_initialize(
936:        -:  906:    	&evt,
937:        -:  907:	    NULL,
938:        -:  908:		NULL,
939:       50:  909:		(unsigned char *)entry-&gt;name,
940:       50:  910:		strlen(entry-&gt;name),
941:        -:  911:		TRUE,
942:        -:  912:		TRUE, 
943:        -:  913:		YAML_PLAIN_SCALAR_STYLE); 	
944:        -:  914:		
945:       50:  915:	yaml_emitter_emit(emitter, &evt);
946:        -:  916:	//log_yml_event(evt);
947:        -:  917:	char buf[TINYBUF];
948:       50:  918:	memset(buf, 0, TINYBUF);
949:       50:  919:	entry_t iter = NULL;
950:       50:  920:	variable_t viter = NULL;
951:        -:  921:	
952:       50:  922:	switch (entry-&gt;type_tag){
953:        -:  923:	
954:        -:  924:		case ENTRY_STR:
955:        -:  925:		
956:       16:  926:			yaml_scalar_event_initialize(
957:        -:  927:    		&evt,
958:        -:  928:	    	NULL,
959:        -:  929:			NULL,
960:        8:  930:			(unsigned char *)entry-&gt;e.scalar_str,
961:        8:  931:			strlen(entry-&gt;e.scalar_str),
962:        -:  932:			TRUE,
963:        -:  933:			TRUE, 
964:        -:  934:			YAML_PLAIN_SCALAR_STYLE); 	
965:        -:  935:		
966:        8:  936:			yaml_emitter_emit(emitter, &evt); 
967:        -:  937:			//log_yml_event(evt);		
968:        8:  938:			break;
969:        -:  939:		
970:        -:  940:		case ENTRY_INT:
971:        -:  941:			
972:       18:  942:			sprintf(buf, "0", entry-&gt;e.scalar_int);
973:       18:  943:			yaml_scalar_event_initialize(
974:        -:  944:    		&evt,
975:        -:  945:	    	NULL,
976:        -:  946:			NULL,
977:        -:  947:			(unsigned char *)buf,
978:       18:  948:			strlen(buf),
979:        -:  949:			TRUE,
980:        -:  950:			TRUE, 
981:        -:  951:			YAML_PLAIN_SCALAR_STYLE); 	
982:        -:  952:		
983:       18:  953:			yaml_emitter_emit(emitter, &evt);
984:        -:  954:			//log_yml_event(evt); 		
985:       18:  955:			break;
986:        -:  956:				 
987:        -:  957:		case ENTRY_MAP:
988:        -:  958:		
989:        8:  959:		    yaml_mapping_start_event_initialize(
990:        -:  960:    			&evt,
991:        -:  961:    			NULL,
992:        -:  962:    			NULL,
993:        -:  963:    			FALSE,
994:        -:  964:    			YAML_BLOCK_MAPPING_STYLE);
995:        -:  965:    	 	    
996:        8:  966:    		yaml_emitter_emit(emitter, &evt);
997:        -:  967:    		//log_yml_event(evt);
998:        8:  968:    		iter = *(entry-&gt;e.conf-&gt;map);
999:        -:  969:    		
1000:       38:  970:			while(i &lt; entry-&gt;e.conf-&gt;size){
1001:       22:  971:			    if(iter != NULL) {
1002:       22:  972:				    emit_entry(iter, emitter);  
1003:        -:  973:				}
1004:       22:  974:				iter = (entry-&gt;e.conf-&gt;map)[++i];
1005:        -:  975:			}	
1006:        8:  976:			yaml_mapping_end_event_initialize(&evt); 	
1007:        8:  977:    		yaml_emitter_emit(emitter, &evt); 
1008:        -:  978:    		//log_yml_event(evt);
1009:        8:  979:			break;
1010:        -:  980:		
1011:        -:  981:		case ENTRY_SEQ:
1012:       16:  982:		  yaml_sequence_start_event_initialize(
1013:        -:  983:    			&evt,
1014:        -:  984:    			NULL,
1015:        -:  985:    			NULL,
1016:        -:  986:    			TRUE,
1017:        -:  987:    			YAML_BLOCK_SEQUENCE_STYLE);
1018:        -:  988:    		//log_yml_event(evt);
1019:       16:  989:    	    yaml_emitter_emit(emitter, &evt); 	
1020:        -:  990:		//emit size as int
1021:        -:  991:		  
1022:       16:  992:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
1023:       16:  993:			yaml_scalar_event_initialize(
1024:        -:  994:    		&evt,
1025:        -:  995:	    	NULL,
1026:        -:  996:			NULL,
1027:        -:  997:			(unsigned char *)buf,
1028:       16:  998:			strlen(buf),
1029:        -:  999:			TRUE,
1030:        -: 1000:			TRUE, 
1031:        -: 1001:			YAML_PLAIN_SCALAR_STYLE); 	
1032:        -: 1002:		
1033:       16: 1003:			yaml_emitter_emit(emitter, &evt);
1034:        -: 1004:			//log_yml_event(evt); 		
1035:        -: 1005:			//emit values as map
1036:       16: 1006:			viter = entry-&gt;e.seq-&gt;vars;
1037:        -: 1007:    		
1038:       16: 1008:    		i = 0;
1039:      128: 1009:			while(i &lt; entry-&gt;e.seq-&gt;size){
1040:       96: 1010:			    if(viter != NULL) {
1041:       96: 1011:				   emit_variable(viter, emitter);
1042:        -: 1012:				}
1043:       96: 1013:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
1044:        -: 1014:			}	
1045:        -: 1015:			
1046:       16: 1016:			yaml_sequence_end_event_initialize(&evt); 	
1047:       16: 1017:    		yaml_emitter_emit(emitter, &evt); 
1048:        -: 1018:    		//log_yml_event(evt);
1049:       16: 1019:			break;
1050:        -: 1020:			
1051:<font color=red>    #####: 1021:		default:break;</font>
1052:        -: 1022:	}
1053:        -: 1023:	
1054:       50: 1024:}
1055:        -: 1025:
1056:function emit called 2 returned 1000locks executed 100%
1057:        2: 1026:int emit(yaml_emitter_t *emitter, const config_t conf) {
1058:        2: 1027:    int r = PLC_OK;     
1059:        -: 1028:   
1060:        -: 1029:    yaml_event_t evt;
1061:        -: 1030:    char val[MAXSTR];
1062:        2: 1031:    memset(val,0,MAXSTR);
1063:        -: 1032:    //doc start
1064:        2: 1033:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, FALSE); 
1065:        2: 1034:	yaml_emitter_emit(emitter, &evt); 		
1066:        -: 1035:   // log_yml_event(evt);
1067:        -: 1036:    
1068:        2: 1037:    yaml_mapping_start_event_initialize(
1069:        -: 1038:    	&evt,
1070:        -: 1039:    	NULL,
1071:        -: 1040:    	NULL,
1072:        -: 1041:    	FALSE,
1073:        -: 1042:    	YAML_BLOCK_MAPPING_STYLE);
1074:        -: 1043:    	 	    
1075:        2: 1044:    yaml_emitter_emit(emitter, &evt);
1076:        -: 1045:   // log_yml_event(evt);
1077:        -: 1046:    
1078:        -: 1047:     
1079:        2: 1048:    entry_map_t config_map = conf-&gt;map;
1080:        2: 1049:    entry_t iter = *config_map;
1081:        2: 1050:    int i = 0;
1082:       60: 1051:    while(i &lt; N_CONFIG_VARIABLES) {
1083:       56: 1052:        if(iter != NULL){
1084:       28: 1053:    	    emit_entry(iter, emitter);
1085:        -: 1054:    	}
1086:       56: 1055:    	iter = config_map[++i];
1087:        -: 1056:    }
1088:        -: 1057:   
1089:        -: 1058:    //mapping end
1090:        2: 1059:    yaml_mapping_end_event_initialize(&evt); 	
1091:        2: 1060:    yaml_emitter_emit(emitter, &evt); 		
1092:        -: 1061:    //log_yml_event(evt);
1093:        -: 1062:    
1094:        -: 1063:    //doc end
1095:        2: 1064:    yaml_document_end_event_initialize(&evt,FALSE);
1096:        2: 1065:    yaml_emitter_emit(emitter, &evt);
1097:        -: 1066:    //log_yml_event(evt); 		
1098:        2: 1067:    yaml_event_delete(&evt); 	
1099:        2: 1068:    return r;
1100:        -: 1069:}
1101:        -: 1070:
1102:function save_config_yml called 0 returned 00locks executed 0%
1103:<font color=red>    #####: 1071:int save_config_yml(const char * filename, const config_t conf) {</font>
1104:        -: 1072:    
1105:        -: 1073:    yaml_emitter_t emitter;
1106:        -: 1074:    yaml_event_t event;
1107:        -: 1075:    
1108:        -: 1076:    FILE * fcfg;
1109:        -: 1077:    char path[MAXSTR];
1110:<font color=red>    #####: 1078:    int r = PLC_OK;</font>
1111:        -: 1079:    
1112:<font color=red>    #####: 1080:    memset(path, 0, MAXSTR);</font>
1113:<font color=red>    #####: 1081:    sprintf(path, "", filename);</font>
1114:        -: 1082:
1115:<font color=red>    #####: 1083:    if(!yaml_emitter_initialize(&emitter)){</font>
1116:<font color=red>    #####: 1084:        return PLC_ERR;    </font>
1117:        -: 1085:    }
1118:<font color=red>    #####: 1086:    if ((fcfg = fopen(path, "wb"))) {</font>
1119:<font color=red>    #####: 1087:         plc_log("Save configuration to  ...", path);</font>
1120:        -: 1088:         
1121:<font color=red>    #####: 1089:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1122:<font color=red>    #####: 1090:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1123:        -: 1091:         
1124:<font color=red>    #####: 1092:         r = yaml_emitter_emit(&emitter, &event);</font>
1125:        -: 1093:         
1126:<font color=red>    #####: 1094:         if(r)</font>
1127:<font color=red>    #####: 1095:            r = emit(&emitter, conf);</font>
1128:<font color=red>    #####: 1096:         if(r){</font>
1129:<font color=red>    #####: 1097:            yaml_stream_end_event_initialize(&event);</font>
1130:<font color=red>    #####: 1098:            r = yaml_emitter_emit(&emitter, &event);   </font>
1131:        -: 1099:         }
1132:        -: 1100:            
1133:<font color=red>    #####: 1101:         if(r &lt; PLC_OK)</font>
1134:<font color=red>    #####: 1102:            plc_log( "Configuration error ");</font>
1135:        -: 1103:            
1136:<font color=red>    #####: 1104:         fclose(fcfg);</font>
1137:        -: 1105:    } else {
1138:<font color=red>    #####: 1106:        r = PLC_ERR;</font>
1139:<font color=red>    #####: 1107:        plc_log("Could not open file  for write", filename);</font>
1140:        -: 1108:    }
1141:<font color=red>    #####: 1109:    yaml_emitter_delete(&emitter);</font>
1142:<font color=red>    #####: 1110:    return r;</font>
1143:        -: 1111:}
1144:        -: 1112:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
