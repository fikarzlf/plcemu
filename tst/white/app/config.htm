<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:
 10:function strdup_r called 14 returned 1000locks executed 100%
 11:       14:    5:char * strdup_r(const char * dest, const char * src) {
 12:        -:    6://strdup with realloc
 13:        -:    7:
 14:       14:    8:    char * r = (!dest)?(char *)malloc(sizeof(src)):realloc(dest, sizeof(src));
 15:        -:    9:        
 16:       14:   10:    memset(r, 0, sizeof(src));
 17:       14:   11:    sprintf(r, "", src);
 18:        -:   12:    
 19:       14:   13:    return r;
 20:        -:   14:}
 21:        -:   15:
 22:function yaml_config_error called 0 returned 00locks executed 0%
 23:<font color=red>    #####:   16:static void yaml_config_error(yaml_parser_t parser){</font>
 24:        -:   17:
 25:        -:   18:    //print line
 26:<font color=red>    #####:   19:}</font>
 27:        -:   20:
 28:function yaml_parser_error called 0 returned 00locks executed 0%
 29:<font color=red>    #####:   21:static void yaml_parser_error(yaml_parser_t parser){</font>
 30:        -:   22:
 31:<font color=red>    #####:   23:     switch (parser.error)</font>
 32:        -:   24:     {
 33:        -:   25:        case YAML_MEMORY_ERROR:
 34:<font color=red>    #####:   26:            plc_log( </font>
 35:        -:   27:            "Memory error: Not enough memory for parsing");
 36:<font color=red>    #####:   28:            break;</font>
 37:        -:   29:
 38:        -:   30:        case YAML_READER_ERROR:
 39:<font color=red>    #####:   31:            if (parser.problem_value != -1) {</font>
 40:<font color=red>    #####:   32:                plc_log( </font>
 41:        -:   33:                "Reader error: : #0 at 0", 
 42:        -:   34:                parser.problem,
 43:        -:   35:                parser.problem_value, 
 44:        -:   36:                parser.problem_offset);
 45:        -:   37:            }
 46:        -:   38:            else {
 47:<font color=red>    #####:   39:                plc_log( </font>
 48:        -:   40:                "Reader error:  at 0", 
 49:        -:   41:                parser.problem,
 50:        -:   42:                parser.problem_offset);
 51:        -:   43:            }
 52:<font color=red>    #####:   44:            break;</font>
 53:        -:   45:
 54:        -:   46:        case YAML_SCANNER_ERROR:
 55:<font color=red>    #####:   47:            if (parser.context) {</font>
 56:<font color=red>    #####:   48:                plc_log( </font>
 57:        -:   49:                "Scanner error:  at line 0, column 0"
 58:        -:   50:                        " at line 0, column 0", 
 59:        -:   51:                        parser.context,
 60:<font color=red>    #####:   52:                        parser.context_mark.line+1,</font>
 61:<font color=red>    #####:   53:                        parser.context_mark.column+1,</font>
 62:        -:   54:                        parser.problem, 
 63:<font color=red>    #####:   55:                        parser.problem_mark.line+1,</font>
 64:<font color=red>    #####:   56:                        parser.problem_mark.column+1);</font>
 65:        -:   57:            }
 66:        -:   58:            else {
 67:<font color=red>    #####:   59:                plc_log( </font>
 68:        -:   60:                "Scanner error:  at line 0, column 0",
 69:<font color=red>    #####:   61:                        parser.problem, parser.problem_mark.line+1,</font>
 70:<font color=red>    #####:   62:                        parser.problem_mark.column+1);</font>
 71:        -:   63:            }
 72:<font color=red>    #####:   64:            break;</font>
 73:        -:   65:
 74:        -:   66:        case YAML_PARSER_ERROR:
 75:<font color=red>    #####:   67:            if (parser.context) {</font>
 76:<font color=red>    #####:   68:                plc_log( </font>
 77:        -:   69:                "Parser error:  at line 0, column 0"
 78:        -:   70:                        " at line 0, column 0", 
 79:        -:   71:                        parser.context,
 80:<font color=red>    #####:   72:                        parser.context_mark.line+1,</font>
 81:<font color=red>    #####:   73:                        parser.context_mark.column+1,</font>
 82:        -:   74:                        parser.problem, 
 83:<font color=red>    #####:   75:                        parser.problem_mark.line+1,</font>
 84:<font color=red>    #####:   76:                        parser.problem_mark.column+1);</font>
 85:        -:   77:            }
 86:        -:   78:            else {
 87:<font color=red>    #####:   79:                plc_log( </font>
 88:        -:   80:                "Parser error:  at line 0, column 0",
 89:        -:   81:                        parser.problem, 
 90:<font color=red>    #####:   82:                        parser.problem_mark.line+1,</font>
 91:<font color=red>    #####:   83:                        parser.problem_mark.column+1);</font>
 92:        -:   84:            }
 93:<font color=red>    #####:   85:            break;</font>
 94:        -:   86:
 95:        -:   87:        default:
 96:        -:   88:            /* Couldn't happen. */
 97:<font color=red>    #####:   89:            plc_log( </font>
 98:        -:   90:            "Internal error\n");
 99:<font color=red>    #####:   91:            break;</font>
100:        -:   92:    }
101:<font color=red>    #####:   93:}</font>
102:        -:   94:
103:function new_entry_int called 110 returned 1000locks executed 100%
104:      110:   95:entry_t new_entry_int(int i, char * name) {
105:      110:   96:	entry_t r = (entry_t)malloc(sizeof(struct entry));
106:      110:   97:	r-&gt;type_tag = ENTRY_INT;
107:      110:   98:	r-&gt;name = name;
108:      110:   99:	r-&gt;e.scalar_int = i;
109:        -:  100:
110:      110:  101:	return r;
111:        -:  102:}
112:        -:  103:
113:function new_entry_str called 54 returned 1000locks executed 100%
114:       54:  104:entry_t new_entry_str(char * str, char * name) {
115:        -:  105:
116:       54:  106:	entry_t r = (entry_t)malloc(sizeof(struct entry));
117:       54:  107:	r-&gt;type_tag = ENTRY_STR;
118:       54:  108:	r-&gt;name = name;
119:       54:  109:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
120:       54:  110:    sprintf(r-&gt;e.scalar_str, "", str);
121:       54:  111:	return r;
122:        -:  112:}
123:        -:  113:
124:function new_entry_map called 50 returned 1000locks executed 100%
125:       50:  114:entry_t new_entry_map(config_t map, char * name) {
126:        -:  115:	
127:       50:  116:	entry_t r = (entry_t)malloc(sizeof(struct entry));
128:       50:  117:	r-&gt;type_tag = ENTRY_MAP;
129:       50:  118:	r-&gt;name = name;
130:       50:  119:	r-&gt;e.conf = map;
131:        -:  120:
132:       50:  121:	return r;
133:        -:  122:}
134:        -:  123:
135:function new_entry_seq called 98 returned 1000locks executed 100%
136:       98:  124:entry_t new_entry_seq(sequence_t seq, char * name) {
137:        -:  125:	
138:       98:  126:	entry_t r = (entry_t)malloc(sizeof(struct entry));
139:       98:  127:	r-&gt;type_tag = ENTRY_SEQ;
140:       98:  128:	r-&gt;name = name;
141:       98:  129:	r-&gt;e.seq = seq;
142:        -:  130:
143:       98:  131:	return r;
144:        -:  132:}
145:        -:  133:
146:function new_entry_null called 0 returned 00locks executed 0%
147:<font color=red>    #####:  134:entry_t new_entry_null() {</font>
148:<font color=red>    #####:  135:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
149:<font color=red>    #####:  136:	r-&gt;type_tag = ENTRY_NONE;</font>
150:<font color=red>    #####:  137:	r-&gt;name = "";</font>
151:<font color=red>    #####:  138:	r-&gt;e.scalar_int = 0;</font>
152:        -:  139:
153:<font color=red>    #####:  140:	return r;</font>
154:        -:  141:}
155:        -:  142:
156:function update_entry called 300 returned 1000locks executed 80%
157:      300:  143:config_t update_entry(
158:        -:  144:    unsigned int key, 
159:        -:  145:    const entry_t item,
160:        -:  146:    const config_t conf) {
161:        -:  147:    
162:      600:  148:    if( conf == NULL ||
163:      300:  149:        key &gt;= conf-&gt;size) {
164:        -:  150:    
165:<font color=red>    #####:  151:        return conf;</font>
166:        -:  152:    } else {
167:        -:  153:    
168:      300:  154:        config_t r = conf;
169:      300:  155:        r-&gt;map[key] = item;
170:        -:  156:        
171:      300:  157:        return r;
172:        -:  158:    }
173:        -:  159:}
174:        -:  160:
175:function get_entry called 110 returned 1000locks executed 100%
176:      110:  161:entry_t get_entry(int key, const config_t conf){
177:        -:  162:
178:      110:  163:    if(conf == NULL || 
179:       96:  164:        key &lt; 0 || 
180:       96:  165:        key &gt; conf-&gt;size) {
181:        -:  166:        
182:       14:  167:        return NULL;    
183:        -:  168:    }
184:        -:  169:    
185:       96:  170:    return conf-&gt;map[key];
186:        -:  171:}
187:        -:  172:
188:function copy_entry called 12 returned 1000locks executed 88%
189:       12:  173:entry_t copy_entry(entry_t other){
190:        -:  174:
191:       12:  175:    entry_t r = NULL;
192:       12:  176:    if(other == NULL){
193:        -:  177:    
194:<font color=red>    #####:  178:        return NULL;</font>
195:        -:  179:    }
196:       12:  180:    switch(other-&gt;type_tag){
197:        -:  181:        case ENTRY_INT:
198:        2:  182:            r = new_entry_int(
199:        -:  183:                    other-&gt;e.scalar_int, 
200:        -:  184:                    other-&gt;name);
201:        2:  185:            break;
202:        -:  186:	    case ENTRY_STR:
203:        6:  187:	        r = new_entry_str(
204:        -:  188:                    other-&gt;e.scalar_str, 
205:        -:  189:                    other-&gt;name);
206:        6:  190:	        break;
207:        -:  191:	    case ENTRY_MAP:
208:        2:  192:	        r = new_entry_map(copy_config(other-&gt;e.conf), other-&gt;name);
209:        -:  193:	        
210:        2:  194:	        break;
211:        -:  195:	    case ENTRY_SEQ:
212:        2:  196:	        r = new_entry_seq(copy_sequence(other-&gt;e.seq), other-&gt;name);
213:        2:  197:	        break;
214:        -:  198:        default: //NULL
215:<font color=red>    #####:  199:            r = new_entry_null();</font>
216:        -:  200:    }
217:       12:  201:    return r;
218:        -:  202:}
219:        -:  203:
220:function get_numeric_entry called 4 returned 1000locks executed 100%
221:        4:  204:int get_numeric_entry(int key, const config_t conf){
222:        4:  205:    entry_t e = get_entry(key, conf);
223:        4:  206:    if(e && e-&gt;type_tag == ENTRY_INT){
224:        -:  207:    
225:        2:  208:        return e-&gt;e.scalar_int;
226:        -:  209:    } else {
227:        -:  210:    
228:        2:  211:        return CONF_ERR;    
229:        -:  212:    } 
230:        -:  213:}
231:        -:  214:
232:function get_string_entry called 4 returned 1000locks executed 100%
233:        4:  215:char * get_string_entry(int key, const config_t conf){
234:        -:  216:    
235:        4:  217:    entry_t e = get_entry(key, conf);
236:        4:  218:    if(e && e-&gt;type_tag == ENTRY_STR){
237:        -:  219:    
238:        2:  220:        return e-&gt;e.scalar_str;
239:        -:  221:    } else {
240:        -:  222:    
241:        2:  223:        return NULL;    
242:        -:  224:    }    
243:        -:  225:}
244:        -:  226:
245:function get_sequence_entry called 4 returned 1000locks executed 83%
246:        4:  227:sequence_t get_sequence_entry(int key, const config_t conf){
247:        4:  228:    entry_t e = get_entry(key, conf);
248:        4:  229:    if(e && e-&gt;type_tag == ENTRY_SEQ){
249:        -:  230:    
250:        4:  231:        return e-&gt;e.seq;
251:        -:  232:    } else {
252:        -:  233:    
253:<font color=red>    #####:  234:        return NULL;    </font>
254:        -:  235:    }    
255:        -:  236:}
256:        -:  237:
257:function get_recursive_entry called 0 returned 00locks executed 0%
258:<font color=red>    #####:  238:config_t get_recursive_entry(int key, const config_t conf){</font>
259:<font color=red>    #####:  239:    entry_t e = get_entry(key, conf);</font>
260:<font color=red>    #####:  240:    if(e && e-&gt;type_tag == ENTRY_MAP){</font>
261:        -:  241:    
262:<font color=red>    #####:  242:        return e-&gt;e.conf;</font>
263:        -:  243:    } else {
264:        -:  244:    
265:<font color=red>    #####:  245:        return NULL;    </font>
266:        -:  246:    }    
267:        -:  247:}
268:        -:  248:
269:        -:  249://TODO: in a c++ impl. this would be a hashmap
270:function new_param called 20 returned 1000locks executed 100%
271:       20:  250:param_t new_param(const char * key, 
272:        -:  251:                     const char * val){
273:        -:  252:    
274:       20:  253:        param_t n = (param_t)malloc(sizeof(struct param));
275:       20:  254:        n-&gt;key = strdup(key);
276:       20:  255:        n-&gt;value = strdup(val);
277:       20:  256:        n-&gt;next = NULL;
278:        -:  257:        
279:       20:  258:        return n;        
280:        -:  259:}
281:        -:  260:
282:function copy_params called 26 returned 1000locks executed 100%
283:       26:  261:param_t copy_params(param_t other){
284:       26:  262:    param_t iter = other;
285:       26:  263:    param_t r = NULL;
286:       56:  264:    while(iter){
287:        4:  265:        r = append_param(r, iter-&gt;key, iter-&gt;value);
288:        4:  266:        iter = iter-&gt;next;
289:        -:  267:    }
290:       26:  268:    return r;
291:        -:  269:}
292:        -:  270:
293:function get_param called 10 returned 1000locks executed 100%
294:       10:  271:param_t get_param(const char * key, const param_t params){
295:       10:  272:    param_t it = params;
296:       30:  273:    while(it && key){
297:       16:  274:        if(!strcmp(it-&gt;key, key)){
298:        -:  275:        
299:        6:  276:            return it;
300:        -:  277:        }
301:       10:  278:        it = it-&gt;next;            
302:        -:  279:    }
303:        -:  280:    
304:        4:  281:    return NULL;
305:        -:  282:}
306:        -:  283:
307:function get_param_val called 6 returned 1000locks executed 83%
308:        6:  284:char * get_param_val(const char * key, const param_t params){
309:        6:  285:    param_t it = get_param(key, params);
310:        -:  286:    
311:        6:  287:    return it?it-&gt;value:NULL;
312:        -:  288:}
313:        -:  289:
314:function append_param called 12 returned 1000locks executed 100%
315:       12:  290:param_t append_param(const param_t params, 
316:        -:  291:                     const char * key, 
317:        -:  292:                     const char * val){
318:        -:  293:        
319:       12:  294:    if(params == NULL){
320:        -:  295:        
321:        4:  296:        return new_param(key, val);
322:        -:  297:    } else {
323:        8:  298:        param_t ret = params;
324:        8:  299:        param_t it = params;
325:       18:  300:        while(it-&gt;next){
326:        2:  301:            it = it-&gt;next;
327:        -:  302:        }
328:        8:  303:        it-&gt;next = new_param(key, val);
329:        -:  304:                
330:        8:  305:        return ret;    
331:        -:  306:    }
332:        -:  307:}
333:        -:  308:
334:function update_param called 12 returned 1000locks executed 78%
335:       12:  309:param_t update_param(const param_t params, 
336:        -:  310:                     const char * key, 
337:        -:  311:                     const char * val){
338:        -:  312:        
339:       12:  313:    if(params == NULL){
340:        -:  314:        
341:        8:  315:        return new_param(key, val);         
342:        -:  316:    } else {
343:        4:  317:        param_t ret = params;
344:        4:  318:        param_t par = get_param(key, params);
345:        4:  319:        if(par){
346:<font color=red>    #####:  320:            par-&gt;value = strdup_r(par-&gt;value, val);</font>
347:        -:  321:        } else {
348:        -:  322:        //FIXME: ..and this is why we need a hashmap.
349:        4:  323:            ret = append_param(ret, key, val);  
350:        -:  324:        } 
351:        4:  325:        return ret;    
352:        -:  326:    }
353:        -:  327:}
354:        -:  328:
355:function get_key called 38 returned 1000locks executed 100%
356:       38:  329:int get_key(const char * name, const config_t where) {
357:       38:  330:     if(where != NULL){
358:        -:  331:    
359:      284:  332:        for(int i = 0; i &lt; where-&gt;size; i++) {
360:      516:  333:            if( where-&gt;map[i] != NULL &&
361:      244:  334:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
362:        -:  335:                
363:       26:  336:                return i;
364:        -:  337:            }
365:        -:  338:        }
366:        -:  339:    }
367:        -:  340:    
368:       12:  341:    return CONF_ERR;  
369:        -:  342:}
370:        -:  343:
371:function new_config called 62 returned 1000locks executed 100%
372:       62:  344:config_t new_config(int size) {
373:       62:  345:    config_t r = (config_t)malloc(sizeof(struct config));
374:       62:  346:	memset(r, 0, sizeof(struct config));
375:       62:  347:	r-&gt;size = size;
376:       62:  348:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
377:       62:  349:    memset(r-&gt;map, 0, size*sizeof(struct entry));
378:        -:  350:    
379:       62:  351:	return r;
380:        -:  352:}
381:        -:  353:
382:function copy_config called 2 returned 1000locks executed 89%
383:        2:  354:config_t copy_config(config_t other){
384:        2:  355:    if(other == NULL){
385:        -:  356:        
386:<font color=red>    #####:  357:        return NULL;</font>
387:        -:  358:    }
388:        2:  359:    config_t r = new_config(other-&gt;size);
389:        2:  360:    int i = 0;
390:        6:  361:    for(;i&lt; other-&gt;size; i++){
391:        4:  362:        r-&gt;map[i] = copy_entry(other-&gt;map[i]);
392:        -:  363:    }
393:        2:  364:    return i;
394:        -:  365:}
395:        -:  366:
396:function new_sequence called 102 returned 1000locks executed 100%
397:      102:  367:sequence_t new_sequence(int size) {
398:        -:  368:    
399:      102:  369:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
400:      102:  370:	memset(r, 0, sizeof(struct sequence));
401:      102:  371:	r-&gt;size = size;
402:      102:  372:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
403:      102:  373:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
404:        -:  374:	
405:      102:  375:	return r;
406:        -:  376:}
407:        -:  377:
408:function copy_sequence called 4 returned 1000locks executed 91%
409:        4:  378:sequence_t copy_sequence(sequence_t other){
410:        4:  379:    if(other == NULL){
411:        -:  380:        
412:<font color=red>    #####:  381:        return NULL;</font>
413:        -:  382:    }
414:        4:  383:    sequence_t r = new_sequence(other-&gt;size);
415:        4:  384:    int i = 0;
416:       30:  385:    for(;i &lt; other-&gt;size; i++){
417:       26:  386:        r-&gt;vars[i].index = other-&gt;vars[i].index;
418:       26:  387:        if(other-&gt;vars[i].name){
419:        2:  388:            r-&gt;vars[i].name = strdup(other-&gt;vars[i].name);
420:        -:  389:        }
421:       26:  390:        r-&gt;vars[i].params = copy_params(other-&gt;vars[i].params);
422:        -:  391:    }
423:        4:  392:    return r;
424:        -:  393:}
425:        -:  394:
426:function clear_config called 4 returned 1000locks executed 100%
427:        4:  395:config_t clear_config(config_t c){
428:        -:  396:
429:        4:  397:    return (config_t)NULL;
430:        -:  398:}
431:        -:  399:
432:function log_yml_event called 2 returned 1000locks executed 19%
433:        2:  400:static int log_yml_event(yaml_event_t event){
434:        -:  401:
435:        2:  402:    switch(event.type){ 
436:        -:  403:    
437:        -:  404:        case YAML_NO_EVENT: 
438:        2:  405:        	plc_log("No event!"); 
439:        2:  406:            break;
440:        -:  407:    /* Stream start/end */
441:        -:  408:        case YAML_STREAM_START_EVENT: 
442:<font color=red>    #####:  409:        	plc_log("STREAM START"); </font>
443:<font color=red>    #####:  410:            break;</font>
444:        -:  411:        case YAML_STREAM_END_EVENT: 
445:<font color=red>    #####:  412:        	plc_log("STREAM END");   </font>
446:<font color=red>    #####:  413:            break;</font>
447:        -:  414:    /* Block delimeters */
448:        -:  415:        case YAML_DOCUMENT_START_EVENT: 
449:<font color=red>    #####:  416:        	plc_log("Start Document"); </font>
450:<font color=red>    #####:  417:            break;</font>
451:        -:  418:        case YAML_DOCUMENT_END_EVENT: 
452:<font color=red>    #####:  419:        	plc_log("End Document");   </font>
453:<font color=red>    #####:  420:            break;</font>
454:        -:  421:        case YAML_SEQUENCE_START_EVENT: 
455:<font color=red>    #####:  422:        	plc_log("Start Sequence"); </font>
456:<font color=red>    #####:  423:            break;</font>
457:        -:  424:        case YAML_SEQUENCE_END_EVENT: 
458:<font color=red>    #####:  425:        	plc_log("End Sequence");</font>
459:<font color=red>    #####:  426:            break;</font>
460:        -:  427:        case YAML_MAPPING_START_EVENT: 
461:<font color=red>    #####:  428:        	plc_log("Start Mapping");         </font>
462:<font color=red>    #####:  429:            break;</font>
463:        -:  430:        case YAML_MAPPING_END_EVENT: 
464:<font color=red>    #####:  431:        	plc_log("End Mapping");      </font>
465:<font color=red>    #####:  432:            break;</font>
466:        -:  433:    /* Data */
467:        -:  434:        case YAML_ALIAS_EVENT:  
468:<font color=red>    #####:  435:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
469:<font color=red>    #####:  436:            break;</font>
470:        -:  437:        case YAML_SCALAR_EVENT: 
471:<font color=red>    #####:  438:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
472:<font color=red>    #####:  439:        	break;</font>
473:        -:  440:        default:
474:<font color=red>    #####:  441:            plc_log("default?");</font>
475:        -:  442:    }
476:        2:  443:    return CONF_OK;
477:        -:  444:}
478:        -:  445:
479:function store_value called 26 returned 1000locks executed 85%
480:       26:  446:config_t store_value(
481:        -:  447:            unsigned char key, 
482:        -:  448:            const char * value, 
483:        -:  449:            config_t config){
484:        -:  450:
485:        -:  451:    entry_t e; 
486:       26:  452:    if( config == NULL) {
487:        -:  453:    
488:<font color=red>    #####:  454:        return NULL;</font>
489:        -:  455:    }
490:        -:  456:    
491:       26:  457:    config_t conf = config;
492:       26:  458:    e = get_entry(key, conf);
493:        -:  459:    
494:       26:  460:    if(e == NULL) {
495:        2:  461:        conf-&gt;err = CONF_ERR;
496:        -:  462:        
497:        2:  463:        return conf;
498:        -:  464:    }
499:        -:  465:    
500:       24:  466:    switch(e-&gt;type_tag){
501:        -:  467:         case ENTRY_INT:
502:       16:  468:            e-&gt;e.scalar_int = atoi(value);
503:       16:  469:            break;
504:        -:  470:         
505:        -:  471:         case ENTRY_STR:
506:        -:  472:         
507:        8:  473:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
508:        8:  474:            break;
509:        -:  475:            
510:<font color=red>    #####:  476:         default: return conf;</font>
511:        -:  477:    }        
512:       24:  478:    conf-&gt;map[key] = e;
513:        -:  479:       
514:       24:  480:    return conf;
515:        -:  481:}
516:        -:  482:
517:function store_seq_value called 22 returned 1000locks executed 100%
518:       22:  483:config_t store_seq_value(
519:        -:  484:                    unsigned char seq,
520:        -:  485:                    unsigned char idx,  
521:        -:  486:                    const char * key,
522:        -:  487:                    const char * value, 
523:        -:  488:                    config_t config){
524:        -:  489:                    
525:       22:  490:    config_t conf = config;                
526:       22:  491:    entry_t s = conf-&gt;map[seq];
527:        -:  492:    
528:       22:  493:    if( s == NULL ||
529:       20:  494:        key == NULL || 
530:       18:  495:        value == NULL ||
531:       36:  496:        s-&gt;type_tag != ENTRY_SEQ ||
532:       18:  497:        idx &gt;= s-&gt;e.seq-&gt;size) {
533:        -:  498:        
534:        4:  499:        conf-&gt;err = CONF_ERR;
535:        -:  500:        
536:        4:  501:        return conf;
537:        -:  502:    }            
538:        -:  503:    
539:       54:  504:    variable_t var = &(conf-&gt;map[seq]
540:       18:  505:                            -&gt;e.seq
541:       36:  506:                            -&gt;vars[idx]);
542:        -:  507:    
543:       18:  508:    conf-&gt;map[seq]
544:       18:  509:        -&gt;e.seq
545:       18:  510:        -&gt;vars[idx].index = idx;
546:        -:  511:    
547:       18:  512:    if(!strcmp(key, "ID")){
548:        6:  513:         conf-&gt;map[seq]
549:        6:  514:             -&gt;e.seq
550:        6:  515:             -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
551:        -:  516:    } else {
552:        -:  517:        
553:       12:  518:        conf-&gt;map[seq]
554:       12:  519:            -&gt;e.seq
555:       24:  520:            -&gt;vars[idx].params = update_param(
556:       12:  521:                conf-&gt;map[seq]
557:       12:  522:                    -&gt;e.seq
558:       12:  523:                    -&gt;vars[idx].params,
559:        -:  524:                key,
560:        -:  525:                value);    
561:        -:  526:    }   
562:        -:  527:        
563:       18:  528:    return conf;                       
564:        -:  529:}
565:        -:  530:
566:function resize_sequence called 2 returned 1000locks executed 86%
567:        2:  531:static config_t resize_sequence(config_t config, int sequence, int size){
568:        2:  532:    config_t conf = config;
569:        2:  533:    sequence_t seq = get_sequence_entry(sequence, conf);
570:        2:  534:    if(size &lt;= 0 ||
571:        2:  535:        size &gt; CONF_MAX_SEQ || 
572:        2:  536:        sequence == NULL){
573:<font color=red>    #####:  537:        conf-&gt;err = CONF_ERR;</font>
574:        -:  538:        
575:<font color=red>    #####:  539:        return conf;</font>
576:        -:  540:    }  
577:        2:  541:    seq-&gt;size = size;
578:        2:  542:	seq-&gt;vars = (variable_t)realloc(seq-&gt;vars, size*sizeof(struct variable));
579:        2:  543:	memset(seq-&gt;vars, 0, size*sizeof(struct variable));    
580:        -:  544:        
581:        2:  545:    return conf;
582:        -:  546:}
583:        -:  547:
584:function process_seq_element called 12 returned 1000locks executed 100%
585:       12:  548:static config_t process_seq_element(
586:        -:  549:                   yaml_event_t event,
587:        -:  550:                   int sequence, 
588:        -:  551:                   const char * key,
589:        -:  552:                   int * idx,
590:        -:  553:                   config_t config){
591:        -:  554:    
592:       12:  555:    config_t conf = config;
593:       12:  556:    char * val = (char *)event.data.scalar.value;
594:       12:  557:    long size = 0;
595:       12:  558:    if(key[0] == 0) { //we are not in a map yet
596:        2:  559:        size = strtol(val, NULL, 10);
597:        -:  560:    }
598:       12:  561:    if(size &gt; 0 &&
599:        -:  562:        size &lt; CONF_MAX_SEQ){
600:        2:  563:        conf = resize_sequence(conf, sequence, (int)size);
601:       10:  564:    } else if(!strcmp(key, "INDEX")){
602:        -:  565:                             
603:        2:  566:            *idx = atoi(val);
604:        -:  567:    } else {  
605:        -:  568:                             
606:        8:  569:            conf = store_seq_value(sequence, 
607:        8:  570:                                      *idx, 
608:        -:  571:                                      key, 
609:        -:  572:                                      val, 
610:        -:  573:                                      conf);       
611:        -:  574:    }                      
612:        -:  575:      
613:       12:  576:    return conf;                       
614:        -:  577:}
615:        -:  578:
616:function process_scalar called 16 returned 1000locks executed 100%
617:       16:  579:static config_t process_scalar(
618:        -:  580:                   yaml_event_t event,
619:        -:  581:                   const char * key,
620:        -:  582:                   config_t config){
621:        -:  583:    
622:       16:  584:    config_t conf = config;
623:       16:  585:    char * val = (char *)event.data.scalar.value;
624:        -:  586:               
625:       16:  587:    conf = store_value(
626:       16:  588:                    get_key(key, conf), 
627:        -:  589:                    val, 
628:        -:  590:                    conf);
629:        -:  591:                 
630:       16:  592:    return conf;                       
631:        -:  593:}
632:        -:  594:
633:function process_mapping called 16 returned 1000locks executed 100%
634:       16:  595:static config_t process_mapping(
635:        -:  596:                    const char * key,
636:        -:  597:                    int seq,
637:        -:  598:                    yaml_parser_t *parser,
638:        -:  599:                    config_t config){
639:        -:  600:    
640:       16:  601:    config_t conf = config;                
641:       16:  602:    int k = get_key(key, conf);
642:       16:  603:    entry_t c = get_entry(k, conf);
643:        -:  604:    
644:       22:  605:    if( c != NULL &&
645:        6:  606:        c-&gt;type_tag == ENTRY_MAP) {
646:        -:  607:                    
647:        6:  608:        c-&gt;e.conf = process(
648:        -:  609:                        seq, 
649:        -:  610:                        parser, 
650:        -:  611:                        c-&gt;e.conf);        
651:        6:  612:        conf-&gt;map[k] = c;
652:        -:  613:    } else {
653:        -:  614:                    
654:       10:  615:        conf = process(
655:        -:  616:            seq, 
656:        -:  617:            parser, 
657:        -:  618:            conf);
658:        -:  619:    }
659:        -:  620:    
660:       16:  621:    return conf;    
661:        -:  622:} 
662:        -:  623:
663:function process called 30 returned 1000locks executed 94%
664:       30:  624:config_t process(int sequence, 
665:        -:  625:            yaml_parser_t *parser, 
666:        -:  626:            config_t configuration){
667:        -:  627:             
668:       30:  628:    config_t config = configuration;
669:       30:  629:    unsigned char storage = STORE_KEY;   
670:       30:  630:    int done = CONF_F;
671:        -:  631:    char key[CONF_STR];
672:       30:  632:    int idx = CONF_ERR;
673:        -:  633:    yaml_event_t event;
674:       30:  634:    memset(&event, 0, sizeof(event));
675:       30:  635:    memset(key, 0, CONF_STR);
676:       30:  636:    if(config == NULL) {
677:        -:  637:     
678:        2:  638:        return NULL;
679:        -:  639:     }
680:        -:  640:     
681:       28:  641:     if(parser == NULL) {
682:        2:  642:        config-&gt;err = CONF_ERR;
683:        -:  643:     
684:        2:  644:        return config;
685:        -:  645:     }
686:        -:  646://     || parser-&gt;context == NULL 
687:        -:  647:           
688:      184:  648:     while(done == CONF_F){
689:        -:  649:     
690:      132:  650:        if (!yaml_parser_parse(parser, &event)){   
691:<font color=red>    #####:  651:                yaml_parser_error(*parser);</font>
692:<font color=red>    #####:  652:                config-&gt;err = CONF_ERR;</font>
693:        -:  653:        } else {
694:        -:  654:   
695:      132:  655:            switch(event.type){
696:        -:  656:                case YAML_SCALAR_EVENT: 
697:        -:  657://swap storage to process val after key and vice versa 
698:       62:  658:                    if(storage == STORE_KEY) {
699:        -:  659: 
700:       34:  660:                            memset(key, 0, CONF_STR);
701:       34:  661:                            sprintf(key, "", 
702:       34:  662:                                (char *)event.data.scalar.value);
703:        -:  663:                        
704:       34:  664:                            storage = STORE_VAL;
705:        -:  665:                    } else {
706:       28:  666:                        if(sequence &gt; CONF_ERR) {
707:        -:  667:                    
708:       12:  668:                            config = process_seq_element(
709:        -:  669:                                    event,
710:        -:  670:                                    sequence,
711:        -:  671:                                    key,
712:        -:  672:                                    &idx,
713:        -:  673:                                    config);
714:        -:  674:                        } else {
715:        -:  675:                            
716:       16:  676:                            config = process_scalar(
717:        -:  677:                                    event,
718:        -:  678:                                    key,
719:        -:  679:                                    config);
720:        -:  680:                        }
721:       28:  681:                        storage = STORE_KEY;            
722:        -:  682:                    }
723:       62:  683:                    break;
724:        -:  684:                
725:        -:  685:                case YAML_SEQUENCE_START_EVENT:
726:        -:  686:
727:        2:  687:                    sequence = get_key(key, config);
728:        2:  688:                    memset(key, 0, CONF_STR);
729:        2:  689:                    break;
730:        -:  690:                
731:        -:  691:                case YAML_SEQUENCE_END_EVENT:
732:        -:  692:
733:        2:  693:                    sequence = CONF_ERR;
734:        2:  694:                    break;
735:        -:  695:                
736:        -:  696:                case YAML_MAPPING_START_EVENT:
737:        -:  697:                
738:       16:  698:                    config = process_mapping(
739:        -:  699:                                key,
740:        -:  700:                                sequence,
741:        -:  701:                                parser,
742:        -:  702:                                config); 
743:       16:  703:                    storage = STORE_KEY;            
744:       16:  704:                    break;
745:        -:  705:                    
746:        -:  706:                case YAML_MAPPING_END_EVENT:
747:        -:  707:                case YAML_STREAM_END_EVENT:     
748:        -:  708:                    
749:       24:  709:                    done = CONF_T;
750:       24:  710:                    break;
751:        -:  711:                    
752:        -:  712:                case YAML_NO_EVENT:
753:        2:  713:                    config-&gt;err = CONF_ERR;
754:        2:  714:                    break;    
755:        -:  715:                    
756:       24:  716:                default: break;    
757:        -:  717:            }
758:        -:  718:         }
759:      132:  719:         if(config-&gt;err &lt; CONF_OK) {
760:        2:  720:             done = CONF_T;
761:        2:  721:             plc_log("Could not parse event:");
762:        2:  722:             log_yml_event(event);
763:        -:  723:         }            
764:        -:  724:         //log_yml_event(event);                                  
765:        -:  725:         //yaml_event_delete(&event);   
766:        -:  726:     }
767:        -:  727:     
768:       26:  728:     return config;
769:        -:  729:}
770:        -:  730:             
771:function load_config_yml called 0 returned 00locks executed 0%
772:<font color=red>    #####:  731:config_t load_config_yml(const char * filename, config_t conf) {</font>
773:        -:  732:    yaml_parser_t parser;
774:        -:  733:    
775:        -:  734:    FILE * fcfg;
776:        -:  735:    char path[CONF_STR];
777:        -:  736:
778:<font color=red>    #####:  737:    memset(path, 0, CONF_STR);</font>
779:<font color=red>    #####:  738:    sprintf(path, "", filename);</font>
780:        -:  739:    
781:<font color=red>    #####:  740:    memset(&parser, 0, sizeof(parser));</font>
782:        -:  741:    
783:<font color=red>    #####:  742:    config_t r = conf;</font>
784:        -:  743:    
785:<font color=red>    #####:  744:    if (!yaml_parser_initialize(&parser)) {</font>
786:        -:  745:    
787:<font color=red>    #####:  746:        yaml_parser_error(parser);    </font>
788:        -:  747:    }
789:<font color=red>    #####:  748:    if ((fcfg = fopen(path, "r"))) {</font>
790:<font color=red>    #####:  749:        plc_log("Looking for configuration from  ...", path);</font>
791:<font color=red>    #####:  750:        yaml_parser_set_input_file(&parser, fcfg);</font>
792:<font color=red>    #####:  751:        r = process(CONF_ERR, &parser, conf);</font>
793:<font color=red>    #####:  752:        if(r-&gt;err &lt; CONF_OK)</font>
794:<font color=red>    #####:  753:            plc_log( "Configuration error ");</font>
795:<font color=red>    #####:  754:        fclose(fcfg);</font>
796:        -:  755:    } else {
797:<font color=red>    #####:  756:        r-&gt;err = CONF_ERR;</font>
798:<font color=red>    #####:  757:        plc_log("Could not open file ", filename);</font>
799:        -:  758:    }
800:<font color=red>    #####:  759:    yaml_parser_delete(&parser);</font>
801:<font color=red>    #####:  760:    return r;</font>
802:        -:  761:}
803:        -:  762:
804:function emit_variable called 96 returned 1000locks executed 100%
805:       96:  763:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
806:        -:  764:    yaml_event_t evt;
807:       98:  765:    if(var-&gt;name != NULL &&
808:        2:  766:        var-&gt;name[0]) {
809:        -:  767:       
810:        -:  768:        char idx[4];
811:        2:  769:        memset(idx, 0, 4);
812:        -:  770:    
813:        2:  771:        yaml_mapping_start_event_initialize(
814:        -:  772:    			        &evt,
815:        -:  773:    			        NULL,
816:        -:  774:    			        NULL,
817:        -:  775:    			        CONF_F,
818:        -:  776:    			        YAML_BLOCK_MAPPING_STYLE);
819:        -:  777:    	 	    
820:        2:  778:        yaml_emitter_emit(emitter, &evt);
821:        -:  779:    		//log_yml_event(evt);
822:        -:  780:    		            
823:        2:  781:        yaml_scalar_event_initialize(
824:        -:  782:                        	&evt,
825:        -:  783:                    	    NULL,
826:        -:  784:                    		NULL,
827:        -:  785:                    		"INDEX",
828:        -:  786:                    		5,
829:        -:  787:                    		CONF_T,
830:        -:  788:                    		CONF_T, 
831:        -:  789:                    		YAML_PLAIN_SCALAR_STYLE); 
832:        2:  790:        yaml_emitter_emit(emitter, &evt);
833:        -:  791:                    		
834:        2:  792:        sprintf(idx, "0", var-&gt;index);		
835:        2:  793:        yaml_scalar_event_initialize(
836:        -:  794:                        	&evt,
837:        -:  795:                    	    NULL,
838:        -:  796:                    		NULL,
839:        -:  797:                    		(unsigned char *)idx,
840:        2:  798:                    		strlen(idx),
841:        -:  799:                    		CONF_T,
842:        -:  800:                    		CONF_T, 
843:        -:  801:                    		YAML_PLAIN_SCALAR_STYLE); 	
844:        2:  802:        yaml_emitter_emit(emitter, &evt);
845:        -:  803:    		            
846:        -:  804:   
847:        2:  805:        yaml_scalar_event_initialize(
848:        -:  806:                        	&evt,
849:        -:  807:                    	    NULL,
850:        -:  808:                    		NULL,
851:        -:  809:                    		"ID",
852:        -:  810:                    		2,
853:        -:  811:                    		CONF_T,
854:        -:  812:                    		CONF_T, 
855:        -:  813:                    		YAML_PLAIN_SCALAR_STYLE); 
856:        2:  814:        yaml_emitter_emit(emitter, &evt);
857:        -:  815:                    			
858:        4:  816:        yaml_scalar_event_initialize(
859:        -:  817:                        	&evt,
860:        -:  818:                    	    NULL,
861:        -:  819:                    		NULL,
862:        2:  820:                    		(unsigned char *)var-&gt;name,
863:        2:  821:                    		strlen(var-&gt;name),
864:        -:  822:                    		CONF_T,
865:        -:  823:                    		CONF_T, 
866:        -:  824:                    		YAML_PLAIN_SCALAR_STYLE); 	
867:        2:  825:        yaml_emitter_emit(emitter, &evt);
868:        -:  826:       
869:        2:  827:        param_t it = var-&gt;params;
870:        6:  828:        while(it){
871:        4:  829:            yaml_scalar_event_initialize(
872:        -:  830:                        	&evt,
873:        -:  831:                    	    NULL,
874:        -:  832:                    		NULL,
875:        2:  833:                    		(unsigned char *)it-&gt;key,
876:        2:  834:                    		strlen(it-&gt;key),
877:        -:  835:                    		CONF_T,
878:        -:  836:                    		CONF_T, 
879:        -:  837:                    		YAML_PLAIN_SCALAR_STYLE); 
880:        2:  838:            yaml_emitter_emit(emitter, &evt);
881:        -:  839:                    			
882:        4:  840:            yaml_scalar_event_initialize(
883:        -:  841:                        	&evt,
884:        -:  842:                    	    NULL,
885:        -:  843:                    		NULL,
886:        2:  844:                    		(unsigned char *)it-&gt;value,
887:        2:  845:                    		strlen(it-&gt;value),
888:        -:  846:                    		CONF_T,
889:        -:  847:                    		CONF_T, 
890:        -:  848:                    		YAML_PLAIN_SCALAR_STYLE); 	
891:        2:  849:            yaml_emitter_emit(emitter, &evt);
892:        2:  850:            it = it-&gt;next; 
893:        -:  851:        }    
894:        2:  852:        yaml_mapping_end_event_initialize(&evt); 
895:        -:  853:        	
896:        2:  854:        yaml_emitter_emit(emitter, &evt); 
897:        -:  855:    }
898:       96:  856:} 
899:        -:  857:
900:function emit_entry called 50 returned 1000locks executed 97%
901:       50:  858:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
902:       50:  859:    int i = 0;
903:        -:  860:    yaml_event_t evt;
904:        -:  861:     
905:      100:  862:    yaml_scalar_event_initialize(
906:        -:  863:    	&evt,
907:        -:  864:	    NULL,
908:        -:  865:		NULL,
909:       50:  866:		(unsigned char *)entry-&gt;name,
910:       50:  867:		strlen(entry-&gt;name),
911:        -:  868:		CONF_T,
912:        -:  869:		CONF_T, 
913:        -:  870:		YAML_PLAIN_SCALAR_STYLE); 	
914:        -:  871:		
915:       50:  872:	yaml_emitter_emit(emitter, &evt);
916:        -:  873:	//log_yml_event(evt);
917:        -:  874:	char buf[CONF_NUM];
918:       50:  875:	memset(buf, 0, CONF_NUM);
919:       50:  876:	entry_t iter = NULL;
920:       50:  877:	variable_t viter = NULL;
921:        -:  878:	
922:       50:  879:	switch (entry-&gt;type_tag){
923:        -:  880:	
924:        -:  881:		case ENTRY_STR:
925:        -:  882:		
926:       16:  883:			yaml_scalar_event_initialize(
927:        -:  884:    		&evt,
928:        -:  885:	    	NULL,
929:        -:  886:         	NULL,
930:        8:  887:			(unsigned char *)entry-&gt;e.scalar_str,
931:        8:  888:			strlen(entry-&gt;e.scalar_str),
932:        -:  889:			CONF_T,
933:        -:  890:			CONF_T, 
934:        -:  891:			YAML_PLAIN_SCALAR_STYLE); 	
935:        -:  892:		
936:        8:  893:			yaml_emitter_emit(emitter, &evt); 
937:        -:  894:			//log_yml_event(evt);		
938:        8:  895:			break;
939:        -:  896:		
940:        -:  897:		case ENTRY_INT:
941:        -:  898:			
942:       18:  899:			sprintf(buf, "0", entry-&gt;e.scalar_int);
943:       18:  900:			yaml_scalar_event_initialize(
944:        -:  901:    		&evt,
945:        -:  902:	    	NULL,
946:        -:  903:			NULL,
947:        -:  904:			(unsigned char *)buf,
948:       18:  905:			strlen(buf),
949:        -:  906:			CONF_T,
950:        -:  907:			CONF_T, 
951:        -:  908:			YAML_PLAIN_SCALAR_STYLE); 	
952:        -:  909:		
953:       18:  910:			yaml_emitter_emit(emitter, &evt);
954:        -:  911:			//log_yml_event(evt); 		
955:       18:  912:			break;
956:        -:  913:				 
957:        -:  914:		case ENTRY_MAP:
958:        -:  915:		
959:        8:  916:		    yaml_mapping_start_event_initialize(
960:        -:  917:    			&evt,
961:        -:  918:    			NULL,
962:        -:  919:    			NULL,
963:        -:  920:    			CONF_F,
964:        -:  921:    			YAML_BLOCK_MAPPING_STYLE);
965:        -:  922:    	 	    
966:        8:  923:    		yaml_emitter_emit(emitter, &evt);
967:        -:  924:    		//log_yml_event(evt);
968:        8:  925:    		iter = *(entry-&gt;e.conf-&gt;map);
969:        -:  926:    		
970:       38:  927:			while(i &lt; entry-&gt;e.conf-&gt;size){
971:       22:  928:			    if(iter != NULL) {
972:       22:  929:				    emit_entry(iter, emitter);  
973:        -:  930:				}
974:       22:  931:				iter = (entry-&gt;e.conf-&gt;map)[++i];
975:        -:  932:			}	
976:        8:  933:			yaml_mapping_end_event_initialize(&evt); 	
977:        8:  934:    		yaml_emitter_emit(emitter, &evt); 
978:        -:  935:    		//log_yml_event(evt);
979:        8:  936:			break;
980:        -:  937:		
981:        -:  938:		case ENTRY_SEQ:
982:       16:  939:		  yaml_sequence_start_event_initialize(
983:        -:  940:    			&evt,
984:        -:  941:    			NULL,
985:        -:  942:    			NULL,
986:        -:  943:    			CONF_T,
987:        -:  944:    			YAML_BLOCK_SEQUENCE_STYLE);
988:        -:  945:    		//log_yml_event(evt);
989:       16:  946:    	    yaml_emitter_emit(emitter, &evt); 	
990:        -:  947:		//emit size as int
991:        -:  948:		  
992:       16:  949:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
993:       16:  950:			yaml_scalar_event_initialize(
994:        -:  951:    		&evt,
995:        -:  952:	    	NULL,
996:        -:  953:			NULL,
997:        -:  954:			(unsigned char *)buf,
998:       16:  955:			strlen(buf),
999:        -:  956:			CONF_T,
1000:        -:  957:			CONF_T, 
1001:        -:  958:			YAML_PLAIN_SCALAR_STYLE); 	
1002:        -:  959:		
1003:       16:  960:			yaml_emitter_emit(emitter, &evt);
1004:        -:  961:			//log_yml_event(evt); 		
1005:        -:  962:			//emit values as map
1006:       16:  963:			viter = entry-&gt;e.seq-&gt;vars;
1007:        -:  964:    		
1008:       16:  965:    		i = 0;
1009:      128:  966:			while(i &lt; entry-&gt;e.seq-&gt;size){
1010:       96:  967:			    if(viter != NULL) {
1011:       96:  968:				   emit_variable(viter, emitter);
1012:        -:  969:				}
1013:       96:  970:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
1014:        -:  971:			}	
1015:        -:  972:			
1016:       16:  973:			yaml_sequence_end_event_initialize(&evt); 	
1017:       16:  974:    		yaml_emitter_emit(emitter, &evt); 
1018:        -:  975:    		//log_yml_event(evt);
1019:       16:  976:			break;
1020:        -:  977:			
1021:<font color=red>    #####:  978:		default:break;</font>
1022:        -:  979:	}
1023:        -:  980:	
1024:       50:  981:}
1025:        -:  982:
1026:function emit called 2 returned 1000locks executed 100%
1027:        2:  983:int emit(yaml_emitter_t *emitter, const config_t conf) {
1028:        2:  984:    int r = CONF_OK;     
1029:        -:  985:   
1030:        -:  986:    yaml_event_t evt;
1031:        -:  987:    char val[CONF_STR];
1032:        2:  988:    memset(val,0,CONF_STR);
1033:        -:  989:    //doc start
1034:        2:  990:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, CONF_F); 
1035:        2:  991:	yaml_emitter_emit(emitter, &evt); 		
1036:        -:  992:   // log_yml_event(evt);
1037:        -:  993:    
1038:        2:  994:    yaml_mapping_start_event_initialize(
1039:        -:  995:    	&evt,
1040:        -:  996:    	NULL,
1041:        -:  997:    	NULL,
1042:        -:  998:    	CONF_F,
1043:        -:  999:    	YAML_BLOCK_MAPPING_STYLE);
1044:        -: 1000:    	 	    
1045:        2: 1001:    yaml_emitter_emit(emitter, &evt);
1046:        -: 1002:   // log_yml_event(evt);
1047:        -: 1003:    
1048:        2: 1004:    entry_map_t config_map = conf-&gt;map;
1049:        2: 1005:    entry_t iter = *config_map;
1050:        2: 1006:    int i = 0;
1051:       36: 1007:    while(i &lt; conf-&gt;size) {
1052:       32: 1008:        if(iter != NULL){
1053:       28: 1009:    	    emit_entry(iter, emitter);
1054:        -: 1010:    	}
1055:       32: 1011:    	iter = config_map[++i];
1056:        -: 1012:    }
1057:        -: 1013:   
1058:        -: 1014:    //mapping end
1059:        2: 1015:    yaml_mapping_end_event_initialize(&evt); 	
1060:        2: 1016:    yaml_emitter_emit(emitter, &evt); 		
1061:        -: 1017:    //log_yml_event(evt);
1062:        -: 1018:    
1063:        -: 1019:    //doc end
1064:        2: 1020:    yaml_document_end_event_initialize(&evt,CONF_F);
1065:        2: 1021:    yaml_emitter_emit(emitter, &evt);
1066:        -: 1022:    //log_yml_event(evt); 		
1067:        2: 1023:    yaml_event_delete(&evt); 	
1068:        2: 1024:    return r;
1069:        -: 1025:}
1070:        -: 1026:
1071:function print_config_yml called 0 returned 00locks executed 0%
1072:<font color=red>    #####: 1027:int print_config_yml(FILE * fcfg, const config_t conf) {</font>
1073:        -: 1028:    
1074:        -: 1029:    yaml_emitter_t emitter;
1075:        -: 1030:    yaml_event_t event;
1076:        -: 1031:    
1077:<font color=red>    #####: 1032:    int r = CONF_OK;</font>
1078:        -: 1033:    
1079:<font color=red>    #####: 1034:    if(!yaml_emitter_initialize(&emitter)){</font>
1080:<font color=red>    #####: 1035:        return CONF_ERR;    </font>
1081:        -: 1036:    }
1082:<font color=red>    #####: 1037:    if (fcfg) {</font>
1083:        -: 1038:         
1084:<font color=red>    #####: 1039:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1085:<font color=red>    #####: 1040:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1086:        -: 1041:         
1087:<font color=red>    #####: 1042:         r = yaml_emitter_emit(&emitter, &event);</font>
1088:        -: 1043:         
1089:<font color=red>    #####: 1044:         if(r){</font>
1090:        -: 1045:          
1091:<font color=red>    #####: 1046:            r = emit(&emitter, conf);</font>
1092:        -: 1047:         }
1093:<font color=red>    #####: 1048:         if(r){</font>
1094:<font color=red>    #####: 1049:            yaml_stream_end_event_initialize(&event);</font>
1095:        -: 1050:          
1096:<font color=red>    #####: 1051:            r = yaml_emitter_emit(&emitter, &event);   </font>
1097:        -: 1052:         }            
1098:        -: 1053:    }
1099:<font color=red>    #####: 1054:    yaml_emitter_delete(&emitter);</font>
1100:<font color=red>    #####: 1055:    return r;</font>
1101:        -: 1056:}
1102:        -: 1057:
1103:function save_config_yml called 0 returned 00locks executed 0%
1104:<font color=red>    #####: 1058:int save_config_yml(const char * filename, const config_t conf) {</font>
1105:        -: 1059:    
1106:        -: 1060://    yaml_emitter_t emitter;
1107:        -: 1061://    yaml_event_t event;
1108:        -: 1062:    
1109:        -: 1063:    FILE * fcfg;
1110:        -: 1064:    char path[CONF_STR];
1111:<font color=red>    #####: 1065:    int r = CONF_OK;</font>
1112:        -: 1066:    
1113:<font color=red>    #####: 1067:    memset(path, 0, CONF_STR);</font>
1114:<font color=red>    #####: 1068:    sprintf(path, "", filename);</font>
1115:        -: 1069:
1116:        -: 1070://    if(!yaml_emitter_initialize(&emitter)){
1117:        -: 1071://        return CONF_ERR;    
1118:        -: 1072://    }
1119:<font color=red>    #####: 1073:    if ((fcfg = fopen(path, "wb"))) {</font>
1120:<font color=red>    #####: 1074:         plc_log("Save configuration to  ...", path);</font>
1121:        -: 1075: /*        
1122:        -: 1076:         yaml_emitter_set_output_file(&emitter, fcfg);
1123:        -: 1077:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);
1124:        -: 1078:         
1125:        -: 1079:         r = yaml_emitter_emit(&emitter, &event);
1126:        -: 1080:         
1127:        -: 1081:         if(r)
1128:        -: 1082:            r = emit(&emitter, conf);
1129:        -: 1083:         if(r){
1130:        -: 1084:            yaml_stream_end_event_initialize(&event);
1131:        -: 1085:            r = yaml_emitter_emit(&emitter, &event);   
1132:        -: 1086:         }
1133:        -: 1087:   */ 
1134:<font color=red>    #####: 1088:         print_config_yml(fcfg, conf);        </font>
1135:<font color=red>    #####: 1089:         if(r &lt; CONF_OK)</font>
1136:<font color=red>    #####: 1090:            plc_log( "Configuration error ");</font>
1137:        -: 1091:            
1138:<font color=red>    #####: 1092:         fclose(fcfg);</font>
1139:        -: 1093:    } else {
1140:<font color=red>    #####: 1094:        r = CONF_ERR;</font>
1141:<font color=red>    #####: 1095:        plc_log("Could not open file  for write", filename);</font>
1142:        -: 1096:    }
1143:        -: 1097:    //yaml_emitter_delete(&emitter);
1144:<font color=red>    #####: 1098:    return r;</font>
1145:        -: 1099:}
1146:        -: 1100:
1147:        -: 1101:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
