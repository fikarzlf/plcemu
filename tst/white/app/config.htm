<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:
 10:function strdup_r called 14 returned 1000locks executed 100%
 11:       14:    5:char * strdup_r(const char * dest, const char * src) {
 12:        -:    6://strdup with realloc
 13:        -:    7:
 14:       14:    8:    char * r = (!dest)?(char *)malloc(sizeof(src)):realloc(dest, sizeof(src));
 15:        -:    9:        
 16:       14:   10:    memset(r, 0, sizeof(src));
 17:       14:   11:    sprintf(r, "", src);
 18:        -:   12:    
 19:       14:   13:    return r;
 20:        -:   14:}
 21:        -:   15:
 22:function yaml_config_error called 0 returned 00locks executed 0%
 23:<font color=red>    #####:   16:static void yaml_config_error(yaml_parser_t parser){</font>
 24:        -:   17:
 25:        -:   18:    //print line
 26:<font color=red>    #####:   19:}</font>
 27:        -:   20:
 28:function yaml_parser_error called 0 returned 00locks executed 0%
 29:<font color=red>    #####:   21:static void yaml_parser_error(yaml_parser_t parser){</font>
 30:        -:   22:
 31:<font color=red>    #####:   23:     switch (parser.error)</font>
 32:        -:   24:     {
 33:        -:   25:        case YAML_MEMORY_ERROR:
 34:<font color=red>    #####:   26:            plc_log( </font>
 35:        -:   27:            "Memory error: Not enough memory for parsing");
 36:<font color=red>    #####:   28:            break;</font>
 37:        -:   29:
 38:        -:   30:        case YAML_READER_ERROR:
 39:<font color=red>    #####:   31:            if (parser.problem_value != -1) {</font>
 40:<font color=red>    #####:   32:                plc_log( </font>
 41:        -:   33:                "Reader error: : #0 at 0", 
 42:        -:   34:                parser.problem,
 43:        -:   35:                parser.problem_value, 
 44:        -:   36:                parser.problem_offset);
 45:        -:   37:            }
 46:        -:   38:            else {
 47:<font color=red>    #####:   39:                plc_log( </font>
 48:        -:   40:                "Reader error:  at 0", 
 49:        -:   41:                parser.problem,
 50:        -:   42:                parser.problem_offset);
 51:        -:   43:            }
 52:<font color=red>    #####:   44:            break;</font>
 53:        -:   45:
 54:        -:   46:        case YAML_SCANNER_ERROR:
 55:<font color=red>    #####:   47:            if (parser.context) {</font>
 56:<font color=red>    #####:   48:                plc_log( </font>
 57:        -:   49:                "Scanner error:  at line 0, column 0"
 58:        -:   50:                        " at line 0, column 0", 
 59:        -:   51:                        parser.context,
 60:<font color=red>    #####:   52:                        parser.context_mark.line+1,</font>
 61:<font color=red>    #####:   53:                        parser.context_mark.column+1,</font>
 62:        -:   54:                        parser.problem, 
 63:<font color=red>    #####:   55:                        parser.problem_mark.line+1,</font>
 64:<font color=red>    #####:   56:                        parser.problem_mark.column+1);</font>
 65:        -:   57:            }
 66:        -:   58:            else {
 67:<font color=red>    #####:   59:                plc_log( </font>
 68:        -:   60:                "Scanner error:  at line 0, column 0",
 69:<font color=red>    #####:   61:                        parser.problem, parser.problem_mark.line+1,</font>
 70:<font color=red>    #####:   62:                        parser.problem_mark.column+1);</font>
 71:        -:   63:            }
 72:<font color=red>    #####:   64:            break;</font>
 73:        -:   65:
 74:        -:   66:        case YAML_PARSER_ERROR:
 75:<font color=red>    #####:   67:            if (parser.context) {</font>
 76:<font color=red>    #####:   68:                plc_log( </font>
 77:        -:   69:                "Parser error:  at line 0, column 0"
 78:        -:   70:                        " at line 0, column 0", 
 79:        -:   71:                        parser.context,
 80:<font color=red>    #####:   72:                        parser.context_mark.line+1,</font>
 81:<font color=red>    #####:   73:                        parser.context_mark.column+1,</font>
 82:        -:   74:                        parser.problem, 
 83:<font color=red>    #####:   75:                        parser.problem_mark.line+1,</font>
 84:<font color=red>    #####:   76:                        parser.problem_mark.column+1);</font>
 85:        -:   77:            }
 86:        -:   78:            else {
 87:<font color=red>    #####:   79:                plc_log( </font>
 88:        -:   80:                "Parser error:  at line 0, column 0",
 89:        -:   81:                        parser.problem, 
 90:<font color=red>    #####:   82:                        parser.problem_mark.line+1,</font>
 91:<font color=red>    #####:   83:                        parser.problem_mark.column+1);</font>
 92:        -:   84:            }
 93:<font color=red>    #####:   85:            break;</font>
 94:        -:   86:
 95:        -:   87:        default:
 96:        -:   88:            /* Couldn't happen. */
 97:<font color=red>    #####:   89:            plc_log( </font>
 98:        -:   90:            "Internal error\n");
 99:<font color=red>    #####:   91:            break;</font>
100:        -:   92:    }
101:<font color=red>    #####:   93:}</font>
102:        -:   94:
103:function new_entry_int called 90 returned 1000locks executed 100%
104:       90:   95:entry_t new_entry_int(int i, char * name) {
105:       90:   96:	entry_t r = (entry_t)malloc(sizeof(struct entry));
106:       90:   97:	r-&gt;type_tag = ENTRY_INT;
107:       90:   98:	r-&gt;name = name;
108:       90:   99:	r-&gt;e.scalar_int = i;
109:        -:  100:
110:       90:  101:	return r;
111:        -:  102:}
112:        -:  103:
113:function new_entry_str called 40 returned 1000locks executed 100%
114:       40:  104:entry_t new_entry_str(char * str, char * name) {
115:        -:  105:
116:       40:  106:	entry_t r = (entry_t)malloc(sizeof(struct entry));
117:       40:  107:	r-&gt;type_tag = ENTRY_STR;
118:       40:  108:	r-&gt;name = name;
119:       40:  109:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
120:       40:  110:    sprintf(r-&gt;e.scalar_str, "", str);
121:       40:  111:	return r;
122:        -:  112:}
123:        -:  113:
124:function new_entry_map called 40 returned 1000locks executed 100%
125:       40:  114:entry_t new_entry_map(config_t map, char * name) {
126:        -:  115:	
127:       40:  116:	entry_t r = (entry_t)malloc(sizeof(struct entry));
128:       40:  117:	r-&gt;type_tag = ENTRY_MAP;
129:       40:  118:	r-&gt;name = name;
130:       40:  119:	r-&gt;e.conf = map;
131:        -:  120:
132:       40:  121:	return r;
133:        -:  122:}
134:        -:  123:
135:function new_entry_seq called 80 returned 1000locks executed 100%
136:       80:  124:entry_t new_entry_seq(sequence_t seq, char * name) {
137:        -:  125:	
138:       80:  126:	entry_t r = (entry_t)malloc(sizeof(struct entry));
139:       80:  127:	r-&gt;type_tag = ENTRY_SEQ;
140:       80:  128:	r-&gt;name = name;
141:       80:  129:	r-&gt;e.seq = seq;
142:        -:  130:
143:       80:  131:	return r;
144:        -:  132:}
145:        -:  133:
146:function new_entry_null called 0 returned 00locks executed 0%
147:<font color=red>    #####:  134:entry_t new_entry_null() {</font>
148:<font color=red>    #####:  135:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
149:<font color=red>    #####:  136:	r-&gt;type_tag = ENTRY_NONE;</font>
150:<font color=red>    #####:  137:	r-&gt;name = "";</font>
151:<font color=red>    #####:  138:	r-&gt;e.scalar_int = 0;</font>
152:        -:  139:
153:<font color=red>    #####:  140:	return r;</font>
154:        -:  141:}
155:        -:  142:
156:function update_entry called 250 returned 1000locks executed 80%
157:      250:  143:config_t update_entry(
158:        -:  144:    unsigned int key, 
159:        -:  145:    const entry_t item,
160:        -:  146:    const config_t conf) {
161:        -:  147:    
162:      500:  148:    if( conf == NULL ||
163:      250:  149:        key &gt;= conf-&gt;size) {
164:        -:  150:    
165:<font color=red>    #####:  151:        return conf;</font>
166:        -:  152:    } else {
167:        -:  153:    
168:      250:  154:        config_t r = conf;
169:      250:  155:        r-&gt;map[key] = item;
170:        -:  156:        
171:      250:  157:        return r;
172:        -:  158:    }
173:        -:  159:}
174:        -:  160:
175:function get_entry called 100 returned 1000locks executed 100%
176:      100:  161:entry_t get_entry(int key, const config_t conf){
177:        -:  162:
178:      100:  163:    if(conf == NULL || 
179:       88:  164:        key &lt; 0 || 
180:       88:  165:        key &gt; conf-&gt;size) {
181:        -:  166:        
182:       12:  167:        return NULL;    
183:        -:  168:    }
184:        -:  169:    
185:       88:  170:    return conf-&gt;map[key];
186:        -:  171:}
187:        -:  172:
188:function get_numeric_entry called 4 returned 1000locks executed 100%
189:        4:  173:int get_numeric_entry(int key, const config_t conf){
190:        4:  174:    entry_t e = get_entry(key, conf);
191:        4:  175:    if(e && e-&gt;type_tag == ENTRY_INT){
192:        -:  176:    
193:        2:  177:        return e-&gt;e.scalar_int;
194:        -:  178:    } else {
195:        -:  179:    
196:        2:  180:        return CONF_ERR;    
197:        -:  181:    } 
198:        -:  182:}
199:        -:  183:
200:function get_string_entry called 4 returned 1000locks executed 100%
201:        4:  184:char * get_string_entry(int key, const config_t conf){
202:        -:  185:    
203:        4:  186:    entry_t e = get_entry(key, conf);
204:        4:  187:    if(e && e-&gt;type_tag == ENTRY_STR){
205:        -:  188:    
206:        2:  189:        return e-&gt;e.scalar_str;
207:        -:  190:    } else {
208:        -:  191:    
209:        2:  192:        return NULL;    
210:        -:  193:    }    
211:        -:  194:}
212:        -:  195:
213:function get_sequence_entry called 2 returned 1000locks executed 83%
214:        2:  196:sequence_t get_sequence_entry(int key, const config_t conf){
215:        2:  197:    entry_t e = get_entry(key, conf);
216:        2:  198:    if(e && e-&gt;type_tag == ENTRY_SEQ){
217:        -:  199:    
218:        2:  200:        return e-&gt;e.seq;
219:        -:  201:    } else {
220:        -:  202:    
221:<font color=red>    #####:  203:        return NULL;    </font>
222:        -:  204:    }    
223:        -:  205:}
224:        -:  206:
225:function get_recursive_entry called 0 returned 00locks executed 0%
226:<font color=red>    #####:  207:config_t get_recursive_entry(int key, const config_t conf){</font>
227:<font color=red>    #####:  208:    entry_t e = get_entry(key, conf);</font>
228:<font color=red>    #####:  209:    if(e && e-&gt;type_tag == ENTRY_MAP){</font>
229:        -:  210:    
230:<font color=red>    #####:  211:        return e-&gt;e.conf;</font>
231:        -:  212:    } else {
232:        -:  213:    
233:<font color=red>    #####:  214:        return NULL;    </font>
234:        -:  215:    }    
235:        -:  216:}
236:        -:  217:
237:        -:  218://TODO: in a c++ impl. this would be a hashmap
238:function new_param called 12 returned 1000locks executed 100%
239:       12:  219:param_t new_param(const char * key, 
240:        -:  220:                     const char * val){
241:        -:  221:    
242:       12:  222:        param_t n = (param_t)malloc(sizeof(struct param));
243:       12:  223:        n-&gt;key = strdup(key);
244:       12:  224:        n-&gt;value = strdup(val);
245:       12:  225:        n-&gt;next = NULL;
246:        -:  226:        
247:       12:  227:        return n;        
248:        -:  228:}
249:        -:  229:
250:function get_param called 10 returned 1000locks executed 100%
251:       10:  230:param_t get_param(const char * key, const param_t params){
252:       10:  231:    param_t it = params;
253:       30:  232:    while(it && key){
254:       16:  233:        if(!strcmp(it-&gt;key, key)){
255:        -:  234:        
256:        6:  235:            return it;
257:        -:  236:        }
258:       10:  237:        it = it-&gt;next;            
259:        -:  238:    }
260:        -:  239:    
261:        4:  240:    return NULL;
262:        -:  241:}
263:        -:  242:
264:function get_param_val called 6 returned 1000locks executed 83%
265:        6:  243:char * get_param_val(const char * key, const param_t params){
266:        6:  244:    param_t it = get_param(key, params);
267:        -:  245:    
268:        6:  246:    return it?it-&gt;value:NULL;
269:        -:  247:}
270:        -:  248:
271:function append_param called 4 returned 1000locks executed 88%
272:        4:  249:param_t append_param(const param_t params, 
273:        -:  250:                     const char * key, 
274:        -:  251:                     const char * val){
275:        -:  252:        
276:        4:  253:    if(params == NULL){
277:        -:  254:        
278:<font color=red>    #####:  255:        return new_param(key, val);</font>
279:        -:  256:    } else {
280:        4:  257:        param_t ret = params;
281:        4:  258:        param_t it = params;
282:       10:  259:        while(it-&gt;next){
283:        2:  260:            it = it-&gt;next;
284:        -:  261:        }
285:        4:  262:        it-&gt;next = new_param(key, val);
286:        -:  263:                
287:        4:  264:        return ret;    
288:        -:  265:    }
289:        -:  266:}
290:        -:  267:
291:function update_param called 12 returned 1000locks executed 78%
292:       12:  268:param_t update_param(const param_t params, 
293:        -:  269:                     const char * key, 
294:        -:  270:                     const char * val){
295:        -:  271:        
296:       12:  272:    if(params == NULL){
297:        -:  273:        
298:        8:  274:        return new_param(key, val);         
299:        -:  275:    } else {
300:        4:  276:        param_t ret = params;
301:        4:  277:        param_t par = get_param(key, params);
302:        4:  278:        if(par){
303:<font color=red>    #####:  279:            par-&gt;value = strdup_r(par-&gt;value, val);</font>
304:        -:  280:        } else {
305:        -:  281:        //FIXME: ..and this is why we need a hashmap.
306:        4:  282:            ret = append_param(ret, key, val);  
307:        -:  283:        } 
308:        4:  284:        return ret;    
309:        -:  285:    }
310:        -:  286:}
311:        -:  287:
312:function get_key called 38 returned 1000locks executed 100%
313:       38:  288:int get_key(const char * name, const config_t where) {
314:       38:  289:     if(where != NULL){
315:        -:  290:    
316:      398:  291:        for(int i = 0; i &lt; where-&gt;size; i++) {
317:      618:  292:            if( where-&gt;map[i] != NULL &&
318:      230:  293:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
319:        -:  294:                
320:       28:  295:                return i;
321:        -:  296:            }
322:        -:  297:        }
323:        -:  298:    }
324:        -:  299:    
325:       10:  300:    return CONF_ERR;  
326:        -:  301:}
327:        -:  302:
328:function new_config called 50 returned 1000locks executed 100%
329:       50:  303:config_t new_config(int size) {
330:       50:  304:    config_t r = (config_t)malloc(sizeof(struct config));
331:       50:  305:	memset(r, 0, sizeof(struct config));
332:       50:  306:	r-&gt;size = size;
333:       50:  307:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
334:       50:  308:    memset(r-&gt;map, 0, size*sizeof(struct entry));
335:        -:  309:    
336:       50:  310:	return r;
337:        -:  311:}
338:        -:  312:
339:function new_sequence called 80 returned 1000locks executed 100%
340:       80:  313:sequence_t new_sequence(int size) {
341:       80:  314:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
342:       80:  315:	memset(r, 0, sizeof(struct sequence));
343:       80:  316:	r-&gt;size = size;
344:       80:  317:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
345:       80:  318:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
346:        -:  319:	
347:       80:  320:	return r;
348:        -:  321:}
349:        -:  322:
350:function clear_config called 4 returned 1000locks executed 100%
351:        4:  323:config_t clear_config(config_t c){
352:        -:  324:
353:        4:  325:    return (config_t)NULL;
354:        -:  326:}
355:        -:  327:
356:function log_yml_event called 130 returned 1000locks executed 88%
357:      130:  328:static int log_yml_event(yaml_event_t event){
358:        -:  329:
359:      130:  330:    switch(event.type){ 
360:        -:  331:    
361:        -:  332:        case YAML_NO_EVENT: 
362:        2:  333:        	plc_log("No event!"); 
363:        2:  334:            break;
364:        -:  335:    /* Stream start/end */
365:        -:  336:        case YAML_STREAM_START_EVENT: 
366:        8:  337:        	plc_log("STREAM START"); 
367:        8:  338:            break;
368:        -:  339:        case YAML_STREAM_END_EVENT: 
369:        8:  340:        	plc_log("STREAM END");   
370:        8:  341:            break;
371:        -:  342:    /* Block delimeters */
372:        -:  343:        case YAML_DOCUMENT_START_EVENT: 
373:        8:  344:        	plc_log("Start Document"); 
374:        8:  345:            break;
375:        -:  346:        case YAML_DOCUMENT_END_EVENT: 
376:        8:  347:        	plc_log("End Document");   
377:        8:  348:            break;
378:        -:  349:        case YAML_SEQUENCE_START_EVENT: 
379:        2:  350:        	plc_log("Start Sequence"); 
380:        2:  351:            break;
381:        -:  352:        case YAML_SEQUENCE_END_EVENT: 
382:        2:  353:        	plc_log("End Sequence");
383:        2:  354:            break;
384:        -:  355:        case YAML_MAPPING_START_EVENT: 
385:       16:  356:        	plc_log("Start Mapping");         
386:       16:  357:            break;
387:        -:  358:        case YAML_MAPPING_END_EVENT: 
388:       16:  359:        	plc_log("End Mapping");      
389:       16:  360:            break;
390:        -:  361:    /* Data */
391:        -:  362:        case YAML_ALIAS_EVENT:  
392:<font color=red>    #####:  363:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
393:<font color=red>    #####:  364:            break;</font>
394:        -:  365:        case YAML_SCALAR_EVENT: 
395:       60:  366:        	plc_log("Got scalar (value )", event.data.scalar.value); 
396:       60:  367:        	break;
397:        -:  368:        default:
398:<font color=red>    #####:  369:            plc_log("default?");</font>
399:        -:  370:    }
400:      130:  371:    return CONF_OK;
401:        -:  372:}
402:        -:  373:
403:function store_value called 26 returned 1000locks executed 85%
404:       26:  374:config_t store_value(
405:        -:  375:            unsigned char key, 
406:        -:  376:            const char * value, 
407:        -:  377:            config_t config){
408:        -:  378:
409:        -:  379:    entry_t e; 
410:       26:  380:    if( config == NULL) {
411:        -:  381:    
412:<font color=red>    #####:  382:        return NULL;</font>
413:        -:  383:    }
414:        -:  384:    
415:       26:  385:    config_t conf = config;
416:       26:  386:    e = get_entry(key, conf);
417:        -:  387:    
418:       26:  388:    if(e == NULL) {
419:        2:  389:        conf-&gt;err = CONF_ERR;
420:        -:  390:        
421:        2:  391:        return conf;
422:        -:  392:    }
423:        -:  393:    
424:       24:  394:    switch(e-&gt;type_tag){
425:        -:  395:         case ENTRY_INT:
426:       16:  396:            e-&gt;e.scalar_int = atoi(value);
427:       16:  397:            break;
428:        -:  398:         
429:        -:  399:         case ENTRY_STR:
430:        -:  400:         
431:        8:  401:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
432:        8:  402:            break;
433:        -:  403:            
434:<font color=red>    #####:  404:         default: return conf;</font>
435:        -:  405:    }        
436:       24:  406:    conf-&gt;map[key] = e;
437:        -:  407:       
438:       24:  408:    return conf;
439:        -:  409:}
440:        -:  410:
441:function store_seq_value called 22 returned 1000locks executed 100%
442:       22:  411:config_t store_seq_value(
443:        -:  412:                    unsigned char seq,
444:        -:  413:                    unsigned char idx,  
445:        -:  414:                    const char * key,
446:        -:  415:                    const char * value, 
447:        -:  416:                    config_t config){
448:        -:  417:                    
449:       22:  418:    config_t conf = config;                
450:       22:  419:    entry_t s = conf-&gt;map[seq];
451:        -:  420:    
452:       22:  421:    if( s == NULL ||
453:       20:  422:        key == NULL || 
454:       18:  423:        value == NULL ||
455:       36:  424:        s-&gt;type_tag != ENTRY_SEQ ||
456:       18:  425:        idx &gt;= s-&gt;e.seq-&gt;size) {
457:        -:  426:        
458:        4:  427:        conf-&gt;err = CONF_ERR;
459:        -:  428:        
460:        4:  429:        return conf;
461:        -:  430:    }            
462:        -:  431:    
463:       54:  432:    variable_t var = &(conf-&gt;map[seq]
464:       18:  433:                            -&gt;e.seq
465:       36:  434:                            -&gt;vars[idx]);
466:        -:  435:    
467:       18:  436:    conf-&gt;map[seq]
468:       18:  437:        -&gt;e.seq
469:       18:  438:        -&gt;vars[idx].index = idx;
470:        -:  439:    
471:       18:  440:    if(!strcmp(key, "ID")){
472:        6:  441:         conf-&gt;map[seq]
473:        6:  442:             -&gt;e.seq
474:        6:  443:             -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
475:        -:  444:    } else {
476:        -:  445:        
477:       12:  446:        conf-&gt;map[seq]
478:       12:  447:            -&gt;e.seq
479:       24:  448:            -&gt;vars[idx].params = update_param(
480:       12:  449:                conf-&gt;map[seq]
481:       12:  450:                    -&gt;e.seq
482:       12:  451:                    -&gt;vars[idx].params,
483:        -:  452:                key,
484:        -:  453:                value);    
485:        -:  454:    }   
486:        -:  455:        
487:       18:  456:    return conf;                       
488:        -:  457:}
489:        -:  458:
490:function process_seq_element called 10 returned 1000locks executed 100%
491:       10:  459:static config_t process_seq_element(
492:        -:  460:                   yaml_event_t event,
493:        -:  461:                   int sequence, 
494:        -:  462:                   const char * key,
495:        -:  463:                   int * idx,
496:        -:  464:                   config_t config){
497:        -:  465:    
498:       10:  466:    config_t conf = config;
499:       10:  467:    char * val = (char *)event.data.scalar.value;
500:        -:  468:                    
501:       10:  469:    if(!strcmp(key, "INDEX")){
502:        -:  470:                             
503:        2:  471:            *idx = atoi(val);
504:        -:  472:    } else {  
505:        -:  473:                             
506:        8:  474:            conf = store_seq_value(sequence, 
507:        8:  475:                                      *idx, 
508:        -:  476:                                      key, 
509:        -:  477:                                      val, 
510:        -:  478:                                      conf);       
511:        -:  479:    }                      
512:        -:  480:      
513:       10:  481:    return conf;                       
514:        -:  482:}
515:        -:  483:
516:function process_scalar called 16 returned 1000locks executed 100%
517:       16:  484:static config_t process_scalar(
518:        -:  485:                   yaml_event_t event,
519:        -:  486:                   const char * key,
520:        -:  487:                   config_t config){
521:        -:  488:    
522:       16:  489:    config_t conf = config;
523:       16:  490:    char * val = (char *)event.data.scalar.value;
524:        -:  491:               
525:       16:  492:    conf = store_value(
526:       16:  493:                    get_key(key, conf), 
527:        -:  494:                    val, 
528:        -:  495:                    conf);
529:        -:  496:                 
530:       16:  497:    return conf;                       
531:        -:  498:}
532:        -:  499:
533:function process_mapping called 16 returned 1000locks executed 100%
534:       16:  500:static config_t process_mapping(
535:        -:  501:                    const char * key,
536:        -:  502:                    int seq,
537:        -:  503:                    yaml_parser_t *parser,
538:        -:  504:                    config_t config){
539:        -:  505:    
540:       16:  506:    config_t conf = config;                
541:       16:  507:    int k = get_key(key, conf);
542:       16:  508:    entry_t c = get_entry(k, conf);
543:        -:  509:    
544:       24:  510:    if( c != NULL &&
545:        8:  511:        c-&gt;type_tag == ENTRY_MAP) {
546:        -:  512:                    
547:        6:  513:        c-&gt;e.conf = process(
548:        -:  514:                        seq, 
549:        -:  515:                        parser, 
550:        -:  516:                        c-&gt;e.conf);        
551:        6:  517:        conf-&gt;map[k] = c;
552:        -:  518:    } else {
553:        -:  519:                    
554:       10:  520:        conf = process(
555:        -:  521:            seq, 
556:        -:  522:            parser, 
557:        -:  523:            conf);
558:        -:  524:    }
559:        -:  525:    
560:       16:  526:    return conf;    
561:        -:  527:} 
562:        -:  528:
563:function process called 30 returned 1000locks executed 94%
564:       30:  529:config_t process(int sequence, 
565:        -:  530:            yaml_parser_t *parser, 
566:        -:  531:            config_t configuration){
567:        -:  532:             
568:       30:  533:    config_t config = configuration;
569:       30:  534:    unsigned char storage = STORE_KEY;   
570:       30:  535:    int done = CONF_F;
571:        -:  536:    char key[CONF_STR];
572:       30:  537:    int idx = CONF_ERR;
573:        -:  538:    yaml_event_t event;
574:       30:  539:    memset(&event, 0, sizeof(event));
575:       30:  540:    memset(key, 0, CONF_STR);
576:       30:  541:    if(config == NULL) {
577:        -:  542:     
578:        2:  543:        return NULL;
579:        -:  544:     }
580:        -:  545:     
581:       28:  546:     if(parser == NULL) {
582:        2:  547:        config-&gt;err = CONF_ERR;
583:        -:  548:     
584:        2:  549:        return config;
585:        -:  550:     }
586:        -:  551://     || parser-&gt;context == NULL 
587:        -:  552:           
588:      182:  553:     while(done == CONF_F){
589:        -:  554:     
590:      130:  555:        if (!yaml_parser_parse(parser, &event)){   
591:<font color=red>    #####:  556:                yaml_parser_error(*parser);</font>
592:<font color=red>    #####:  557:                config-&gt;err = CONF_ERR;</font>
593:        -:  558:        } else {
594:        -:  559:   
595:      130:  560:            switch(event.type){
596:        -:  561:                case YAML_SCALAR_EVENT: 
597:        -:  562://swap storage to process val after key and vice versa 
598:       60:  563:                    if(storage == STORE_KEY) {
599:       34:  564:                        memset(key, 0, CONF_STR);
600:       34:  565:                        sprintf(key, "", 
601:       34:  566:                            (char *)event.data.scalar.value);
602:        -:  567:                        
603:       34:  568:                        storage = STORE_VAL;
604:        -:  569:                    } else {
605:       26:  570:                        if(sequence &gt; CONF_ERR) {
606:        -:  571:                    
607:       10:  572:                            config = process_seq_element(
608:        -:  573:                                    event,
609:        -:  574:                                    sequence,
610:        -:  575:                                    key,
611:        -:  576:                                    &idx,
612:        -:  577:                                    config);
613:        -:  578:                        } else {
614:        -:  579:                            
615:       16:  580:                            config = process_scalar(
616:        -:  581:                                    event,
617:        -:  582:                                    key,
618:        -:  583:                                    config);
619:        -:  584:                        }
620:       26:  585:                        storage = STORE_KEY;            
621:        -:  586:                    }
622:       60:  587:                    break;
623:        -:  588:                
624:        -:  589:                case YAML_SEQUENCE_START_EVENT:
625:        -:  590:
626:        2:  591:                    sequence = get_key(key, config);
627:        2:  592:                    break;
628:        -:  593:                
629:        -:  594:                case YAML_SEQUENCE_END_EVENT:
630:        -:  595:
631:        2:  596:                    sequence = CONF_ERR;
632:        2:  597:                    break;
633:        -:  598:                
634:        -:  599:                case YAML_MAPPING_START_EVENT:
635:        -:  600:                
636:       16:  601:                    config = process_mapping(
637:        -:  602:                                key,
638:        -:  603:                                sequence,
639:        -:  604:                                parser,
640:        -:  605:                                config); 
641:       16:  606:                    storage = STORE_KEY;            
642:       16:  607:                    break;
643:        -:  608:                    
644:        -:  609:                case YAML_MAPPING_END_EVENT:
645:        -:  610:                case YAML_STREAM_END_EVENT:     
646:        -:  611:                    
647:       24:  612:                    done = CONF_T;
648:       24:  613:                    break;
649:        -:  614:                    
650:        -:  615:                case YAML_NO_EVENT:
651:        2:  616:                    config-&gt;err = CONF_ERR;
652:        2:  617:                    break;    
653:        -:  618:                    
654:       24:  619:                default: break;    
655:        -:  620:            }
656:        -:  621:         }
657:      130:  622:         if(config-&gt;err &lt; CONF_OK) {
658:        2:  623:             done = CONF_T;
659:        -:  624:             //log_yml_event(event);
660:        -:  625:         }            
661:      130:  626:         log_yml_event(event);                                  
662:      130:  627:         yaml_event_delete(&event);   
663:        -:  628:     }
664:        -:  629:     
665:       26:  630:     return config;
666:        -:  631:}
667:        -:  632:             
668:function load_config_yml called 0 returned 00locks executed 0%
669:<font color=red>    #####:  633:config_t load_config_yml(const char * filename, config_t conf) {</font>
670:        -:  634:    yaml_parser_t parser;
671:        -:  635:    
672:        -:  636:    FILE * fcfg;
673:        -:  637:    char path[CONF_STR];
674:        -:  638:
675:<font color=red>    #####:  639:    memset(path, 0, CONF_STR);</font>
676:<font color=red>    #####:  640:    sprintf(path, "", filename);</font>
677:        -:  641:    
678:<font color=red>    #####:  642:    memset(&parser, 0, sizeof(parser));</font>
679:        -:  643:    
680:<font color=red>    #####:  644:    config_t r = conf;</font>
681:        -:  645:    
682:<font color=red>    #####:  646:    if (!yaml_parser_initialize(&parser)) {</font>
683:        -:  647:    
684:<font color=red>    #####:  648:        yaml_parser_error(parser);    </font>
685:        -:  649:    }
686:<font color=red>    #####:  650:    if ((fcfg = fopen(path, "r"))) {</font>
687:<font color=red>    #####:  651:        plc_log("Looking for configuration from  ...", path);</font>
688:<font color=red>    #####:  652:        yaml_parser_set_input_file(&parser, fcfg);</font>
689:<font color=red>    #####:  653:        r = process(CONF_ERR, &parser, conf);</font>
690:<font color=red>    #####:  654:        if(r-&gt;err &lt; CONF_OK)</font>
691:<font color=red>    #####:  655:            plc_log( "Configuration error ");</font>
692:<font color=red>    #####:  656:        fclose(fcfg);</font>
693:        -:  657:    } else {
694:<font color=red>    #####:  658:        r-&gt;err = CONF_ERR;</font>
695:<font color=red>    #####:  659:        plc_log("Could not open file ", filename);</font>
696:        -:  660:    }
697:<font color=red>    #####:  661:    yaml_parser_delete(&parser);</font>
698:<font color=red>    #####:  662:    return r;</font>
699:        -:  663:}
700:        -:  664:
701:function emit_variable called 96 returned 1000locks executed 100%
702:       96:  665:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
703:        -:  666:    yaml_event_t evt;
704:       98:  667:    if(var-&gt;name != NULL &&
705:        2:  668:        var-&gt;name[0]) {
706:        -:  669:       
707:        -:  670:        char idx[4];
708:        2:  671:        memset(idx, 0, 4);
709:        -:  672:    
710:        2:  673:        yaml_mapping_start_event_initialize(
711:        -:  674:    			        &evt,
712:        -:  675:    			        NULL,
713:        -:  676:    			        NULL,
714:        -:  677:    			        CONF_F,
715:        -:  678:    			        YAML_BLOCK_MAPPING_STYLE);
716:        -:  679:    	 	    
717:        2:  680:        yaml_emitter_emit(emitter, &evt);
718:        -:  681:    		//log_yml_event(evt);
719:        -:  682:    		            
720:        2:  683:        yaml_scalar_event_initialize(
721:        -:  684:                        	&evt,
722:        -:  685:                    	    NULL,
723:        -:  686:                    		NULL,
724:        -:  687:                    		"INDEX",
725:        -:  688:                    		5,
726:        -:  689:                    		CONF_T,
727:        -:  690:                    		CONF_T, 
728:        -:  691:                    		YAML_PLAIN_SCALAR_STYLE); 
729:        2:  692:        yaml_emitter_emit(emitter, &evt);
730:        -:  693:                    		
731:        2:  694:        sprintf(idx, "0", var-&gt;index);		
732:        2:  695:        yaml_scalar_event_initialize(
733:        -:  696:                        	&evt,
734:        -:  697:                    	    NULL,
735:        -:  698:                    		NULL,
736:        -:  699:                    		(unsigned char *)idx,
737:        2:  700:                    		strlen(idx),
738:        -:  701:                    		CONF_T,
739:        -:  702:                    		CONF_T, 
740:        -:  703:                    		YAML_PLAIN_SCALAR_STYLE); 	
741:        2:  704:        yaml_emitter_emit(emitter, &evt);
742:        -:  705:    		            
743:        -:  706:   
744:        2:  707:        yaml_scalar_event_initialize(
745:        -:  708:                        	&evt,
746:        -:  709:                    	    NULL,
747:        -:  710:                    		NULL,
748:        -:  711:                    		"ID",
749:        -:  712:                    		2,
750:        -:  713:                    		CONF_T,
751:        -:  714:                    		CONF_T, 
752:        -:  715:                    		YAML_PLAIN_SCALAR_STYLE); 
753:        2:  716:        yaml_emitter_emit(emitter, &evt);
754:        -:  717:                    			
755:        4:  718:        yaml_scalar_event_initialize(
756:        -:  719:                        	&evt,
757:        -:  720:                    	    NULL,
758:        -:  721:                    		NULL,
759:        2:  722:                    		(unsigned char *)var-&gt;name,
760:        2:  723:                    		strlen(var-&gt;name),
761:        -:  724:                    		CONF_T,
762:        -:  725:                    		CONF_T, 
763:        -:  726:                    		YAML_PLAIN_SCALAR_STYLE); 	
764:        2:  727:        yaml_emitter_emit(emitter, &evt);
765:        -:  728:       
766:        2:  729:        param_t it = var-&gt;params;
767:        6:  730:        while(it){
768:        4:  731:            yaml_scalar_event_initialize(
769:        -:  732:                        	&evt,
770:        -:  733:                    	    NULL,
771:        -:  734:                    		NULL,
772:        2:  735:                    		(unsigned char *)it-&gt;key,
773:        2:  736:                    		strlen(it-&gt;key),
774:        -:  737:                    		CONF_T,
775:        -:  738:                    		CONF_T, 
776:        -:  739:                    		YAML_PLAIN_SCALAR_STYLE); 
777:        2:  740:            yaml_emitter_emit(emitter, &evt);
778:        -:  741:                    			
779:        4:  742:            yaml_scalar_event_initialize(
780:        -:  743:                        	&evt,
781:        -:  744:                    	    NULL,
782:        -:  745:                    		NULL,
783:        2:  746:                    		(unsigned char *)it-&gt;value,
784:        2:  747:                    		strlen(it-&gt;value),
785:        -:  748:                    		CONF_T,
786:        -:  749:                    		CONF_T, 
787:        -:  750:                    		YAML_PLAIN_SCALAR_STYLE); 	
788:        2:  751:            yaml_emitter_emit(emitter, &evt);
789:        2:  752:            it = it-&gt;next; 
790:        -:  753:        }    
791:        2:  754:        yaml_mapping_end_event_initialize(&evt); 
792:        -:  755:        	
793:        2:  756:        yaml_emitter_emit(emitter, &evt); 
794:        -:  757:    }
795:       96:  758:} 
796:        -:  759:
797:function emit_entry called 50 returned 1000locks executed 97%
798:       50:  760:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
799:       50:  761:    int i = 0;
800:        -:  762:    yaml_event_t evt;
801:        -:  763:     
802:      100:  764:    yaml_scalar_event_initialize(
803:        -:  765:    	&evt,
804:        -:  766:	    NULL,
805:        -:  767:		NULL,
806:       50:  768:		(unsigned char *)entry-&gt;name,
807:       50:  769:		strlen(entry-&gt;name),
808:        -:  770:		CONF_T,
809:        -:  771:		CONF_T, 
810:        -:  772:		YAML_PLAIN_SCALAR_STYLE); 	
811:        -:  773:		
812:       50:  774:	yaml_emitter_emit(emitter, &evt);
813:        -:  775:	//log_yml_event(evt);
814:        -:  776:	char buf[CONF_NUM];
815:       50:  777:	memset(buf, 0, CONF_NUM);
816:       50:  778:	entry_t iter = NULL;
817:       50:  779:	variable_t viter = NULL;
818:        -:  780:	
819:       50:  781:	switch (entry-&gt;type_tag){
820:        -:  782:	
821:        -:  783:		case ENTRY_STR:
822:        -:  784:		
823:       16:  785:			yaml_scalar_event_initialize(
824:        -:  786:    		&evt,
825:        -:  787:	    	NULL,
826:        -:  788:         	NULL,
827:        8:  789:			(unsigned char *)entry-&gt;e.scalar_str,
828:        8:  790:			strlen(entry-&gt;e.scalar_str),
829:        -:  791:			CONF_T,
830:        -:  792:			CONF_T, 
831:        -:  793:			YAML_PLAIN_SCALAR_STYLE); 	
832:        -:  794:		
833:        8:  795:			yaml_emitter_emit(emitter, &evt); 
834:        -:  796:			//log_yml_event(evt);		
835:        8:  797:			break;
836:        -:  798:		
837:        -:  799:		case ENTRY_INT:
838:        -:  800:			
839:       18:  801:			sprintf(buf, "0", entry-&gt;e.scalar_int);
840:       18:  802:			yaml_scalar_event_initialize(
841:        -:  803:    		&evt,
842:        -:  804:	    	NULL,
843:        -:  805:			NULL,
844:        -:  806:			(unsigned char *)buf,
845:       18:  807:			strlen(buf),
846:        -:  808:			CONF_T,
847:        -:  809:			CONF_T, 
848:        -:  810:			YAML_PLAIN_SCALAR_STYLE); 	
849:        -:  811:		
850:       18:  812:			yaml_emitter_emit(emitter, &evt);
851:        -:  813:			//log_yml_event(evt); 		
852:       18:  814:			break;
853:        -:  815:				 
854:        -:  816:		case ENTRY_MAP:
855:        -:  817:		
856:        8:  818:		    yaml_mapping_start_event_initialize(
857:        -:  819:    			&evt,
858:        -:  820:    			NULL,
859:        -:  821:    			NULL,
860:        -:  822:    			CONF_F,
861:        -:  823:    			YAML_BLOCK_MAPPING_STYLE);
862:        -:  824:    	 	    
863:        8:  825:    		yaml_emitter_emit(emitter, &evt);
864:        -:  826:    		//log_yml_event(evt);
865:        8:  827:    		iter = *(entry-&gt;e.conf-&gt;map);
866:        -:  828:    		
867:       38:  829:			while(i &lt; entry-&gt;e.conf-&gt;size){
868:       22:  830:			    if(iter != NULL) {
869:       22:  831:				    emit_entry(iter, emitter);  
870:        -:  832:				}
871:       22:  833:				iter = (entry-&gt;e.conf-&gt;map)[++i];
872:        -:  834:			}	
873:        8:  835:			yaml_mapping_end_event_initialize(&evt); 	
874:        8:  836:    		yaml_emitter_emit(emitter, &evt); 
875:        -:  837:    		//log_yml_event(evt);
876:        8:  838:			break;
877:        -:  839:		
878:        -:  840:		case ENTRY_SEQ:
879:       16:  841:		  yaml_sequence_start_event_initialize(
880:        -:  842:    			&evt,
881:        -:  843:    			NULL,
882:        -:  844:    			NULL,
883:        -:  845:    			CONF_T,
884:        -:  846:    			YAML_BLOCK_SEQUENCE_STYLE);
885:        -:  847:    		//log_yml_event(evt);
886:       16:  848:    	    yaml_emitter_emit(emitter, &evt); 	
887:        -:  849:		//emit size as int
888:        -:  850:		  
889:       16:  851:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
890:       16:  852:			yaml_scalar_event_initialize(
891:        -:  853:    		&evt,
892:        -:  854:	    	NULL,
893:        -:  855:			NULL,
894:        -:  856:			(unsigned char *)buf,
895:       16:  857:			strlen(buf),
896:        -:  858:			CONF_T,
897:        -:  859:			CONF_T, 
898:        -:  860:			YAML_PLAIN_SCALAR_STYLE); 	
899:        -:  861:		
900:       16:  862:			yaml_emitter_emit(emitter, &evt);
901:        -:  863:			//log_yml_event(evt); 		
902:        -:  864:			//emit values as map
903:       16:  865:			viter = entry-&gt;e.seq-&gt;vars;
904:        -:  866:    		
905:       16:  867:    		i = 0;
906:      128:  868:			while(i &lt; entry-&gt;e.seq-&gt;size){
907:       96:  869:			    if(viter != NULL) {
908:       96:  870:				   emit_variable(viter, emitter);
909:        -:  871:				}
910:       96:  872:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
911:        -:  873:			}	
912:        -:  874:			
913:       16:  875:			yaml_sequence_end_event_initialize(&evt); 	
914:       16:  876:    		yaml_emitter_emit(emitter, &evt); 
915:        -:  877:    		//log_yml_event(evt);
916:       16:  878:			break;
917:        -:  879:			
918:<font color=red>    #####:  880:		default:break;</font>
919:        -:  881:	}
920:        -:  882:	
921:       50:  883:}
922:        -:  884:
923:function emit called 2 returned 1000locks executed 100%
924:        2:  885:int emit(yaml_emitter_t *emitter, const config_t conf) {
925:        2:  886:    int r = CONF_OK;     
926:        -:  887:   
927:        -:  888:    yaml_event_t evt;
928:        -:  889:    char val[CONF_STR];
929:        2:  890:    memset(val,0,CONF_STR);
930:        -:  891:    //doc start
931:        2:  892:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, CONF_F); 
932:        2:  893:	yaml_emitter_emit(emitter, &evt); 		
933:        -:  894:   // log_yml_event(evt);
934:        -:  895:    
935:        2:  896:    yaml_mapping_start_event_initialize(
936:        -:  897:    	&evt,
937:        -:  898:    	NULL,
938:        -:  899:    	NULL,
939:        -:  900:    	CONF_F,
940:        -:  901:    	YAML_BLOCK_MAPPING_STYLE);
941:        -:  902:    	 	    
942:        2:  903:    yaml_emitter_emit(emitter, &evt);
943:        -:  904:   // log_yml_event(evt);
944:        -:  905:    
945:        2:  906:    entry_map_t config_map = conf-&gt;map;
946:        2:  907:    entry_t iter = *config_map;
947:        2:  908:    int i = 0;
948:       50:  909:    while(i &lt; conf-&gt;size) {
949:       46:  910:        if(iter != NULL){
950:       28:  911:    	    emit_entry(iter, emitter);
951:        -:  912:    	}
952:       46:  913:    	iter = config_map[++i];
953:        -:  914:    }
954:        -:  915:   
955:        -:  916:    //mapping end
956:        2:  917:    yaml_mapping_end_event_initialize(&evt); 	
957:        2:  918:    yaml_emitter_emit(emitter, &evt); 		
958:        -:  919:    //log_yml_event(evt);
959:        -:  920:    
960:        -:  921:    //doc end
961:        2:  922:    yaml_document_end_event_initialize(&evt,CONF_F);
962:        2:  923:    yaml_emitter_emit(emitter, &evt);
963:        -:  924:    //log_yml_event(evt); 		
964:        2:  925:    yaml_event_delete(&evt); 	
965:        2:  926:    return r;
966:        -:  927:}
967:        -:  928:
968:function save_config_yml called 0 returned 00locks executed 0%
969:<font color=red>    #####:  929:int save_config_yml(const char * filename, const config_t conf) {</font>
970:        -:  930:    
971:        -:  931:    yaml_emitter_t emitter;
972:        -:  932:    yaml_event_t event;
973:        -:  933:    
974:        -:  934:    FILE * fcfg;
975:        -:  935:    char path[CONF_STR];
976:<font color=red>    #####:  936:    int r = CONF_OK;</font>
977:        -:  937:    
978:<font color=red>    #####:  938:    memset(path, 0, CONF_STR);</font>
979:<font color=red>    #####:  939:    sprintf(path, "", filename);</font>
980:        -:  940:
981:<font color=red>    #####:  941:    if(!yaml_emitter_initialize(&emitter)){</font>
982:<font color=red>    #####:  942:        return CONF_ERR;    </font>
983:        -:  943:    }
984:<font color=red>    #####:  944:    if ((fcfg = fopen(path, "wb"))) {</font>
985:<font color=red>    #####:  945:         plc_log("Save configuration to  ...", path);</font>
986:        -:  946:         
987:<font color=red>    #####:  947:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
988:<font color=red>    #####:  948:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
989:        -:  949:         
990:<font color=red>    #####:  950:         r = yaml_emitter_emit(&emitter, &event);</font>
991:        -:  951:         
992:<font color=red>    #####:  952:         if(r)</font>
993:<font color=red>    #####:  953:            r = emit(&emitter, conf);</font>
994:<font color=red>    #####:  954:         if(r){</font>
995:<font color=red>    #####:  955:            yaml_stream_end_event_initialize(&event);</font>
996:<font color=red>    #####:  956:            r = yaml_emitter_emit(&emitter, &event);   </font>
997:        -:  957:         }
998:        -:  958:            
999:<font color=red>    #####:  959:         if(r &lt; CONF_OK)</font>
1000:<font color=red>    #####:  960:            plc_log( "Configuration error ");</font>
1001:        -:  961:            
1002:<font color=red>    #####:  962:         fclose(fcfg);</font>
1003:        -:  963:    } else {
1004:<font color=red>    #####:  964:        r = CONF_ERR;</font>
1005:<font color=red>    #####:  965:        plc_log("Could not open file  for write", filename);</font>
1006:        -:  966:    }
1007:<font color=red>    #####:  967:    yaml_emitter_delete(&emitter);</font>
1008:<font color=red>    #####:  968:    return r;</font>
1009:        -:  969:}
1010:        -:  970:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
