<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:#include "plclib.h"
 10:        -:    5:
 11:        -:    6:const char * Config_vars[N_CONFIG_VARIABLES] = {
 12:        -:    7:    "STEP",
 13:        -:    8:    "PIPE",
 14:        -:    9:    "SIGENABLE",
 15:        -:   10:    "PAGELEN",
 16:        -:   11:    "PAGEWIDTH",
 17:        -:   12:    "HW",
 18:        -:   13:    "NT",
 19:        -:   14:    "NS",
 20:        -:   15:    "NR",
 21:        -:   16:    "NM",
 22:        -:   17:    "NDI",
 23:        -:   18:    "NDQ",
 24:        -:   19:    "NAI",
 25:        -:   20:    "NAQ",
 26:        -:   21:    "RESPONSE",
 27:        -:   22:    "USPACE",
 28:        -:   23:    "COMEDI",
 29:        -:   24:    "SIM",
 30:        -:   25:    "IL",
 31:        -:   26:    "LD",
 32:        -:   27:    //sequences
 33:        -:   28:    "AI",
 34:        -:   29:    "AQ",
 35:        -:   30:    "DI",
 36:        -:   31:    "DQ",
 37:        -:   32:    "MVAR",
 38:        -:   33:    "MREG",
 39:        -:   34:    "TIMER",
 40:        -:   35:    "PULSE"
 41:        -:   36:};
 42:        -:   37:
 43:        -:   38:/*
 44:        -:   39:const char * Variable_params[N_VARIABLE_PARAMS] = {
 45:        -:   40:    "INDEX",
 46:        -:   41:    "ID",
 47:        -:   42:    "VALUE",
 48:        -:   43:    "MIN",
 49:        -:   44:    "MAX"
 50:        -:   45:};
 51:        -:   46:*/
 52:function strdup_r called 10 returned 1000locks executed 100%
 53:       10:   47:char * strdup_r(const char * dest, const char * src) {
 54:        -:   48://strdup with realloc
 55:       10:   49:    char * r = (dest == NULL)?(char *)malloc(sizeof(src)):dest;
 56:        -:   50:        
 57:       10:   51:    r = realloc(r, sizeof(src));
 58:       10:   52:    memset(r, 0, sizeof(src));
 59:       10:   53:    sprintf(r, "", src);
 60:        -:   54:    
 61:       10:   55:    return r;
 62:        -:   56:}
 63:        -:   57:
 64:        -:   58:
 65:function yaml_config_error called 0 returned 00locks executed 0%
 66:<font color=red>    #####:   59:static void yaml_config_error(yaml_parser_t parser){</font>
 67:        -:   60:
 68:        -:   61:    //print line
 69:<font color=red>    #####:   62:}</font>
 70:        -:   63:
 71:function yaml_parser_error called 0 returned 00locks executed 0%
 72:<font color=red>    #####:   64:static void yaml_parser_error(yaml_parser_t parser){</font>
 73:        -:   65:
 74:<font color=red>    #####:   66:     switch (parser.error)</font>
 75:        -:   67:     {
 76:        -:   68:        case YAML_MEMORY_ERROR:
 77:<font color=red>    #####:   69:            plc_log( </font>
 78:        -:   70:            "Memory error: Not enough memory for parsing");
 79:<font color=red>    #####:   71:            break;</font>
 80:        -:   72:
 81:        -:   73:        case YAML_READER_ERROR:
 82:<font color=red>    #####:   74:            if (parser.problem_value != -1) {</font>
 83:<font color=red>    #####:   75:                plc_log( </font>
 84:        -:   76:                "Reader error: : #0 at 0", 
 85:        -:   77:                parser.problem,
 86:        -:   78:                parser.problem_value, 
 87:        -:   79:                parser.problem_offset);
 88:        -:   80:            }
 89:        -:   81:            else {
 90:<font color=red>    #####:   82:                plc_log( </font>
 91:        -:   83:                "Reader error:  at 0", 
 92:        -:   84:                parser.problem,
 93:        -:   85:                parser.problem_offset);
 94:        -:   86:            }
 95:<font color=red>    #####:   87:            break;</font>
 96:        -:   88:
 97:        -:   89:        case YAML_SCANNER_ERROR:
 98:<font color=red>    #####:   90:            if (parser.context) {</font>
 99:<font color=red>    #####:   91:                plc_log( </font>
100:        -:   92:                "Scanner error:  at line 0, column 0"
101:        -:   93:                        " at line 0, column 0", 
102:        -:   94:                        parser.context,
103:<font color=red>    #####:   95:                        parser.context_mark.line+1,</font>
104:<font color=red>    #####:   96:                        parser.context_mark.column+1,</font>
105:        -:   97:                        parser.problem, 
106:<font color=red>    #####:   98:                        parser.problem_mark.line+1,</font>
107:<font color=red>    #####:   99:                        parser.problem_mark.column+1);</font>
108:        -:  100:            }
109:        -:  101:            else {
110:<font color=red>    #####:  102:                plc_log( </font>
111:        -:  103:                "Scanner error:  at line 0, column 0",
112:<font color=red>    #####:  104:                        parser.problem, parser.problem_mark.line+1,</font>
113:<font color=red>    #####:  105:                        parser.problem_mark.column+1);</font>
114:        -:  106:            }
115:<font color=red>    #####:  107:            break;</font>
116:        -:  108:
117:        -:  109:        case YAML_PARSER_ERROR:
118:<font color=red>    #####:  110:            if (parser.context) {</font>
119:<font color=red>    #####:  111:                plc_log( </font>
120:        -:  112:                "Parser error:  at line 0, column 0"
121:        -:  113:                        " at line 0, column 0", 
122:        -:  114:                        parser.context,
123:<font color=red>    #####:  115:                        parser.context_mark.line+1,</font>
124:<font color=red>    #####:  116:                        parser.context_mark.column+1,</font>
125:        -:  117:                        parser.problem, 
126:<font color=red>    #####:  118:                        parser.problem_mark.line+1,</font>
127:<font color=red>    #####:  119:                        parser.problem_mark.column+1);</font>
128:        -:  120:            }
129:        -:  121:            else {
130:<font color=red>    #####:  122:                plc_log( </font>
131:        -:  123:                "Parser error:  at line 0, column 0",
132:        -:  124:                        parser.problem, 
133:<font color=red>    #####:  125:                        parser.problem_mark.line+1,</font>
134:<font color=red>    #####:  126:                        parser.problem_mark.column+1);</font>
135:        -:  127:            }
136:<font color=red>    #####:  128:            break;</font>
137:        -:  129:
138:        -:  130:        default:
139:        -:  131:            /* Couldn't happen. */
140:<font color=red>    #####:  132:            plc_log( </font>
141:        -:  133:            "Internal error\n");
142:<font color=red>    #####:  134:            break;</font>
143:        -:  135:    }
144:<font color=red>    #####:  136:}</font>
145:        -:  137:
146:function new_entry_int called 72 returned 1000locks executed 100%
147:       72:  138:static entry_t new_entry_int(int i, char * name) {
148:        -:  139:
149:       72:  140:	entry_t r = (entry_t)malloc(sizeof(struct entry));
150:       72:  141:	r-&gt;type_tag = ENTRY_INT;
151:       72:  142:	r-&gt;name = name;
152:       72:  143:	r-&gt;e.scalar_int = i;
153:        -:  144:
154:       72:  145:	return r;
155:        -:  146:}
156:        -:  147:
157:function new_entry_str called 32 returned 1000locks executed 100%
158:       32:  148:static entry_t new_entry_str(char * str, char * name) {
159:        -:  149:
160:       32:  150:	entry_t r = (entry_t)malloc(sizeof(struct entry));
161:       32:  151:	r-&gt;type_tag = ENTRY_STR;
162:       32:  152:	r-&gt;name = name;
163:       32:  153:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
164:       32:  154:    sprintf(r-&gt;e.scalar_str, "", str);
165:       32:  155:	return r;
166:        -:  156:}
167:        -:  157:
168:function new_entry_map called 32 returned 1000locks executed 100%
169:       32:  158:static entry_t new_entry_map(config_t map, char * name) {
170:        -:  159:	
171:       32:  160:	entry_t r = (entry_t)malloc(sizeof(struct entry));
172:       32:  161:	r-&gt;type_tag = ENTRY_MAP;
173:       32:  162:	r-&gt;name = name;
174:       32:  163:	r-&gt;e.conf = map;
175:        -:  164:
176:       32:  165:	return r;
177:        -:  166:}
178:        -:  167:
179:function new_entry_seq called 64 returned 1000locks executed 100%
180:       64:  168:static entry_t new_entry_seq(sequence_t seq, char * name) {
181:        -:  169:	
182:       64:  170:	entry_t r = (entry_t)malloc(sizeof(struct entry));
183:       64:  171:	r-&gt;type_tag = ENTRY_SEQ;
184:       64:  172:	r-&gt;name = name;
185:       64:  173:	r-&gt;e.seq = seq;
186:        -:  174:
187:       64:  175:	return r;
188:        -:  176:}
189:        -:  177:
190:function new_entry_null called 0 returned 00locks executed 0%
191:<font color=red>    #####:  178:static entry_t new_entry_null() {</font>
192:<font color=red>    #####:  179:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
193:<font color=red>    #####:  180:	r-&gt;type_tag = ENTRY_NONE;</font>
194:<font color=red>    #####:  181:	r-&gt;name = "";</font>
195:<font color=red>    #####:  182:	r-&gt;e.scalar_int = 0;</font>
196:        -:  183:
197:<font color=red>    #####:  184:	return r;</font>
198:        -:  185:}
199:        -:  186:
200:function update_entry called 200 returned 1000locks executed 80%
201:      200:  187:static config_t update_entry(
202:        -:  188:    unsigned int key, 
203:        -:  189:    const entry_t item,
204:        -:  190:    const config_t conf) {
205:        -:  191:    
206:      400:  192:    if( conf == NULL ||
207:      200:  193:        key &gt;= conf-&gt;size) {
208:        -:  194:    
209:<font color=red>    #####:  195:        return conf;</font>
210:        -:  196:    } else {
211:        -:  197:    
212:      200:  198:        config_t r = conf;
213:      200:  199:        r-&gt;map[key] = item;
214:        -:  200:        
215:      200:  201:        return r;
216:        -:  202:    }
217:        -:  203:}
218:        -:  204:
219:function get_entry called 90 returned 1000locks executed 100%
220:       90:  205:entry_t get_entry(int key, const config_t conf){
221:        -:  206:
222:       90:  207:    if(conf == NULL || 
223:       80:  208:        key &lt; 0 || 
224:       80:  209:        key &gt; conf-&gt;size) {
225:        -:  210:        
226:       10:  211:        return NULL;    
227:        -:  212:    }
228:        -:  213:    
229:       80:  214:    return conf-&gt;map[key];
230:        -:  215:}
231:        -:  216:
232:        -:  217:/*
233:        -:  218:int get_var_key(const char * name){
234:        -:  219:    for(int i = 0; i &lt; N_VARIABLE_PARAMS; i++) {
235:        -:  220:        if(!strcmp(name, Variable_params[i])) {
236:        -:  221:            
237:        -:  222:            return i;
238:        -:  223:        }
239:        -:  224:    }
240:        -:  225:    
241:        -:  226:    return PLC_ERR;
242:        -:  227:}
243:        -:  228:*/
244:        -:  229://TODO: in a c++ impl. this would be a hashmap
245:function new_param called 8 returned 1000locks executed 100%
246:        8:  230:param_t new_param(const char * key, 
247:        -:  231:                     const char * val){
248:        -:  232:    
249:        8:  233:        param_t n = (param_t)malloc(sizeof(struct param));
250:        8:  234:        n-&gt;key = strdup(key);
251:        8:  235:        n-&gt;value = strdup(val);
252:        8:  236:        n-&gt;next = NULL;
253:        -:  237:        
254:        8:  238:        return n;        
255:        -:  239:}
256:        -:  240:
257:function get_param called 8 returned 1000locks executed 100%
258:        8:  241:param_t get_param(const char * key, const param_t params){
259:        8:  242:    param_t it = params;
260:       26:  243:    while(it && key){
261:       14:  244:        if(!strcmp(it-&gt;key, key)){
262:        -:  245:        
263:        4:  246:            return it;
264:        -:  247:        }
265:       10:  248:        it = it-&gt;next;            
266:        -:  249:    }
267:        -:  250:    
268:        4:  251:    return NULL;
269:        -:  252:}
270:        -:  253:
271:function get_param_val called 4 returned 1000locks executed 83%
272:        4:  254:char * get_param_val(const char * key, const param_t params){
273:        4:  255:    param_t it = get_param(key, params);
274:        -:  256:    
275:        4:  257:    return it?it-&gt;value:NULL;
276:        -:  258:}
277:        -:  259:
278:function append_param called 4 returned 1000locks executed 88%
279:        4:  260:param_t append_param(const param_t params, 
280:        -:  261:                     const char * key, 
281:        -:  262:                     const char * val){
282:        -:  263:        
283:        4:  264:    if(params == NULL){
284:        -:  265:        
285:<font color=red>    #####:  266:        return new_param(key, val);</font>
286:        -:  267:    } else {
287:        4:  268:        param_t ret = params;
288:        4:  269:        param_t it = params;
289:       10:  270:        while(it-&gt;next){
290:        2:  271:            it = it-&gt;next;
291:        -:  272:        }
292:        4:  273:        it-&gt;next = new_param(key, val);
293:        -:  274:                
294:        4:  275:        return ret;    
295:        -:  276:    }
296:        -:  277:}
297:        -:  278:
298:function update_param called 8 returned 1000locks executed 78%
299:        8:  279:param_t update_param(const param_t params, 
300:        -:  280:                     const char * key, 
301:        -:  281:                     const char * val){
302:        -:  282:        
303:        8:  283:    if(params == NULL){
304:        -:  284:        
305:        4:  285:        return new_param(key, val);         
306:        -:  286:    } else {
307:        4:  287:        param_t ret = params;
308:        4:  288:        param_t par = get_param(key, params);
309:        4:  289:        if(par){
310:<font color=red>    #####:  290:            par-&gt;value = strdup_r(par-&gt;value, val);</font>
311:        -:  291:        } else {
312:        -:  292:        //FIXME: ..and this is why we need a hashmap.
313:        4:  293:            ret = append_param(ret, key, val);  
314:        -:  294:        } 
315:        4:  295:        return ret;    
316:        -:  296:    }
317:        -:  297:}
318:        -:  298:
319:function get_key called 38 returned 1000locks executed 100%
320:       38:  299:int get_key(const char * name, const config_t where) {
321:       38:  300:     if(where != NULL){
322:        -:  301:    
323:      490:  302:        for(int i = 0; i &lt; where-&gt;size; i++) {
324:      710:  303:            if( where-&gt;map[i] != NULL &&
325:      230:  304:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
326:        -:  305:                
327:       28:  306:                return i;
328:        -:  307:            }
329:        -:  308:        }
330:        -:  309:    }
331:        -:  310:    
332:       10:  311:    return PLC_ERR;  
333:        -:  312:}
334:        -:  313:
335:function new_config called 40 returned 1000locks executed 100%
336:       40:  314:config_t new_config(int size) {
337:       40:  315:    config_t r = (config_t)malloc(sizeof(struct config));
338:       40:  316:	memset(r, 0, sizeof(struct config));
339:       40:  317:	r-&gt;size = size;
340:       40:  318:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
341:       40:  319:    memset(r-&gt;map, 0, size*sizeof(struct entry));
342:        -:  320:    
343:       40:  321:	return r;
344:        -:  322:}
345:        -:  323:
346:function new_sequence called 64 returned 1000locks executed 100%
347:       64:  324:sequence_t new_sequence(int size) {
348:       64:  325:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
349:       64:  326:	memset(r, 0, sizeof(struct sequence));
350:       64:  327:	r-&gt;size = size;
351:       64:  328:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
352:       64:  329:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
353:        -:  330:	
354:       64:  331:	return r;
355:        -:  332:}
356:        -:  333:
357:function init_config called 8 returned 1000locks executed 100%
358:        8:  334:config_t init_config(){
359:        -:  335: //TODO: in a c++ implementation this all can be done automatically 
360:        -:  336: //using a hashmap
361:        8:  337:    config_t conf = new_config(N_CONFIG_VARIABLES);
362:        -:  338:   
363:        8:  339:    config_t uspace = new_config(N_USPACE_VARS);
364:        -:  340:        
365:        8:  341:    uspace = update_entry(
366:        -:  342:        USPACE_BASE,
367:        -:  343:	    new_entry_int(50176, "USPACE_BASE"),
368:        -:  344:	    uspace);
369:        -:  345:	
370:        8:  346:	uspace = update_entry(
371:        -:  347:	    USPACE_WR, 
372:        -:  348:	    new_entry_int(0, "USPACE_WR"),
373:        -:  349:	    uspace);
374:        -:  350:	    
375:        8:  351:	uspace = update_entry(
376:        -:  352:	    USPACE_RD, 
377:        -:  353:	    new_entry_int(8, "USPACE_RD"),
378:        -:  354:	    uspace);
379:        -:  355:	
380:        8:  356:	config_t subdev = new_config(N_SUBDEV_VARS);
381:        -:  357:	
382:        8:  358:    subdev = update_entry(
383:        -:  359:        SUBDEV_IN,
384:        -:  360:	    new_entry_int(0, "SUBDEV_IN"),
385:        -:  361:	    subdev);
386:        -:  362:	    
387:        8:  363:	subdev = update_entry(
388:        -:  364:	    SUBDEV_OUT,
389:        -:  365:	    new_entry_int(1, "SUBDEV_OUT"),
390:        -:  366:	    subdev);
391:        -:  367:	    
392:        8:  368:    subdev = update_entry(
393:        -:  369:        SUBDEV_ADC, 
394:        -:  370:	    new_entry_int(2, "SUBDEV_ADC"),
395:        -:  371:	    subdev);
396:        -:  372:	    
397:        8:  373:	subdev = update_entry(
398:        -:  374:	    SUBDEV_DAC, 
399:        -:  375:	    new_entry_int(3, "SUBDEV_DAC"),
400:        -:  376:	    subdev);
401:        -:  377:	
402:        8:  378:	config_t comedi = new_config(N_COMEDI_VARS);
403:        -:  379:	
404:        8:  380:	comedi = update_entry(
405:        -:  381:	    COMEDI_FILE,
406:        -:  382:	    new_entry_int(0, "COMEDI_FILE"),
407:        -:  383:	    comedi);
408:        -:  384:	    
409:        8:  385:	comedi = update_entry(
410:        -:  386:	    COMEDI_SUBDEV, 
411:        -:  387:	    new_entry_map(subdev, "COMEDI_SUBDEV"),
412:        -:  388:	    comedi);
413:        -:  389:    
414:        8:  390:    config_t sim = new_config(N_SIM_VARS);
415:        -:  391:    
416:        8:  392:    sim = update_entry(
417:        -:  393:        SIM_INPUT,
418:        -:  394:        new_entry_str("sim.in", "SIM_INPUT"), 
419:        -:  395:        sim);
420:        -:  396:        
421:        8:  397:    sim = update_entry(
422:        -:  398:        SIM_OUTPUT,
423:        -:  399:        new_entry_str("sim.out", "SIM_OUTPUT"),
424:        -:  400:        sim);    
425:        -:  401:
426:        8:  402:    conf = update_entry(
427:        -:  403:        CONFIG_STEP,
428:        -:  404:        new_entry_int(1, "STEP"),
429:        -:  405:        conf);
430:        -:  406:    
431:        8:  407:    conf = update_entry(
432:        -:  408:        CONFIG_PIPE,
433:        -:  409:        new_entry_str("plcpipe", "PIPE"),
434:        -:  410:        conf);
435:        -:  411:    
436:        8:  412:    conf = update_entry(
437:        -:  413:        CONFIG_HW,
438:        -:  414:        new_entry_str("STDI/O", "HW"),
439:        -:  415:        conf);
440:        -:  416:        
441:        8:  417:    conf = update_entry(
442:        -:  418:        CONFIG_USPACE,
443:        -:  419:        new_entry_map(uspace, "USPACE"),
444:        -:  420:        conf);
445:        -:  421:    
446:        8:  422:    conf = update_entry(
447:        -:  423:        CONFIG_COMEDI,
448:        -:  424:        new_entry_map(comedi, "COMEDI"),
449:        -:  425:        conf);
450:        -:  426:    
451:        8:  427:    conf = update_entry(
452:        -:  428:        CONFIG_SIM,
453:        -:  429:        new_entry_map(sim, "SIM"),
454:        -:  430:        conf);
455:        -:  431:   /*******************************************/
456:        -:  432:   
457:        8:  433:    conf = update_entry(
458:        -:  434:        CONFIG_TIMER,
459:        -:  435:        new_entry_seq(new_sequence(4), "TIMERS"),
460:        -:  436:        conf);
461:        -:  437:    
462:        8:  438:    conf = update_entry(
463:        -:  439:        CONFIG_PULSE,
464:        -:  440:        new_entry_seq(new_sequence(4), "PULSES"),
465:        -:  441:        conf);
466:        -:  442:        
467:        8:  443:    conf = update_entry(
468:        -:  444:        CONFIG_MREG,
469:        -:  445:        new_entry_seq(new_sequence(4), "MREG"),
470:        -:  446:        conf);
471:        -:  447:        
472:        8:  448:    conf = update_entry(
473:        -:  449:        CONFIG_MVAR,
474:        -:  450:        new_entry_seq(new_sequence(4), "MVAR"),
475:        -:  451:        conf);
476:        -:  452:    
477:        8:  453:    conf = update_entry(
478:        -:  454:        CONFIG_DI,
479:        -:  455:        new_entry_seq(new_sequence(8), "DI"),
480:        -:  456:        conf);
481:        -:  457: 
482:        8:  458:    conf = update_entry(
483:        -:  459:        CONFIG_DQ,
484:        -:  460:        new_entry_seq(new_sequence(8), "DQ"),
485:        -:  461:        conf);
486:        -:  462:    
487:        8:  463:    conf = update_entry(
488:        -:  464:        CONFIG_AI,
489:        -:  465:        new_entry_seq(new_sequence(8), "AI"),
490:        -:  466:        conf);
491:        -:  467:    
492:        8:  468:    conf = update_entry(
493:        -:  469:        CONFIG_AQ,
494:        -:  470:        new_entry_seq(new_sequence(8), "AQ"),
495:        -:  471:        conf);
496:        -:  472:
497:        8:  473:    return conf;
498:        -:  474:}
499:        -:  475:
500:function clear_config called 4 returned 1000locks executed 100%
501:        4:  476:config_t clear_config(config_t c){
502:        -:  477:
503:        4:  478:    return (config_t)NULL;
504:        -:  479:}
505:        -:  480:
506:function log_yml_event called 0 returned 00locks executed 0%
507:<font color=red>    #####:  481:static int log_yml_event(yaml_event_t event){</font>
508:        -:  482:
509:<font color=red>    #####:  483:    switch(event.type){ </font>
510:        -:  484:    
511:        -:  485:        case YAML_NO_EVENT: 
512:<font color=red>    #####:  486:        	plc_log("No event!"); </font>
513:<font color=red>    #####:  487:            break;</font>
514:        -:  488:    /* Stream start/end */
515:        -:  489:        case YAML_STREAM_START_EVENT: 
516:<font color=red>    #####:  490:        	plc_log("STREAM START"); </font>
517:<font color=red>    #####:  491:            break;</font>
518:        -:  492:        case YAML_STREAM_END_EVENT: 
519:<font color=red>    #####:  493:        	plc_log("STREAM END");   </font>
520:<font color=red>    #####:  494:            break;</font>
521:        -:  495:    /* Block delimeters */
522:        -:  496:        case YAML_DOCUMENT_START_EVENT: 
523:<font color=red>    #####:  497:        	plc_log("Start Document"); </font>
524:<font color=red>    #####:  498:            break;</font>
525:        -:  499:        case YAML_DOCUMENT_END_EVENT: 
526:<font color=red>    #####:  500:        	plc_log("End Document");   </font>
527:<font color=red>    #####:  501:            break;</font>
528:        -:  502:        case YAML_SEQUENCE_START_EVENT: 
529:<font color=red>    #####:  503:        	plc_log("Start Sequence"); </font>
530:<font color=red>    #####:  504:            break;</font>
531:        -:  505:        case YAML_SEQUENCE_END_EVENT: 
532:<font color=red>    #####:  506:        	plc_log("End Sequence");</font>
533:<font color=red>    #####:  507:            break;</font>
534:        -:  508:        case YAML_MAPPING_START_EVENT: 
535:<font color=red>    #####:  509:        	plc_log("Start Mapping");         </font>
536:<font color=red>    #####:  510:            break;</font>
537:        -:  511:        case YAML_MAPPING_END_EVENT: 
538:<font color=red>    #####:  512:        	plc_log("End Mapping");      </font>
539:<font color=red>    #####:  513:            break;</font>
540:        -:  514:    /* Data */
541:        -:  515:        case YAML_ALIAS_EVENT:  
542:<font color=red>    #####:  516:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
543:<font color=red>    #####:  517:            break;</font>
544:        -:  518:        case YAML_SCALAR_EVENT: 
545:<font color=red>    #####:  519:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
546:<font color=red>    #####:  520:        	break;</font>
547:        -:  521:        default:
548:<font color=red>    #####:  522:            plc_log("default?");</font>
549:        -:  523:    }
550:<font color=red>    #####:  524:    return PLC_OK;</font>
551:        -:  525:}
552:        -:  526:
553:function store_value called 26 returned 1000locks executed 85%
554:       26:  527:config_t store_value(BYTE key, const char * value, config_t config){
555:        -:  528:
556:        -:  529:    entry_t e; 
557:       26:  530:    if( config == NULL) {
558:        -:  531:    
559:<font color=red>    #####:  532:        return NULL;</font>
560:        -:  533:    }
561:        -:  534:    
562:       26:  535:    config_t conf = config;
563:       26:  536:    e = get_entry(key, conf);
564:        -:  537:    
565:       26:  538:    if(e == NULL) {
566:        2:  539:        conf-&gt;err = PLC_ERR;
567:        -:  540:        
568:        2:  541:        return conf;
569:        -:  542:    }
570:        -:  543:    
571:       24:  544:    switch(e-&gt;type_tag){
572:        -:  545:         case ENTRY_INT:
573:       16:  546:            e-&gt;e.scalar_int = atoi(value);
574:       16:  547:            break;
575:        -:  548:         
576:        -:  549:         case ENTRY_STR:
577:        -:  550:         
578:        8:  551:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
579:        8:  552:            break;
580:        -:  553:            
581:<font color=red>    #####:  554:         default: return PLC_ERR;</font>
582:        -:  555:    }        
583:       24:  556:    conf-&gt;map[key] = e;
584:        -:  557:       
585:       24:  558:    return conf;
586:        -:  559:}
587:        -:  560:
588:function store_seq_value called 14 returned 1000locks executed 100%
589:       14:  561:config_t store_seq_value(BYTE seq,
590:        -:  562:                    BYTE idx,  
591:        -:  563:                    const char * key,
592:        -:  564:                    const char * value, 
593:        -:  565:                    config_t config){
594:        -:  566:                    
595:       14:  567:    config_t conf = config;                
596:       14:  568:    entry_t s = conf-&gt;map[seq];
597:        -:  569:    
598:       14:  570:    if( s == NULL ||
599:       12:  571:        key == NULL || 
600:       10:  572:        value == NULL ||
601:       20:  573:        s-&gt;type_tag != ENTRY_SEQ ||
602:       10:  574:        idx &gt;= s-&gt;e.seq-&gt;size) {
603:        -:  575:        
604:        4:  576:        conf-&gt;err = PLC_ERR;
605:        -:  577:        
606:        4:  578:        return conf;
607:        -:  579:    }            
608:        -:  580:    
609:       30:  581:    variable_t var = &(conf-&gt;map[seq]
610:       10:  582:                            -&gt;e.seq
611:       20:  583:                            -&gt;vars[idx]);
612:        -:  584:    
613:       10:  585:    conf-&gt;map[seq]
614:       10:  586:        -&gt;e.seq
615:       10:  587:        -&gt;vars[idx].index = idx;
616:        -:  588:    
617:       10:  589:    if(!strcmp(key, "ID")){
618:        2:  590:         conf-&gt;map[seq]
619:        2:  591:             -&gt;e.seq
620:        2:  592:             -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
621:        -:  593:    } else {
622:        -:  594:        
623:        8:  595:        conf-&gt;map[seq]
624:        8:  596:            -&gt;e.seq
625:       16:  597:            -&gt;vars[idx].params = update_param(
626:        8:  598:                conf-&gt;map[seq]
627:        8:  599:                    -&gt;e.seq
628:        8:  600:                    -&gt;vars[idx].params,
629:        -:  601:                key,
630:        -:  602:                value);    
631:        -:  603:    }   
632:        -:  604:        
633:       10:  605:    return conf;                       
634:        -:  606:}
635:        -:  607:
636:function process_seq_element called 10 returned 1000locks executed 100%
637:       10:  608:static config_t process_seq_element(
638:        -:  609:                   yaml_event_t event,
639:        -:  610:                   int sequence, 
640:        -:  611:                   const char * key,
641:        -:  612:                   int * idx,
642:        -:  613:                   config_t config){
643:        -:  614:    
644:       10:  615:    config_t conf = config;
645:       10:  616:    char * val = (char *)event.data.scalar.value;
646:        -:  617:                    
647:        -:  618:          
648:       10:  619:    if(!strcmp(key, "INDEX")){
649:        -:  620:                             
650:        2:  621:            *idx = atoi(val);
651:        -:  622:    } else {  
652:        -:  623:                             
653:        8:  624:            conf = store_seq_value(sequence, 
654:        8:  625:                                      *idx, 
655:        -:  626:                                      key, 
656:        -:  627:                                      val, 
657:        -:  628:                                      conf);       
658:        -:  629:    }                      
659:        -:  630:      
660:       10:  631:    return conf;                       
661:        -:  632:}
662:        -:  633:
663:function process_scalar called 16 returned 1000locks executed 100%
664:       16:  634:static config_t process_scalar(
665:        -:  635:                   yaml_event_t event,
666:        -:  636:                   const char * key,
667:        -:  637:                   config_t config){
668:        -:  638:    
669:       16:  639:    config_t conf = config;
670:       16:  640:    char * val = (char *)event.data.scalar.value;
671:        -:  641:               
672:       16:  642:    conf = store_value(
673:       16:  643:                    get_key(key, conf), 
674:        -:  644:                    val, 
675:        -:  645:                    conf);
676:        -:  646:                 
677:       16:  647:    return conf;                       
678:        -:  648:}
679:        -:  649:
680:function process_mapping called 16 returned 1000locks executed 100%
681:       16:  650:static config_t process_mapping(
682:        -:  651:                    const char * key,
683:        -:  652:                    int seq,
684:        -:  653:                    yaml_parser_t *parser,
685:        -:  654:                    config_t config){
686:        -:  655:    
687:       16:  656:    config_t conf = config;                
688:       16:  657:    int k = get_key(key, conf);
689:       16:  658:    entry_t c = get_entry(k, conf);
690:        -:  659:    
691:       24:  660:    if( c != NULL &&
692:        8:  661:        c-&gt;type_tag == ENTRY_MAP) {
693:        -:  662:                    
694:        6:  663:        c-&gt;e.conf = process(
695:        -:  664:                        seq, 
696:        -:  665:                        parser, 
697:        -:  666:                        c-&gt;e.conf);        
698:        6:  667:        conf-&gt;map[k] = c;
699:        -:  668:    } else {
700:        -:  669:                    
701:       10:  670:        conf = process(
702:        -:  671:            seq, 
703:        -:  672:            parser, 
704:        -:  673:            conf);
705:        -:  674:    }
706:        -:  675:    
707:       16:  676:    return conf;    
708:        -:  677:} 
709:        -:  678:
710:function process called 30 returned 1000locks executed 94%
711:       30:  679:config_t process(int sequence, 
712:        -:  680:            yaml_parser_t *parser, 
713:        -:  681:            config_t configuration){
714:        -:  682:             
715:       30:  683:    config_t config = configuration;
716:       30:  684:    BYTE storage = STORE_KEY;   
717:       30:  685:    int done = FALSE;
718:        -:  686:    char key[MAXSTR];
719:       30:  687:    int idx = PLC_ERR;
720:        -:  688:    yaml_event_t event;
721:       30:  689:    memset(&event, 0, sizeof(event));
722:       30:  690:    memset(key, 0, MAXSTR);
723:       30:  691:    if(config == NULL) {
724:        -:  692:     
725:        2:  693:        return NULL;
726:        -:  694:     }
727:        -:  695:     
728:       28:  696:     if(parser == NULL) {
729:        2:  697:        config-&gt;err = PLC_ERR;
730:        -:  698:     
731:        2:  699:        return config;
732:        -:  700:     }
733:        -:  701://     || parser-&gt;context == NULL 
734:        -:  702:           
735:      182:  703:     while(done == FALSE){
736:        -:  704:     
737:      130:  705:        if (!yaml_parser_parse(parser, &event)){   
738:<font color=red>    #####:  706:                yaml_parser_error(*parser);</font>
739:<font color=red>    #####:  707:                config-&gt;err = PLC_ERR;</font>
740:        -:  708:        } else {
741:        -:  709:   
742:      130:  710:            switch(event.type){
743:        -:  711:                case YAML_SCALAR_EVENT: 
744:        -:  712://swap storage to process val after key and vice versa 
745:       60:  713:                    if(storage == STORE_KEY) {
746:       34:  714:                        memset(key, 0, MAXSTR);
747:       34:  715:                        sprintf(key, "", 
748:       34:  716:                            (char *)event.data.scalar.value);
749:        -:  717:                        
750:       34:  718:                        storage = STORE_VAL;
751:        -:  719:                    } else {
752:       26:  720:                        if(sequence &gt; PLC_ERR) {
753:        -:  721:                    
754:       10:  722:                            config = process_seq_element(
755:        -:  723:                                    event,
756:        -:  724:                                    sequence,
757:        -:  725:                                    key,
758:        -:  726:                                    &idx,
759:        -:  727:                                    config);
760:        -:  728:                        } else {
761:        -:  729:                            
762:       16:  730:                            config = process_scalar(
763:        -:  731:                                    event,
764:        -:  732:                                    key,
765:        -:  733:                                    config);
766:        -:  734:                        }
767:       26:  735:                        storage = STORE_KEY;            
768:        -:  736:                    }
769:       60:  737:                    break;
770:        -:  738:                
771:        -:  739:                case YAML_SEQUENCE_START_EVENT:
772:        -:  740:
773:        2:  741:                    sequence = get_key(key, config);
774:        2:  742:                    break;
775:        -:  743:                
776:        -:  744:                case YAML_SEQUENCE_END_EVENT:
777:        -:  745:
778:        2:  746:                    sequence = PLC_ERR;
779:        2:  747:                    break;
780:        -:  748:                
781:        -:  749:                case YAML_MAPPING_START_EVENT:
782:        -:  750:                
783:       16:  751:                    config = process_mapping(
784:        -:  752:                                key,
785:        -:  753:                                sequence,
786:        -:  754:                                parser,
787:        -:  755:                                config); 
788:       16:  756:                    storage = STORE_KEY;            
789:       16:  757:                    break;
790:        -:  758:                    
791:        -:  759:                case YAML_MAPPING_END_EVENT:
792:        -:  760:                case YAML_STREAM_END_EVENT:     
793:        -:  761:                    
794:       24:  762:                    done = TRUE;
795:       24:  763:                    break;
796:        -:  764:                    
797:        -:  765:                case YAML_NO_EVENT:
798:        2:  766:                    config-&gt;err = PLC_ERR;
799:        2:  767:                    break;    
800:        -:  768:                    
801:       24:  769:                default: break;    
802:        -:  770:            }
803:        -:  771:         }
804:      130:  772:         if(config-&gt;err &lt; PLC_OK) {
805:        2:  773:             done = TRUE;
806:        -:  774:             //log_yml_event(event);
807:        -:  775:         }                                              
808:      130:  776:         yaml_event_delete(&event);   
809:        -:  777:     }
810:        -:  778:     
811:       26:  779:     return config;
812:        -:  780:}
813:        -:  781:             
814:function load_config_yml called 0 returned 00locks executed 0%
815:<font color=red>    #####:  782:config_t load_config_yml(const char * filename, config_t conf) {</font>
816:        -:  783:    yaml_parser_t parser;
817:        -:  784:    
818:        -:  785:    FILE * fcfg;
819:        -:  786:    char path[MAXSTR];
820:        -:  787:
821:<font color=red>    #####:  788:    memset(path, 0, MAXSTR);</font>
822:<font color=red>    #####:  789:    sprintf(path, "", filename);</font>
823:        -:  790:    
824:<font color=red>    #####:  791:    memset(&parser, 0, sizeof(parser));</font>
825:        -:  792:    
826:<font color=red>    #####:  793:    config_t r = conf;</font>
827:        -:  794:    
828:<font color=red>    #####:  795:    if (!yaml_parser_initialize(&parser)) {</font>
829:        -:  796:    
830:<font color=red>    #####:  797:        yaml_parser_error(parser);    </font>
831:        -:  798:    }
832:<font color=red>    #####:  799:    if ((fcfg = fopen(path, "r"))) {</font>
833:<font color=red>    #####:  800:        plc_log("Looking for configuration from  ...", path);</font>
834:<font color=red>    #####:  801:        yaml_parser_set_input_file(&parser, fcfg);</font>
835:<font color=red>    #####:  802:        r = process(PLC_ERR, &parser, conf);</font>
836:<font color=red>    #####:  803:        if(r-&gt;err &lt; PLC_OK)</font>
837:<font color=red>    #####:  804:            plc_log( "Configuration error ");</font>
838:<font color=red>    #####:  805:        fclose(fcfg);</font>
839:        -:  806:    } else {
840:<font color=red>    #####:  807:        r-&gt;err = PLC_ERR;</font>
841:<font color=red>    #####:  808:        plc_log("Could not open file ", filename);</font>
842:        -:  809:    }
843:<font color=red>    #####:  810:    yaml_parser_delete(&parser);</font>
844:<font color=red>    #####:  811:    return r;</font>
845:        -:  812:}
846:        -:  813:
847:function emit_variable called 96 returned 1000locks executed 9%
848:       96:  814:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
849:        -:  815:    yaml_event_t evt;
850:       96:  816:    if(var-&gt;name != NULL &&
851:<font color=red>    #####:  817:        var-&gt;name[0]) {</font>
852:        -:  818:       
853:        -:  819:        char idx[4];
854:<font color=red>    #####:  820:        memset(idx, 0, 4);</font>
855:        -:  821:    
856:<font color=red>    #####:  822:        yaml_mapping_start_event_initialize(</font>
857:        -:  823:    			        &evt,
858:        -:  824:    			        NULL,
859:        -:  825:    			        NULL,
860:        -:  826:    			        FALSE,
861:        -:  827:    			        YAML_BLOCK_MAPPING_STYLE);
862:        -:  828:    	 	    
863:<font color=red>    #####:  829:        yaml_emitter_emit(emitter, &evt);</font>
864:        -:  830:    		//log_yml_event(evt);
865:        -:  831:    		            
866:<font color=red>    #####:  832:        yaml_scalar_event_initialize(</font>
867:        -:  833:                        	&evt,
868:        -:  834:                    	    NULL,
869:        -:  835:                    		NULL,
870:        -:  836:                    		"INDEX",
871:        -:  837:                    		5,
872:        -:  838:                    		TRUE,
873:        -:  839:                    		TRUE, 
874:        -:  840:                    		YAML_PLAIN_SCALAR_STYLE); 
875:<font color=red>    #####:  841:        yaml_emitter_emit(emitter, &evt);</font>
876:        -:  842:                    		
877:<font color=red>    #####:  843:        sprintf(idx, "0", var-&gt;index);		</font>
878:<font color=red>    #####:  844:        yaml_scalar_event_initialize(</font>
879:        -:  845:                        	&evt,
880:        -:  846:                    	    NULL,
881:        -:  847:                    		NULL,
882:        -:  848:                    		(unsigned char *)idx,
883:<font color=red>    #####:  849:                    		strlen(idx),</font>
884:        -:  850:                    		TRUE,
885:        -:  851:                    		TRUE, 
886:        -:  852:                    		YAML_PLAIN_SCALAR_STYLE); 	
887:<font color=red>    #####:  853:        yaml_emitter_emit(emitter, &evt);</font>
888:        -:  854:    		            
889:        -:  855:   
890:<font color=red>    #####:  856:        yaml_scalar_event_initialize(</font>
891:        -:  857:                        	&evt,
892:        -:  858:                    	    NULL,
893:        -:  859:                    		NULL,
894:        -:  860:                    		"ID",
895:        -:  861:                    		2,
896:        -:  862:                    		TRUE,
897:        -:  863:                    		TRUE, 
898:        -:  864:                    		YAML_PLAIN_SCALAR_STYLE); 
899:<font color=red>    #####:  865:        yaml_emitter_emit(emitter, &evt);</font>
900:        -:  866:                    			
901:<font color=red>    #####:  867:        yaml_scalar_event_initialize(</font>
902:        -:  868:                        	&evt,
903:        -:  869:                    	    NULL,
904:        -:  870:                    		NULL,
905:<font color=red>    #####:  871:                    		(unsigned char *)var-&gt;name,</font>
906:<font color=red>    #####:  872:                    		strlen(var-&gt;name),</font>
907:        -:  873:                    		TRUE,
908:        -:  874:                    		TRUE, 
909:        -:  875:                    		YAML_PLAIN_SCALAR_STYLE); 	
910:<font color=red>    #####:  876:        yaml_emitter_emit(emitter, &evt);</font>
911:        -:  877:       
912:<font color=red>    #####:  878:        param_t it = var-&gt;params;</font>
913:<font color=red>    #####:  879:        while(it){</font>
914:<font color=red>    #####:  880:            yaml_scalar_event_initialize(</font>
915:        -:  881:                        	&evt,
916:        -:  882:                    	    NULL,
917:        -:  883:                    		NULL,
918:<font color=red>    #####:  884:                    		(unsigned char *)it-&gt;key,</font>
919:<font color=red>    #####:  885:                    		strlen(it-&gt;key),</font>
920:        -:  886:                    		TRUE,
921:        -:  887:                    		TRUE, 
922:        -:  888:                    		YAML_PLAIN_SCALAR_STYLE); 
923:<font color=red>    #####:  889:            yaml_emitter_emit(emitter, &evt);</font>
924:        -:  890:                    			
925:<font color=red>    #####:  891:            yaml_scalar_event_initialize(</font>
926:        -:  892:                        	&evt,
927:        -:  893:                    	    NULL,
928:        -:  894:                    		NULL,
929:<font color=red>    #####:  895:                    		(unsigned char *)it-&gt;value,</font>
930:<font color=red>    #####:  896:                    		strlen(it-&gt;value),</font>
931:        -:  897:                    		TRUE,
932:        -:  898:                    		TRUE, 
933:        -:  899:                    		YAML_PLAIN_SCALAR_STYLE); 	
934:<font color=red>    #####:  900:            yaml_emitter_emit(emitter, &evt);</font>
935:<font color=red>    #####:  901:            it = it-&gt;next; </font>
936:        -:  902:        }    
937:        -:  903:       
938:        -:  904:/*
939:        -:  905:       yaml_scalar_event_initialize(
940:        -:  906:                        	&evt,
941:        -:  907:                    	    NULL,
942:        -:  908:                    		NULL,
943:        -:  909:                    		"VALUE",
944:        -:  910:                    		5,
945:        -:  911:                    		TRUE,
946:        -:  912:                    		TRUE, 
947:        -:  913:                    		YAML_PLAIN_SCALAR_STYLE); 
948:        -:  914:       yaml_emitter_emit(emitter, &evt);
949:        -:  915:                    			
950:        -:  916:       yaml_scalar_event_initialize(
951:        -:  917:                        	&evt,
952:        -:  918:                    	    NULL,
953:        -:  919:                    		NULL,
954:        -:  920:                    		(unsigned char *)var-&gt;value,
955:        -:  921:                    		strlen(var-&gt;value),
956:        -:  922:                    		TRUE,
957:        -:  923:                    		TRUE, 
958:        -:  924:                    		YAML_PLAIN_SCALAR_STYLE); 	
959:        -:  925:        yaml_emitter_emit(emitter, &evt);
960:        -:  926:        
961:        -:  927:        if(strcmp(var-&gt;min, var-&gt;max)) {
962:        -:  928:            yaml_scalar_event_initialize(
963:        -:  929:                        	&evt,
964:        -:  930:                    	    NULL,
965:        -:  931:                    		NULL,
966:        -:  932:                    		"MIN",
967:        -:  933:                    		3,
968:        -:  934:                    		TRUE,
969:        -:  935:                    		TRUE, 
970:        -:  936:                    		YAML_PLAIN_SCALAR_STYLE); 
971:        -:  937:            yaml_emitter_emit(emitter, &evt);
972:        -:  938:                    			
973:        -:  939:            yaml_scalar_event_initialize(
974:        -:  940:                        	&evt,
975:        -:  941:                    	    NULL,
976:        -:  942:                    		NULL,
977:        -:  943:                    		(unsigned char *)var-&gt;min,
978:        -:  944:                    		strlen(var-&gt;min),
979:        -:  945:                    		TRUE,
980:        -:  946:                    		TRUE, 
981:        -:  947:                    		YAML_PLAIN_SCALAR_STYLE); 	
982:        -:  948:            yaml_emitter_emit(emitter, &evt);
983:        -:  949:
984:        -:  950:            yaml_scalar_event_initialize(
985:        -:  951:                        	&evt,
986:        -:  952:                    	    NULL,
987:        -:  953:                    		NULL,
988:        -:  954:                    		"MAX",
989:        -:  955:                    		3,
990:        -:  956:                    		TRUE,
991:        -:  957:                    		TRUE, 
992:        -:  958:                    		YAML_PLAIN_SCALAR_STYLE); 
993:        -:  959:            yaml_emitter_emit(emitter, &evt);
994:        -:  960:                    			
995:        -:  961:            yaml_scalar_event_initialize(
996:        -:  962:                        	&evt,
997:        -:  963:                    	    NULL,
998:        -:  964:                    		NULL,
999:        -:  965:                    		(unsigned char *)var-&gt;max,
1000:        -:  966:                    		strlen(var-&gt;max),
1001:        -:  967:                    		TRUE,
1002:        -:  968:                    		TRUE, 
1003:        -:  969:                    		YAML_PLAIN_SCALAR_STYLE); 	
1004:        -:  970:            yaml_emitter_emit(emitter, &evt);
1005:        -:  971:       }       */
1006:<font color=red>    #####:  972:        yaml_mapping_end_event_initialize(&evt); 	</font>
1007:<font color=red>    #####:  973:        yaml_emitter_emit(emitter, &evt); </font>
1008:        -:  974:    }
1009:       96:  975:} 
1010:        -:  976:
1011:function emit_entry called 50 returned 1000locks executed 97%
1012:       50:  977:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
1013:       50:  978:    int i = 0;
1014:        -:  979:    yaml_event_t evt;
1015:        -:  980:     
1016:      100:  981:    yaml_scalar_event_initialize(
1017:        -:  982:    	&evt,
1018:        -:  983:	    NULL,
1019:        -:  984:		NULL,
1020:       50:  985:		(unsigned char *)entry-&gt;name,
1021:       50:  986:		strlen(entry-&gt;name),
1022:        -:  987:		TRUE,
1023:        -:  988:		TRUE, 
1024:        -:  989:		YAML_PLAIN_SCALAR_STYLE); 	
1025:        -:  990:		
1026:       50:  991:	yaml_emitter_emit(emitter, &evt);
1027:        -:  992:	//log_yml_event(evt);
1028:        -:  993:	char buf[TINYBUF];
1029:       50:  994:	memset(buf, 0, TINYBUF);
1030:       50:  995:	entry_t iter = NULL;
1031:       50:  996:	variable_t viter = NULL;
1032:        -:  997:	
1033:       50:  998:	switch (entry-&gt;type_tag){
1034:        -:  999:	
1035:        -: 1000:		case ENTRY_STR:
1036:        -: 1001:		
1037:       16: 1002:			yaml_scalar_event_initialize(
1038:        -: 1003:    		&evt,
1039:        -: 1004:	    	NULL,
1040:        -: 1005:			NULL,
1041:        8: 1006:			(unsigned char *)entry-&gt;e.scalar_str,
1042:        8: 1007:			strlen(entry-&gt;e.scalar_str),
1043:        -: 1008:			TRUE,
1044:        -: 1009:			TRUE, 
1045:        -: 1010:			YAML_PLAIN_SCALAR_STYLE); 	
1046:        -: 1011:		
1047:        8: 1012:			yaml_emitter_emit(emitter, &evt); 
1048:        -: 1013:			//log_yml_event(evt);		
1049:        8: 1014:			break;
1050:        -: 1015:		
1051:        -: 1016:		case ENTRY_INT:
1052:        -: 1017:			
1053:       18: 1018:			sprintf(buf, "0", entry-&gt;e.scalar_int);
1054:       18: 1019:			yaml_scalar_event_initialize(
1055:        -: 1020:    		&evt,
1056:        -: 1021:	    	NULL,
1057:        -: 1022:			NULL,
1058:        -: 1023:			(unsigned char *)buf,
1059:       18: 1024:			strlen(buf),
1060:        -: 1025:			TRUE,
1061:        -: 1026:			TRUE, 
1062:        -: 1027:			YAML_PLAIN_SCALAR_STYLE); 	
1063:        -: 1028:		
1064:       18: 1029:			yaml_emitter_emit(emitter, &evt);
1065:        -: 1030:			//log_yml_event(evt); 		
1066:       18: 1031:			break;
1067:        -: 1032:				 
1068:        -: 1033:		case ENTRY_MAP:
1069:        -: 1034:		
1070:        8: 1035:		    yaml_mapping_start_event_initialize(
1071:        -: 1036:    			&evt,
1072:        -: 1037:    			NULL,
1073:        -: 1038:    			NULL,
1074:        -: 1039:    			FALSE,
1075:        -: 1040:    			YAML_BLOCK_MAPPING_STYLE);
1076:        -: 1041:    	 	    
1077:        8: 1042:    		yaml_emitter_emit(emitter, &evt);
1078:        -: 1043:    		//log_yml_event(evt);
1079:        8: 1044:    		iter = *(entry-&gt;e.conf-&gt;map);
1080:        -: 1045:    		
1081:       38: 1046:			while(i &lt; entry-&gt;e.conf-&gt;size){
1082:       22: 1047:			    if(iter != NULL) {
1083:       22: 1048:				    emit_entry(iter, emitter);  
1084:        -: 1049:				}
1085:       22: 1050:				iter = (entry-&gt;e.conf-&gt;map)[++i];
1086:        -: 1051:			}	
1087:        8: 1052:			yaml_mapping_end_event_initialize(&evt); 	
1088:        8: 1053:    		yaml_emitter_emit(emitter, &evt); 
1089:        -: 1054:    		//log_yml_event(evt);
1090:        8: 1055:			break;
1091:        -: 1056:		
1092:        -: 1057:		case ENTRY_SEQ:
1093:       16: 1058:		  yaml_sequence_start_event_initialize(
1094:        -: 1059:    			&evt,
1095:        -: 1060:    			NULL,
1096:        -: 1061:    			NULL,
1097:        -: 1062:    			TRUE,
1098:        -: 1063:    			YAML_BLOCK_SEQUENCE_STYLE);
1099:        -: 1064:    		//log_yml_event(evt);
1100:       16: 1065:    	    yaml_emitter_emit(emitter, &evt); 	
1101:        -: 1066:		//emit size as int
1102:        -: 1067:		  
1103:       16: 1068:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
1104:       16: 1069:			yaml_scalar_event_initialize(
1105:        -: 1070:    		&evt,
1106:        -: 1071:	    	NULL,
1107:        -: 1072:			NULL,
1108:        -: 1073:			(unsigned char *)buf,
1109:       16: 1074:			strlen(buf),
1110:        -: 1075:			TRUE,
1111:        -: 1076:			TRUE, 
1112:        -: 1077:			YAML_PLAIN_SCALAR_STYLE); 	
1113:        -: 1078:		
1114:       16: 1079:			yaml_emitter_emit(emitter, &evt);
1115:        -: 1080:			//log_yml_event(evt); 		
1116:        -: 1081:			//emit values as map
1117:       16: 1082:			viter = entry-&gt;e.seq-&gt;vars;
1118:        -: 1083:    		
1119:       16: 1084:    		i = 0;
1120:      128: 1085:			while(i &lt; entry-&gt;e.seq-&gt;size){
1121:       96: 1086:			    if(viter != NULL) {
1122:       96: 1087:				   emit_variable(viter, emitter);
1123:        -: 1088:				}
1124:       96: 1089:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
1125:        -: 1090:			}	
1126:        -: 1091:			
1127:       16: 1092:			yaml_sequence_end_event_initialize(&evt); 	
1128:       16: 1093:    		yaml_emitter_emit(emitter, &evt); 
1129:        -: 1094:    		//log_yml_event(evt);
1130:       16: 1095:			break;
1131:        -: 1096:			
1132:<font color=red>    #####: 1097:		default:break;</font>
1133:        -: 1098:	}
1134:        -: 1099:	
1135:       50: 1100:}
1136:        -: 1101:
1137:function emit called 2 returned 1000locks executed 100%
1138:        2: 1102:int emit(yaml_emitter_t *emitter, const config_t conf) {
1139:        2: 1103:    int r = PLC_OK;     
1140:        -: 1104:   
1141:        -: 1105:    yaml_event_t evt;
1142:        -: 1106:    char val[MAXSTR];
1143:        2: 1107:    memset(val,0,MAXSTR);
1144:        -: 1108:    //doc start
1145:        2: 1109:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, FALSE); 
1146:        2: 1110:	yaml_emitter_emit(emitter, &evt); 		
1147:        -: 1111:   // log_yml_event(evt);
1148:        -: 1112:    
1149:        2: 1113:    yaml_mapping_start_event_initialize(
1150:        -: 1114:    	&evt,
1151:        -: 1115:    	NULL,
1152:        -: 1116:    	NULL,
1153:        -: 1117:    	FALSE,
1154:        -: 1118:    	YAML_BLOCK_MAPPING_STYLE);
1155:        -: 1119:    	 	    
1156:        2: 1120:    yaml_emitter_emit(emitter, &evt);
1157:        -: 1121:   // log_yml_event(evt);
1158:        -: 1122:    
1159:        -: 1123:     
1160:        2: 1124:    entry_map_t config_map = conf-&gt;map;
1161:        2: 1125:    entry_t iter = *config_map;
1162:        2: 1126:    int i = 0;
1163:       60: 1127:    while(i &lt; N_CONFIG_VARIABLES) {
1164:       56: 1128:        if(iter != NULL){
1165:       28: 1129:    	    emit_entry(iter, emitter);
1166:        -: 1130:    	}
1167:       56: 1131:    	iter = config_map[++i];
1168:        -: 1132:    }
1169:        -: 1133:   
1170:        -: 1134:    //mapping end
1171:        2: 1135:    yaml_mapping_end_event_initialize(&evt); 	
1172:        2: 1136:    yaml_emitter_emit(emitter, &evt); 		
1173:        -: 1137:    //log_yml_event(evt);
1174:        -: 1138:    
1175:        -: 1139:    //doc end
1176:        2: 1140:    yaml_document_end_event_initialize(&evt,FALSE);
1177:        2: 1141:    yaml_emitter_emit(emitter, &evt);
1178:        -: 1142:    //log_yml_event(evt); 		
1179:        2: 1143:    yaml_event_delete(&evt); 	
1180:        2: 1144:    return r;
1181:        -: 1145:}
1182:        -: 1146:
1183:function save_config_yml called 0 returned 00locks executed 0%
1184:<font color=red>    #####: 1147:int save_config_yml(const char * filename, const config_t conf) {</font>
1185:        -: 1148:    
1186:        -: 1149:    yaml_emitter_t emitter;
1187:        -: 1150:    yaml_event_t event;
1188:        -: 1151:    
1189:        -: 1152:    FILE * fcfg;
1190:        -: 1153:    char path[MAXSTR];
1191:<font color=red>    #####: 1154:    int r = PLC_OK;</font>
1192:        -: 1155:    
1193:<font color=red>    #####: 1156:    memset(path, 0, MAXSTR);</font>
1194:<font color=red>    #####: 1157:    sprintf(path, "", filename);</font>
1195:        -: 1158:
1196:<font color=red>    #####: 1159:    if(!yaml_emitter_initialize(&emitter)){</font>
1197:<font color=red>    #####: 1160:        return PLC_ERR;    </font>
1198:        -: 1161:    }
1199:<font color=red>    #####: 1162:    if ((fcfg = fopen(path, "wb"))) {</font>
1200:<font color=red>    #####: 1163:         plc_log("Save configuration to  ...", path);</font>
1201:        -: 1164:         
1202:<font color=red>    #####: 1165:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1203:<font color=red>    #####: 1166:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1204:        -: 1167:         
1205:<font color=red>    #####: 1168:         r = yaml_emitter_emit(&emitter, &event);</font>
1206:        -: 1169:         
1207:<font color=red>    #####: 1170:         if(r)</font>
1208:<font color=red>    #####: 1171:            r = emit(&emitter, conf);</font>
1209:<font color=red>    #####: 1172:         if(r){</font>
1210:<font color=red>    #####: 1173:            yaml_stream_end_event_initialize(&event);</font>
1211:<font color=red>    #####: 1174:            r = yaml_emitter_emit(&emitter, &event);   </font>
1212:        -: 1175:         }
1213:        -: 1176:            
1214:<font color=red>    #####: 1177:         if(r &lt; PLC_OK)</font>
1215:<font color=red>    #####: 1178:            plc_log( "Configuration error ");</font>
1216:        -: 1179:            
1217:<font color=red>    #####: 1180:         fclose(fcfg);</font>
1218:        -: 1181:    } else {
1219:<font color=red>    #####: 1182:        r = PLC_ERR;</font>
1220:<font color=red>    #####: 1183:        plc_log("Could not open file  for write", filename);</font>
1221:        -: 1184:    }
1222:<font color=red>    #####: 1185:    yaml_emitter_delete(&emitter);</font>
1223:<font color=red>    #####: 1186:    return r;</font>
1224:        -: 1187:}
1225:        -: 1188:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
