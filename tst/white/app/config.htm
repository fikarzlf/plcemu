<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:
 10:function strdup_r called 14 returned 1000locks executed 100%
 11:       14:    5:char * strdup_r(const char * dest, const char * src) {
 12:        -:    6://strdup with realloc
 13:        -:    7:
 14:       14:    8:    char * r = (!dest)?(char *)malloc(sizeof(src)):realloc(dest, sizeof(src));
 15:        -:    9:        
 16:       14:   10:    memset(r, 0, sizeof(src));
 17:       14:   11:    sprintf(r, "", src);
 18:        -:   12:    
 19:       14:   13:    return r;
 20:        -:   14:}
 21:        -:   15:
 22:function yaml_config_error called 0 returned 00locks executed 0%
 23:<font color=red>    #####:   16:static void yaml_config_error(yaml_parser_t parser){</font>
 24:        -:   17:
 25:        -:   18:    //print line
 26:<font color=red>    #####:   19:}</font>
 27:        -:   20:
 28:function yaml_parser_error called 0 returned 00locks executed 0%
 29:<font color=red>    #####:   21:static void yaml_parser_error(yaml_parser_t parser){</font>
 30:        -:   22:
 31:<font color=red>    #####:   23:     switch (parser.error)</font>
 32:        -:   24:     {
 33:        -:   25:        case YAML_MEMORY_ERROR:
 34:<font color=red>    #####:   26:            plc_log( </font>
 35:        -:   27:            "Memory error: Not enough memory for parsing");
 36:<font color=red>    #####:   28:            break;</font>
 37:        -:   29:
 38:        -:   30:        case YAML_READER_ERROR:
 39:<font color=red>    #####:   31:            if (parser.problem_value != -1) {</font>
 40:<font color=red>    #####:   32:                plc_log( </font>
 41:        -:   33:                "Reader error: : #0 at 0", 
 42:        -:   34:                parser.problem,
 43:        -:   35:                parser.problem_value, 
 44:        -:   36:                parser.problem_offset);
 45:        -:   37:            }
 46:        -:   38:            else {
 47:<font color=red>    #####:   39:                plc_log( </font>
 48:        -:   40:                "Reader error:  at 0", 
 49:        -:   41:                parser.problem,
 50:        -:   42:                parser.problem_offset);
 51:        -:   43:            }
 52:<font color=red>    #####:   44:            break;</font>
 53:        -:   45:
 54:        -:   46:        case YAML_SCANNER_ERROR:
 55:<font color=red>    #####:   47:            if (parser.context) {</font>
 56:<font color=red>    #####:   48:                plc_log( </font>
 57:        -:   49:                "Scanner error:  at line 0, column 0"
 58:        -:   50:                        " at line 0, column 0", 
 59:        -:   51:                        parser.context,
 60:<font color=red>    #####:   52:                        parser.context_mark.line+1,</font>
 61:<font color=red>    #####:   53:                        parser.context_mark.column+1,</font>
 62:        -:   54:                        parser.problem, 
 63:<font color=red>    #####:   55:                        parser.problem_mark.line+1,</font>
 64:<font color=red>    #####:   56:                        parser.problem_mark.column+1);</font>
 65:        -:   57:            }
 66:        -:   58:            else {
 67:<font color=red>    #####:   59:                plc_log( </font>
 68:        -:   60:                "Scanner error:  at line 0, column 0",
 69:<font color=red>    #####:   61:                        parser.problem, parser.problem_mark.line+1,</font>
 70:<font color=red>    #####:   62:                        parser.problem_mark.column+1);</font>
 71:        -:   63:            }
 72:<font color=red>    #####:   64:            break;</font>
 73:        -:   65:
 74:        -:   66:        case YAML_PARSER_ERROR:
 75:<font color=red>    #####:   67:            if (parser.context) {</font>
 76:<font color=red>    #####:   68:                plc_log( </font>
 77:        -:   69:                "Parser error:  at line 0, column 0"
 78:        -:   70:                        " at line 0, column 0", 
 79:        -:   71:                        parser.context,
 80:<font color=red>    #####:   72:                        parser.context_mark.line+1,</font>
 81:<font color=red>    #####:   73:                        parser.context_mark.column+1,</font>
 82:        -:   74:                        parser.problem, 
 83:<font color=red>    #####:   75:                        parser.problem_mark.line+1,</font>
 84:<font color=red>    #####:   76:                        parser.problem_mark.column+1);</font>
 85:        -:   77:            }
 86:        -:   78:            else {
 87:<font color=red>    #####:   79:                plc_log( </font>
 88:        -:   80:                "Parser error:  at line 0, column 0",
 89:        -:   81:                        parser.problem, 
 90:<font color=red>    #####:   82:                        parser.problem_mark.line+1,</font>
 91:<font color=red>    #####:   83:                        parser.problem_mark.column+1);</font>
 92:        -:   84:            }
 93:<font color=red>    #####:   85:            break;</font>
 94:        -:   86:
 95:        -:   87:        default:
 96:        -:   88:            /* Couldn't happen. */
 97:<font color=red>    #####:   89:            plc_log( </font>
 98:        -:   90:            "Internal error\n");
 99:<font color=red>    #####:   91:            break;</font>
100:        -:   92:    }
101:<font color=red>    #####:   93:}</font>
102:        -:   94:
103:function new_entry_int called 108 returned 1000locks executed 100%
104:      108:   95:entry_t new_entry_int(int i, char * name) {
105:      108:   96:	entry_t r = (entry_t)malloc(sizeof(struct entry));
106:      108:   97:	r-&gt;type_tag = ENTRY_INT;
107:      108:   98:	r-&gt;name = name;
108:      108:   99:	r-&gt;e.scalar_int = i;
109:        -:  100:
110:      108:  101:	return r;
111:        -:  102:}
112:        -:  103:
113:function new_entry_str called 48 returned 1000locks executed 100%
114:       48:  104:entry_t new_entry_str(char * str, char * name) {
115:        -:  105:
116:       48:  106:	entry_t r = (entry_t)malloc(sizeof(struct entry));
117:       48:  107:	r-&gt;type_tag = ENTRY_STR;
118:       48:  108:	r-&gt;name = name;
119:       48:  109:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
120:       48:  110:    sprintf(r-&gt;e.scalar_str, "", str);
121:       48:  111:	return r;
122:        -:  112:}
123:        -:  113:
124:function new_entry_map called 48 returned 1000locks executed 100%
125:       48:  114:entry_t new_entry_map(config_t map, char * name) {
126:        -:  115:	
127:       48:  116:	entry_t r = (entry_t)malloc(sizeof(struct entry));
128:       48:  117:	r-&gt;type_tag = ENTRY_MAP;
129:       48:  118:	r-&gt;name = name;
130:       48:  119:	r-&gt;e.conf = map;
131:        -:  120:
132:       48:  121:	return r;
133:        -:  122:}
134:        -:  123:
135:function new_entry_seq called 96 returned 1000locks executed 100%
136:       96:  124:entry_t new_entry_seq(sequence_t seq, char * name) {
137:        -:  125:	
138:       96:  126:	entry_t r = (entry_t)malloc(sizeof(struct entry));
139:       96:  127:	r-&gt;type_tag = ENTRY_SEQ;
140:       96:  128:	r-&gt;name = name;
141:       96:  129:	r-&gt;e.seq = seq;
142:        -:  130:
143:       96:  131:	return r;
144:        -:  132:}
145:        -:  133:
146:function new_entry_null called 0 returned 00locks executed 0%
147:<font color=red>    #####:  134:entry_t new_entry_null() {</font>
148:<font color=red>    #####:  135:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
149:<font color=red>    #####:  136:	r-&gt;type_tag = ENTRY_NONE;</font>
150:<font color=red>    #####:  137:	r-&gt;name = "";</font>
151:<font color=red>    #####:  138:	r-&gt;e.scalar_int = 0;</font>
152:        -:  139:
153:<font color=red>    #####:  140:	return r;</font>
154:        -:  141:}
155:        -:  142:
156:function update_entry called 300 returned 1000locks executed 80%
157:      300:  143:config_t update_entry(
158:        -:  144:    unsigned int key, 
159:        -:  145:    const entry_t item,
160:        -:  146:    const config_t conf) {
161:        -:  147:    
162:      600:  148:    if( conf == NULL ||
163:      300:  149:        key &gt;= conf-&gt;size) {
164:        -:  150:    
165:<font color=red>    #####:  151:        return conf;</font>
166:        -:  152:    } else {
167:        -:  153:    
168:      300:  154:        config_t r = conf;
169:      300:  155:        r-&gt;map[key] = item;
170:        -:  156:        
171:      300:  157:        return r;
172:        -:  158:    }
173:        -:  159:}
174:        -:  160:
175:function get_entry called 102 returned 1000locks executed 100%
176:      102:  161:entry_t get_entry(int key, const config_t conf){
177:        -:  162:
178:      102:  163:    if(conf == NULL || 
179:       88:  164:        key &lt; 0 || 
180:       88:  165:        key &gt; conf-&gt;size) {
181:        -:  166:        
182:       14:  167:        return NULL;    
183:        -:  168:    }
184:        -:  169:    
185:       88:  170:    return conf-&gt;map[key];
186:        -:  171:}
187:        -:  172:
188:function copy_entry called 6 returned 1000locks executed 100%
189:        6:  173:entry_t copy_entry(int key, const config_t conf){
190:        6:  174:}
191:        -:  175:
192:function get_numeric_entry called 4 returned 1000locks executed 100%
193:        4:  176:int get_numeric_entry(int key, const config_t conf){
194:        4:  177:    entry_t e = get_entry(key, conf);
195:        4:  178:    if(e && e-&gt;type_tag == ENTRY_INT){
196:        -:  179:    
197:        2:  180:        return e-&gt;e.scalar_int;
198:        -:  181:    } else {
199:        -:  182:    
200:        2:  183:        return CONF_ERR;    
201:        -:  184:    } 
202:        -:  185:}
203:        -:  186:
204:function get_string_entry called 4 returned 1000locks executed 100%
205:        4:  187:char * get_string_entry(int key, const config_t conf){
206:        -:  188:    
207:        4:  189:    entry_t e = get_entry(key, conf);
208:        4:  190:    if(e && e-&gt;type_tag == ENTRY_STR){
209:        -:  191:    
210:        2:  192:        return e-&gt;e.scalar_str;
211:        -:  193:    } else {
212:        -:  194:    
213:        2:  195:        return NULL;    
214:        -:  196:    }    
215:        -:  197:}
216:        -:  198:
217:function get_sequence_entry called 4 returned 1000locks executed 83%
218:        4:  199:sequence_t get_sequence_entry(int key, const config_t conf){
219:        4:  200:    entry_t e = get_entry(key, conf);
220:        4:  201:    if(e && e-&gt;type_tag == ENTRY_SEQ){
221:        -:  202:    
222:        4:  203:        return e-&gt;e.seq;
223:        -:  204:    } else {
224:        -:  205:    
225:<font color=red>    #####:  206:        return NULL;    </font>
226:        -:  207:    }    
227:        -:  208:}
228:        -:  209:
229:function get_recursive_entry called 0 returned 00locks executed 0%
230:<font color=red>    #####:  210:config_t get_recursive_entry(int key, const config_t conf){</font>
231:<font color=red>    #####:  211:    entry_t e = get_entry(key, conf);</font>
232:<font color=red>    #####:  212:    if(e && e-&gt;type_tag == ENTRY_MAP){</font>
233:        -:  213:    
234:<font color=red>    #####:  214:        return e-&gt;e.conf;</font>
235:        -:  215:    } else {
236:        -:  216:    
237:<font color=red>    #####:  217:        return NULL;    </font>
238:        -:  218:    }    
239:        -:  219:}
240:        -:  220:
241:        -:  221://TODO: in a c++ impl. this would be a hashmap
242:function new_param called 12 returned 1000locks executed 100%
243:       12:  222:param_t new_param(const char * key, 
244:        -:  223:                     const char * val){
245:        -:  224:    
246:       12:  225:        param_t n = (param_t)malloc(sizeof(struct param));
247:       12:  226:        n-&gt;key = strdup(key);
248:       12:  227:        n-&gt;value = strdup(val);
249:       12:  228:        n-&gt;next = NULL;
250:        -:  229:        
251:       12:  230:        return n;        
252:        -:  231:}
253:        -:  232:
254:function get_param called 10 returned 1000locks executed 100%
255:       10:  233:param_t get_param(const char * key, const param_t params){
256:       10:  234:    param_t it = params;
257:       30:  235:    while(it && key){
258:       16:  236:        if(!strcmp(it-&gt;key, key)){
259:        -:  237:        
260:        6:  238:            return it;
261:        -:  239:        }
262:       10:  240:        it = it-&gt;next;            
263:        -:  241:    }
264:        -:  242:    
265:        4:  243:    return NULL;
266:        -:  244:}
267:        -:  245:
268:function get_param_val called 6 returned 1000locks executed 83%
269:        6:  246:char * get_param_val(const char * key, const param_t params){
270:        6:  247:    param_t it = get_param(key, params);
271:        -:  248:    
272:        6:  249:    return it?it-&gt;value:NULL;
273:        -:  250:}
274:        -:  251:
275:function append_param called 4 returned 1000locks executed 88%
276:        4:  252:param_t append_param(const param_t params, 
277:        -:  253:                     const char * key, 
278:        -:  254:                     const char * val){
279:        -:  255:        
280:        4:  256:    if(params == NULL){
281:        -:  257:        
282:<font color=red>    #####:  258:        return new_param(key, val);</font>
283:        -:  259:    } else {
284:        4:  260:        param_t ret = params;
285:        4:  261:        param_t it = params;
286:       10:  262:        while(it-&gt;next){
287:        2:  263:            it = it-&gt;next;
288:        -:  264:        }
289:        4:  265:        it-&gt;next = new_param(key, val);
290:        -:  266:                
291:        4:  267:        return ret;    
292:        -:  268:    }
293:        -:  269:}
294:        -:  270:
295:function update_param called 12 returned 1000locks executed 78%
296:       12:  271:param_t update_param(const param_t params, 
297:        -:  272:                     const char * key, 
298:        -:  273:                     const char * val){
299:        -:  274:        
300:       12:  275:    if(params == NULL){
301:        -:  276:        
302:        8:  277:        return new_param(key, val);         
303:        -:  278:    } else {
304:        4:  279:        param_t ret = params;
305:        4:  280:        param_t par = get_param(key, params);
306:        4:  281:        if(par){
307:<font color=red>    #####:  282:            par-&gt;value = strdup_r(par-&gt;value, val);</font>
308:        -:  283:        } else {
309:        -:  284:        //FIXME: ..and this is why we need a hashmap.
310:        4:  285:            ret = append_param(ret, key, val);  
311:        -:  286:        } 
312:        4:  287:        return ret;    
313:        -:  288:    }
314:        -:  289:}
315:        -:  290:
316:function get_key called 38 returned 1000locks executed 100%
317:       38:  291:int get_key(const char * name, const config_t where) {
318:       38:  292:     if(where != NULL){
319:        -:  293:    
320:      284:  294:        for(int i = 0; i &lt; where-&gt;size; i++) {
321:      516:  295:            if( where-&gt;map[i] != NULL &&
322:      244:  296:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
323:        -:  297:                
324:       26:  298:                return i;
325:        -:  299:            }
326:        -:  300:        }
327:        -:  301:    }
328:        -:  302:    
329:       12:  303:    return CONF_ERR;  
330:        -:  304:}
331:        -:  305:
332:function new_config called 60 returned 1000locks executed 100%
333:       60:  306:config_t new_config(int size) {
334:       60:  307:    config_t r = (config_t)malloc(sizeof(struct config));
335:       60:  308:	memset(r, 0, sizeof(struct config));
336:       60:  309:	r-&gt;size = size;
337:       60:  310:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
338:       60:  311:    memset(r-&gt;map, 0, size*sizeof(struct entry));
339:        -:  312:    
340:       60:  313:	return r;
341:        -:  314:}
342:        -:  315:
343:function new_sequence called 96 returned 1000locks executed 100%
344:       96:  316:sequence_t new_sequence(int size) {
345:       96:  317:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
346:       96:  318:	memset(r, 0, sizeof(struct sequence));
347:       96:  319:	r-&gt;size = size;
348:       96:  320:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
349:       96:  321:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
350:        -:  322:	
351:       96:  323:	return r;
352:        -:  324:}
353:        -:  325:
354:function clear_config called 4 returned 1000locks executed 100%
355:        4:  326:config_t clear_config(config_t c){
356:        -:  327:
357:        4:  328:    return (config_t)NULL;
358:        -:  329:}
359:        -:  330:
360:function log_yml_event called 2 returned 1000locks executed 19%
361:        2:  331:static int log_yml_event(yaml_event_t event){
362:        -:  332:
363:        2:  333:    switch(event.type){ 
364:        -:  334:    
365:        -:  335:        case YAML_NO_EVENT: 
366:        2:  336:        	plc_log("No event!"); 
367:        2:  337:            break;
368:        -:  338:    /* Stream start/end */
369:        -:  339:        case YAML_STREAM_START_EVENT: 
370:<font color=red>    #####:  340:        	plc_log("STREAM START"); </font>
371:<font color=red>    #####:  341:            break;</font>
372:        -:  342:        case YAML_STREAM_END_EVENT: 
373:<font color=red>    #####:  343:        	plc_log("STREAM END");   </font>
374:<font color=red>    #####:  344:            break;</font>
375:        -:  345:    /* Block delimeters */
376:        -:  346:        case YAML_DOCUMENT_START_EVENT: 
377:<font color=red>    #####:  347:        	plc_log("Start Document"); </font>
378:<font color=red>    #####:  348:            break;</font>
379:        -:  349:        case YAML_DOCUMENT_END_EVENT: 
380:<font color=red>    #####:  350:        	plc_log("End Document");   </font>
381:<font color=red>    #####:  351:            break;</font>
382:        -:  352:        case YAML_SEQUENCE_START_EVENT: 
383:<font color=red>    #####:  353:        	plc_log("Start Sequence"); </font>
384:<font color=red>    #####:  354:            break;</font>
385:        -:  355:        case YAML_SEQUENCE_END_EVENT: 
386:<font color=red>    #####:  356:        	plc_log("End Sequence");</font>
387:<font color=red>    #####:  357:            break;</font>
388:        -:  358:        case YAML_MAPPING_START_EVENT: 
389:<font color=red>    #####:  359:        	plc_log("Start Mapping");         </font>
390:<font color=red>    #####:  360:            break;</font>
391:        -:  361:        case YAML_MAPPING_END_EVENT: 
392:<font color=red>    #####:  362:        	plc_log("End Mapping");      </font>
393:<font color=red>    #####:  363:            break;</font>
394:        -:  364:    /* Data */
395:        -:  365:        case YAML_ALIAS_EVENT:  
396:<font color=red>    #####:  366:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
397:<font color=red>    #####:  367:            break;</font>
398:        -:  368:        case YAML_SCALAR_EVENT: 
399:<font color=red>    #####:  369:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
400:<font color=red>    #####:  370:        	break;</font>
401:        -:  371:        default:
402:<font color=red>    #####:  372:            plc_log("default?");</font>
403:        -:  373:    }
404:        2:  374:    return CONF_OK;
405:        -:  375:}
406:        -:  376:
407:function store_value called 26 returned 1000locks executed 85%
408:       26:  377:config_t store_value(
409:        -:  378:            unsigned char key, 
410:        -:  379:            const char * value, 
411:        -:  380:            config_t config){
412:        -:  381:
413:        -:  382:    entry_t e; 
414:       26:  383:    if( config == NULL) {
415:        -:  384:    
416:<font color=red>    #####:  385:        return NULL;</font>
417:        -:  386:    }
418:        -:  387:    
419:       26:  388:    config_t conf = config;
420:       26:  389:    e = get_entry(key, conf);
421:        -:  390:    
422:       26:  391:    if(e == NULL) {
423:        2:  392:        conf-&gt;err = CONF_ERR;
424:        -:  393:        
425:        2:  394:        return conf;
426:        -:  395:    }
427:        -:  396:    
428:       24:  397:    switch(e-&gt;type_tag){
429:        -:  398:         case ENTRY_INT:
430:       16:  399:            e-&gt;e.scalar_int = atoi(value);
431:       16:  400:            break;
432:        -:  401:         
433:        -:  402:         case ENTRY_STR:
434:        -:  403:         
435:        8:  404:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
436:        8:  405:            break;
437:        -:  406:            
438:<font color=red>    #####:  407:         default: return conf;</font>
439:        -:  408:    }        
440:       24:  409:    conf-&gt;map[key] = e;
441:        -:  410:       
442:       24:  411:    return conf;
443:        -:  412:}
444:        -:  413:
445:function store_seq_value called 22 returned 1000locks executed 100%
446:       22:  414:config_t store_seq_value(
447:        -:  415:                    unsigned char seq,
448:        -:  416:                    unsigned char idx,  
449:        -:  417:                    const char * key,
450:        -:  418:                    const char * value, 
451:        -:  419:                    config_t config){
452:        -:  420:                    
453:       22:  421:    config_t conf = config;                
454:       22:  422:    entry_t s = conf-&gt;map[seq];
455:        -:  423:    
456:       22:  424:    if( s == NULL ||
457:       20:  425:        key == NULL || 
458:       18:  426:        value == NULL ||
459:       36:  427:        s-&gt;type_tag != ENTRY_SEQ ||
460:       18:  428:        idx &gt;= s-&gt;e.seq-&gt;size) {
461:        -:  429:        
462:        4:  430:        conf-&gt;err = CONF_ERR;
463:        -:  431:        
464:        4:  432:        return conf;
465:        -:  433:    }            
466:        -:  434:    
467:       54:  435:    variable_t var = &(conf-&gt;map[seq]
468:       18:  436:                            -&gt;e.seq
469:       36:  437:                            -&gt;vars[idx]);
470:        -:  438:    
471:       18:  439:    conf-&gt;map[seq]
472:       18:  440:        -&gt;e.seq
473:       18:  441:        -&gt;vars[idx].index = idx;
474:        -:  442:    
475:       18:  443:    if(!strcmp(key, "ID")){
476:        6:  444:         conf-&gt;map[seq]
477:        6:  445:             -&gt;e.seq
478:        6:  446:             -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
479:        -:  447:    } else {
480:        -:  448:        
481:       12:  449:        conf-&gt;map[seq]
482:       12:  450:            -&gt;e.seq
483:       24:  451:            -&gt;vars[idx].params = update_param(
484:       12:  452:                conf-&gt;map[seq]
485:       12:  453:                    -&gt;e.seq
486:       12:  454:                    -&gt;vars[idx].params,
487:        -:  455:                key,
488:        -:  456:                value);    
489:        -:  457:    }   
490:        -:  458:        
491:       18:  459:    return conf;                       
492:        -:  460:}
493:        -:  461:
494:function resize_sequence called 2 returned 1000locks executed 86%
495:        2:  462:static config_t resize_sequence(config_t config, int sequence, int size){
496:        2:  463:    config_t conf = config;
497:        2:  464:    sequence_t seq = get_sequence_entry(sequence, conf);
498:        2:  465:    if(size &lt;= 0 ||
499:        2:  466:        size &gt; CONF_MAX_SEQ || 
500:        2:  467:        sequence == NULL){
501:<font color=red>    #####:  468:        conf-&gt;err = CONF_ERR;</font>
502:        -:  469:        
503:<font color=red>    #####:  470:        return conf;</font>
504:        -:  471:    }  
505:        2:  472:    seq-&gt;size = size;
506:        2:  473:	seq-&gt;vars = (variable_t)realloc(seq-&gt;vars, size*sizeof(struct variable));
507:        2:  474:	memset(seq-&gt;vars, 0, size*sizeof(struct variable));    
508:        -:  475:        
509:        2:  476:    return conf;
510:        -:  477:}
511:        -:  478:
512:function process_seq_element called 12 returned 1000locks executed 100%
513:       12:  479:static config_t process_seq_element(
514:        -:  480:                   yaml_event_t event,
515:        -:  481:                   int sequence, 
516:        -:  482:                   const char * key,
517:        -:  483:                   int * idx,
518:        -:  484:                   config_t config){
519:        -:  485:    
520:       12:  486:    config_t conf = config;
521:       12:  487:    char * val = (char *)event.data.scalar.value;
522:       12:  488:    long size = 0;
523:       12:  489:    if(key[0] == 0) { //we are not in a map yet
524:        2:  490:        size = strtol(val, NULL, 10);
525:        -:  491:    }
526:       12:  492:    if(size &gt; 0 &&
527:        -:  493:        size &lt; CONF_MAX_SEQ){
528:        2:  494:        conf = resize_sequence(conf, sequence, (int)size);
529:       10:  495:    } else if(!strcmp(key, "INDEX")){
530:        -:  496:                             
531:        2:  497:            *idx = atoi(val);
532:        -:  498:    } else {  
533:        -:  499:                             
534:        8:  500:            conf = store_seq_value(sequence, 
535:        8:  501:                                      *idx, 
536:        -:  502:                                      key, 
537:        -:  503:                                      val, 
538:        -:  504:                                      conf);       
539:        -:  505:    }                      
540:        -:  506:      
541:       12:  507:    return conf;                       
542:        -:  508:}
543:        -:  509:
544:function process_scalar called 16 returned 1000locks executed 100%
545:       16:  510:static config_t process_scalar(
546:        -:  511:                   yaml_event_t event,
547:        -:  512:                   const char * key,
548:        -:  513:                   config_t config){
549:        -:  514:    
550:       16:  515:    config_t conf = config;
551:       16:  516:    char * val = (char *)event.data.scalar.value;
552:        -:  517:               
553:       16:  518:    conf = store_value(
554:       16:  519:                    get_key(key, conf), 
555:        -:  520:                    val, 
556:        -:  521:                    conf);
557:        -:  522:                 
558:       16:  523:    return conf;                       
559:        -:  524:}
560:        -:  525:
561:function process_mapping called 16 returned 1000locks executed 100%
562:       16:  526:static config_t process_mapping(
563:        -:  527:                    const char * key,
564:        -:  528:                    int seq,
565:        -:  529:                    yaml_parser_t *parser,
566:        -:  530:                    config_t config){
567:        -:  531:    
568:       16:  532:    config_t conf = config;                
569:       16:  533:    int k = get_key(key, conf);
570:       16:  534:    entry_t c = get_entry(k, conf);
571:        -:  535:    
572:       22:  536:    if( c != NULL &&
573:        6:  537:        c-&gt;type_tag == ENTRY_MAP) {
574:        -:  538:                    
575:        6:  539:        c-&gt;e.conf = process(
576:        -:  540:                        seq, 
577:        -:  541:                        parser, 
578:        -:  542:                        c-&gt;e.conf);        
579:        6:  543:        conf-&gt;map[k] = c;
580:        -:  544:    } else {
581:        -:  545:                    
582:       10:  546:        conf = process(
583:        -:  547:            seq, 
584:        -:  548:            parser, 
585:        -:  549:            conf);
586:        -:  550:    }
587:        -:  551:    
588:       16:  552:    return conf;    
589:        -:  553:} 
590:        -:  554:
591:function process called 30 returned 1000locks executed 94%
592:       30:  555:config_t process(int sequence, 
593:        -:  556:            yaml_parser_t *parser, 
594:        -:  557:            config_t configuration){
595:        -:  558:             
596:       30:  559:    config_t config = configuration;
597:       30:  560:    unsigned char storage = STORE_KEY;   
598:       30:  561:    int done = CONF_F;
599:        -:  562:    char key[CONF_STR];
600:       30:  563:    int idx = CONF_ERR;
601:        -:  564:    yaml_event_t event;
602:       30:  565:    memset(&event, 0, sizeof(event));
603:       30:  566:    memset(key, 0, CONF_STR);
604:       30:  567:    if(config == NULL) {
605:        -:  568:     
606:        2:  569:        return NULL;
607:        -:  570:     }
608:        -:  571:     
609:       28:  572:     if(parser == NULL) {
610:        2:  573:        config-&gt;err = CONF_ERR;
611:        -:  574:     
612:        2:  575:        return config;
613:        -:  576:     }
614:        -:  577://     || parser-&gt;context == NULL 
615:        -:  578:           
616:      184:  579:     while(done == CONF_F){
617:        -:  580:     
618:      132:  581:        if (!yaml_parser_parse(parser, &event)){   
619:<font color=red>    #####:  582:                yaml_parser_error(*parser);</font>
620:<font color=red>    #####:  583:                config-&gt;err = CONF_ERR;</font>
621:        -:  584:        } else {
622:        -:  585:   
623:      132:  586:            switch(event.type){
624:        -:  587:                case YAML_SCALAR_EVENT: 
625:        -:  588://swap storage to process val after key and vice versa 
626:       62:  589:                    if(storage == STORE_KEY) {
627:        -:  590: 
628:       34:  591:                            memset(key, 0, CONF_STR);
629:       34:  592:                            sprintf(key, "", 
630:       34:  593:                                (char *)event.data.scalar.value);
631:        -:  594:                        
632:       34:  595:                            storage = STORE_VAL;
633:        -:  596:                    } else {
634:       28:  597:                        if(sequence &gt; CONF_ERR) {
635:        -:  598:                    
636:       12:  599:                            config = process_seq_element(
637:        -:  600:                                    event,
638:        -:  601:                                    sequence,
639:        -:  602:                                    key,
640:        -:  603:                                    &idx,
641:        -:  604:                                    config);
642:        -:  605:                        } else {
643:        -:  606:                            
644:       16:  607:                            config = process_scalar(
645:        -:  608:                                    event,
646:        -:  609:                                    key,
647:        -:  610:                                    config);
648:        -:  611:                        }
649:       28:  612:                        storage = STORE_KEY;            
650:        -:  613:                    }
651:       62:  614:                    break;
652:        -:  615:                
653:        -:  616:                case YAML_SEQUENCE_START_EVENT:
654:        -:  617:
655:        2:  618:                    sequence = get_key(key, config);
656:        2:  619:                    memset(key, 0, CONF_STR);
657:        2:  620:                    break;
658:        -:  621:                
659:        -:  622:                case YAML_SEQUENCE_END_EVENT:
660:        -:  623:
661:        2:  624:                    sequence = CONF_ERR;
662:        2:  625:                    break;
663:        -:  626:                
664:        -:  627:                case YAML_MAPPING_START_EVENT:
665:        -:  628:                
666:       16:  629:                    config = process_mapping(
667:        -:  630:                                key,
668:        -:  631:                                sequence,
669:        -:  632:                                parser,
670:        -:  633:                                config); 
671:       16:  634:                    storage = STORE_KEY;            
672:       16:  635:                    break;
673:        -:  636:                    
674:        -:  637:                case YAML_MAPPING_END_EVENT:
675:        -:  638:                case YAML_STREAM_END_EVENT:     
676:        -:  639:                    
677:       24:  640:                    done = CONF_T;
678:       24:  641:                    break;
679:        -:  642:                    
680:        -:  643:                case YAML_NO_EVENT:
681:        2:  644:                    config-&gt;err = CONF_ERR;
682:        2:  645:                    break;    
683:        -:  646:                    
684:       24:  647:                default: break;    
685:        -:  648:            }
686:        -:  649:         }
687:      132:  650:         if(config-&gt;err &lt; CONF_OK) {
688:        2:  651:             done = CONF_T;
689:        2:  652:             plc_log("Could not parse event:");
690:        2:  653:             log_yml_event(event);
691:        -:  654:         }            
692:        -:  655:         //log_yml_event(event);                                  
693:        -:  656:         //yaml_event_delete(&event);   
694:        -:  657:     }
695:        -:  658:     
696:       26:  659:     return config;
697:        -:  660:}
698:        -:  661:             
699:function load_config_yml called 0 returned 00locks executed 0%
700:<font color=red>    #####:  662:config_t load_config_yml(const char * filename, config_t conf) {</font>
701:        -:  663:    yaml_parser_t parser;
702:        -:  664:    
703:        -:  665:    FILE * fcfg;
704:        -:  666:    char path[CONF_STR];
705:        -:  667:
706:<font color=red>    #####:  668:    memset(path, 0, CONF_STR);</font>
707:<font color=red>    #####:  669:    sprintf(path, "", filename);</font>
708:        -:  670:    
709:<font color=red>    #####:  671:    memset(&parser, 0, sizeof(parser));</font>
710:        -:  672:    
711:<font color=red>    #####:  673:    config_t r = conf;</font>
712:        -:  674:    
713:<font color=red>    #####:  675:    if (!yaml_parser_initialize(&parser)) {</font>
714:        -:  676:    
715:<font color=red>    #####:  677:        yaml_parser_error(parser);    </font>
716:        -:  678:    }
717:<font color=red>    #####:  679:    if ((fcfg = fopen(path, "r"))) {</font>
718:<font color=red>    #####:  680:        plc_log("Looking for configuration from  ...", path);</font>
719:<font color=red>    #####:  681:        yaml_parser_set_input_file(&parser, fcfg);</font>
720:<font color=red>    #####:  682:        r = process(CONF_ERR, &parser, conf);</font>
721:<font color=red>    #####:  683:        if(r-&gt;err &lt; CONF_OK)</font>
722:<font color=red>    #####:  684:            plc_log( "Configuration error ");</font>
723:<font color=red>    #####:  685:        fclose(fcfg);</font>
724:        -:  686:    } else {
725:<font color=red>    #####:  687:        r-&gt;err = CONF_ERR;</font>
726:<font color=red>    #####:  688:        plc_log("Could not open file ", filename);</font>
727:        -:  689:    }
728:<font color=red>    #####:  690:    yaml_parser_delete(&parser);</font>
729:<font color=red>    #####:  691:    return r;</font>
730:        -:  692:}
731:        -:  693:
732:function emit_variable called 96 returned 1000locks executed 100%
733:       96:  694:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
734:        -:  695:    yaml_event_t evt;
735:       98:  696:    if(var-&gt;name != NULL &&
736:        2:  697:        var-&gt;name[0]) {
737:        -:  698:       
738:        -:  699:        char idx[4];
739:        2:  700:        memset(idx, 0, 4);
740:        -:  701:    
741:        2:  702:        yaml_mapping_start_event_initialize(
742:        -:  703:    			        &evt,
743:        -:  704:    			        NULL,
744:        -:  705:    			        NULL,
745:        -:  706:    			        CONF_F,
746:        -:  707:    			        YAML_BLOCK_MAPPING_STYLE);
747:        -:  708:    	 	    
748:        2:  709:        yaml_emitter_emit(emitter, &evt);
749:        -:  710:    		//log_yml_event(evt);
750:        -:  711:    		            
751:        2:  712:        yaml_scalar_event_initialize(
752:        -:  713:                        	&evt,
753:        -:  714:                    	    NULL,
754:        -:  715:                    		NULL,
755:        -:  716:                    		"INDEX",
756:        -:  717:                    		5,
757:        -:  718:                    		CONF_T,
758:        -:  719:                    		CONF_T, 
759:        -:  720:                    		YAML_PLAIN_SCALAR_STYLE); 
760:        2:  721:        yaml_emitter_emit(emitter, &evt);
761:        -:  722:                    		
762:        2:  723:        sprintf(idx, "0", var-&gt;index);		
763:        2:  724:        yaml_scalar_event_initialize(
764:        -:  725:                        	&evt,
765:        -:  726:                    	    NULL,
766:        -:  727:                    		NULL,
767:        -:  728:                    		(unsigned char *)idx,
768:        2:  729:                    		strlen(idx),
769:        -:  730:                    		CONF_T,
770:        -:  731:                    		CONF_T, 
771:        -:  732:                    		YAML_PLAIN_SCALAR_STYLE); 	
772:        2:  733:        yaml_emitter_emit(emitter, &evt);
773:        -:  734:    		            
774:        -:  735:   
775:        2:  736:        yaml_scalar_event_initialize(
776:        -:  737:                        	&evt,
777:        -:  738:                    	    NULL,
778:        -:  739:                    		NULL,
779:        -:  740:                    		"ID",
780:        -:  741:                    		2,
781:        -:  742:                    		CONF_T,
782:        -:  743:                    		CONF_T, 
783:        -:  744:                    		YAML_PLAIN_SCALAR_STYLE); 
784:        2:  745:        yaml_emitter_emit(emitter, &evt);
785:        -:  746:                    			
786:        4:  747:        yaml_scalar_event_initialize(
787:        -:  748:                        	&evt,
788:        -:  749:                    	    NULL,
789:        -:  750:                    		NULL,
790:        2:  751:                    		(unsigned char *)var-&gt;name,
791:        2:  752:                    		strlen(var-&gt;name),
792:        -:  753:                    		CONF_T,
793:        -:  754:                    		CONF_T, 
794:        -:  755:                    		YAML_PLAIN_SCALAR_STYLE); 	
795:        2:  756:        yaml_emitter_emit(emitter, &evt);
796:        -:  757:       
797:        2:  758:        param_t it = var-&gt;params;
798:        6:  759:        while(it){
799:        4:  760:            yaml_scalar_event_initialize(
800:        -:  761:                        	&evt,
801:        -:  762:                    	    NULL,
802:        -:  763:                    		NULL,
803:        2:  764:                    		(unsigned char *)it-&gt;key,
804:        2:  765:                    		strlen(it-&gt;key),
805:        -:  766:                    		CONF_T,
806:        -:  767:                    		CONF_T, 
807:        -:  768:                    		YAML_PLAIN_SCALAR_STYLE); 
808:        2:  769:            yaml_emitter_emit(emitter, &evt);
809:        -:  770:                    			
810:        4:  771:            yaml_scalar_event_initialize(
811:        -:  772:                        	&evt,
812:        -:  773:                    	    NULL,
813:        -:  774:                    		NULL,
814:        2:  775:                    		(unsigned char *)it-&gt;value,
815:        2:  776:                    		strlen(it-&gt;value),
816:        -:  777:                    		CONF_T,
817:        -:  778:                    		CONF_T, 
818:        -:  779:                    		YAML_PLAIN_SCALAR_STYLE); 	
819:        2:  780:            yaml_emitter_emit(emitter, &evt);
820:        2:  781:            it = it-&gt;next; 
821:        -:  782:        }    
822:        2:  783:        yaml_mapping_end_event_initialize(&evt); 
823:        -:  784:        	
824:        2:  785:        yaml_emitter_emit(emitter, &evt); 
825:        -:  786:    }
826:       96:  787:} 
827:        -:  788:
828:function emit_entry called 50 returned 1000locks executed 97%
829:       50:  789:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
830:       50:  790:    int i = 0;
831:        -:  791:    yaml_event_t evt;
832:        -:  792:     
833:      100:  793:    yaml_scalar_event_initialize(
834:        -:  794:    	&evt,
835:        -:  795:	    NULL,
836:        -:  796:		NULL,
837:       50:  797:		(unsigned char *)entry-&gt;name,
838:       50:  798:		strlen(entry-&gt;name),
839:        -:  799:		CONF_T,
840:        -:  800:		CONF_T, 
841:        -:  801:		YAML_PLAIN_SCALAR_STYLE); 	
842:        -:  802:		
843:       50:  803:	yaml_emitter_emit(emitter, &evt);
844:        -:  804:	//log_yml_event(evt);
845:        -:  805:	char buf[CONF_NUM];
846:       50:  806:	memset(buf, 0, CONF_NUM);
847:       50:  807:	entry_t iter = NULL;
848:       50:  808:	variable_t viter = NULL;
849:        -:  809:	
850:       50:  810:	switch (entry-&gt;type_tag){
851:        -:  811:	
852:        -:  812:		case ENTRY_STR:
853:        -:  813:		
854:       16:  814:			yaml_scalar_event_initialize(
855:        -:  815:    		&evt,
856:        -:  816:	    	NULL,
857:        -:  817:         	NULL,
858:        8:  818:			(unsigned char *)entry-&gt;e.scalar_str,
859:        8:  819:			strlen(entry-&gt;e.scalar_str),
860:        -:  820:			CONF_T,
861:        -:  821:			CONF_T, 
862:        -:  822:			YAML_PLAIN_SCALAR_STYLE); 	
863:        -:  823:		
864:        8:  824:			yaml_emitter_emit(emitter, &evt); 
865:        -:  825:			//log_yml_event(evt);		
866:        8:  826:			break;
867:        -:  827:		
868:        -:  828:		case ENTRY_INT:
869:        -:  829:			
870:       18:  830:			sprintf(buf, "0", entry-&gt;e.scalar_int);
871:       18:  831:			yaml_scalar_event_initialize(
872:        -:  832:    		&evt,
873:        -:  833:	    	NULL,
874:        -:  834:			NULL,
875:        -:  835:			(unsigned char *)buf,
876:       18:  836:			strlen(buf),
877:        -:  837:			CONF_T,
878:        -:  838:			CONF_T, 
879:        -:  839:			YAML_PLAIN_SCALAR_STYLE); 	
880:        -:  840:		
881:       18:  841:			yaml_emitter_emit(emitter, &evt);
882:        -:  842:			//log_yml_event(evt); 		
883:       18:  843:			break;
884:        -:  844:				 
885:        -:  845:		case ENTRY_MAP:
886:        -:  846:		
887:        8:  847:		    yaml_mapping_start_event_initialize(
888:        -:  848:    			&evt,
889:        -:  849:    			NULL,
890:        -:  850:    			NULL,
891:        -:  851:    			CONF_F,
892:        -:  852:    			YAML_BLOCK_MAPPING_STYLE);
893:        -:  853:    	 	    
894:        8:  854:    		yaml_emitter_emit(emitter, &evt);
895:        -:  855:    		//log_yml_event(evt);
896:        8:  856:    		iter = *(entry-&gt;e.conf-&gt;map);
897:        -:  857:    		
898:       38:  858:			while(i &lt; entry-&gt;e.conf-&gt;size){
899:       22:  859:			    if(iter != NULL) {
900:       22:  860:				    emit_entry(iter, emitter);  
901:        -:  861:				}
902:       22:  862:				iter = (entry-&gt;e.conf-&gt;map)[++i];
903:        -:  863:			}	
904:        8:  864:			yaml_mapping_end_event_initialize(&evt); 	
905:        8:  865:    		yaml_emitter_emit(emitter, &evt); 
906:        -:  866:    		//log_yml_event(evt);
907:        8:  867:			break;
908:        -:  868:		
909:        -:  869:		case ENTRY_SEQ:
910:       16:  870:		  yaml_sequence_start_event_initialize(
911:        -:  871:    			&evt,
912:        -:  872:    			NULL,
913:        -:  873:    			NULL,
914:        -:  874:    			CONF_T,
915:        -:  875:    			YAML_BLOCK_SEQUENCE_STYLE);
916:        -:  876:    		//log_yml_event(evt);
917:       16:  877:    	    yaml_emitter_emit(emitter, &evt); 	
918:        -:  878:		//emit size as int
919:        -:  879:		  
920:       16:  880:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
921:       16:  881:			yaml_scalar_event_initialize(
922:        -:  882:    		&evt,
923:        -:  883:	    	NULL,
924:        -:  884:			NULL,
925:        -:  885:			(unsigned char *)buf,
926:       16:  886:			strlen(buf),
927:        -:  887:			CONF_T,
928:        -:  888:			CONF_T, 
929:        -:  889:			YAML_PLAIN_SCALAR_STYLE); 	
930:        -:  890:		
931:       16:  891:			yaml_emitter_emit(emitter, &evt);
932:        -:  892:			//log_yml_event(evt); 		
933:        -:  893:			//emit values as map
934:       16:  894:			viter = entry-&gt;e.seq-&gt;vars;
935:        -:  895:    		
936:       16:  896:    		i = 0;
937:      128:  897:			while(i &lt; entry-&gt;e.seq-&gt;size){
938:       96:  898:			    if(viter != NULL) {
939:       96:  899:				   emit_variable(viter, emitter);
940:        -:  900:				}
941:       96:  901:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
942:        -:  902:			}	
943:        -:  903:			
944:       16:  904:			yaml_sequence_end_event_initialize(&evt); 	
945:       16:  905:    		yaml_emitter_emit(emitter, &evt); 
946:        -:  906:    		//log_yml_event(evt);
947:       16:  907:			break;
948:        -:  908:			
949:<font color=red>    #####:  909:		default:break;</font>
950:        -:  910:	}
951:        -:  911:	
952:       50:  912:}
953:        -:  913:
954:function emit called 2 returned 1000locks executed 100%
955:        2:  914:int emit(yaml_emitter_t *emitter, const config_t conf) {
956:        2:  915:    int r = CONF_OK;     
957:        -:  916:   
958:        -:  917:    yaml_event_t evt;
959:        -:  918:    char val[CONF_STR];
960:        2:  919:    memset(val,0,CONF_STR);
961:        -:  920:    //doc start
962:        2:  921:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, CONF_F); 
963:        2:  922:	yaml_emitter_emit(emitter, &evt); 		
964:        -:  923:   // log_yml_event(evt);
965:        -:  924:    
966:        2:  925:    yaml_mapping_start_event_initialize(
967:        -:  926:    	&evt,
968:        -:  927:    	NULL,
969:        -:  928:    	NULL,
970:        -:  929:    	CONF_F,
971:        -:  930:    	YAML_BLOCK_MAPPING_STYLE);
972:        -:  931:    	 	    
973:        2:  932:    yaml_emitter_emit(emitter, &evt);
974:        -:  933:   // log_yml_event(evt);
975:        -:  934:    
976:        2:  935:    entry_map_t config_map = conf-&gt;map;
977:        2:  936:    entry_t iter = *config_map;
978:        2:  937:    int i = 0;
979:       36:  938:    while(i &lt; conf-&gt;size) {
980:       32:  939:        if(iter != NULL){
981:       28:  940:    	    emit_entry(iter, emitter);
982:        -:  941:    	}
983:       32:  942:    	iter = config_map[++i];
984:        -:  943:    }
985:        -:  944:   
986:        -:  945:    //mapping end
987:        2:  946:    yaml_mapping_end_event_initialize(&evt); 	
988:        2:  947:    yaml_emitter_emit(emitter, &evt); 		
989:        -:  948:    //log_yml_event(evt);
990:        -:  949:    
991:        -:  950:    //doc end
992:        2:  951:    yaml_document_end_event_initialize(&evt,CONF_F);
993:        2:  952:    yaml_emitter_emit(emitter, &evt);
994:        -:  953:    //log_yml_event(evt); 		
995:        2:  954:    yaml_event_delete(&evt); 	
996:        2:  955:    return r;
997:        -:  956:}
998:        -:  957:
999:function save_config_yml called 0 returned 00locks executed 0%
1000:<font color=red>    #####:  958:int save_config_yml(const char * filename, const config_t conf) {</font>
1001:        -:  959:    
1002:        -:  960:    yaml_emitter_t emitter;
1003:        -:  961:    yaml_event_t event;
1004:        -:  962:    
1005:        -:  963:    FILE * fcfg;
1006:        -:  964:    char path[CONF_STR];
1007:<font color=red>    #####:  965:    int r = CONF_OK;</font>
1008:        -:  966:    
1009:<font color=red>    #####:  967:    memset(path, 0, CONF_STR);</font>
1010:<font color=red>    #####:  968:    sprintf(path, "", filename);</font>
1011:        -:  969:
1012:<font color=red>    #####:  970:    if(!yaml_emitter_initialize(&emitter)){</font>
1013:<font color=red>    #####:  971:        return CONF_ERR;    </font>
1014:        -:  972:    }
1015:<font color=red>    #####:  973:    if ((fcfg = fopen(path, "wb"))) {</font>
1016:<font color=red>    #####:  974:         plc_log("Save configuration to  ...", path);</font>
1017:        -:  975:         
1018:<font color=red>    #####:  976:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1019:<font color=red>    #####:  977:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1020:        -:  978:         
1021:<font color=red>    #####:  979:         r = yaml_emitter_emit(&emitter, &event);</font>
1022:        -:  980:         
1023:<font color=red>    #####:  981:         if(r)</font>
1024:<font color=red>    #####:  982:            r = emit(&emitter, conf);</font>
1025:<font color=red>    #####:  983:         if(r){</font>
1026:<font color=red>    #####:  984:            yaml_stream_end_event_initialize(&event);</font>
1027:<font color=red>    #####:  985:            r = yaml_emitter_emit(&emitter, &event);   </font>
1028:        -:  986:         }
1029:        -:  987:            
1030:<font color=red>    #####:  988:         if(r &lt; CONF_OK)</font>
1031:<font color=red>    #####:  989:            plc_log( "Configuration error ");</font>
1032:        -:  990:            
1033:<font color=red>    #####:  991:         fclose(fcfg);</font>
1034:        -:  992:    } else {
1035:<font color=red>    #####:  993:        r = CONF_ERR;</font>
1036:<font color=red>    #####:  994:        plc_log("Could not open file  for write", filename);</font>
1037:        -:  995:    }
1038:<font color=red>    #####:  996:    yaml_emitter_delete(&emitter);</font>
1039:<font color=red>    #####:  997:    return r;</font>
1040:        -:  998:}
1041:        -:  999:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
