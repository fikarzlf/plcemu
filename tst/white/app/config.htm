<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:
 10:function strdup_r called 14 returned 1000locks executed 100%
 11:       14:    5:char * strdup_r(const char * dest, const char * src) {
 12:        -:    6://strdup with realloc
 13:        -:    7:
 14:       14:    8:    char * r = (!dest)?(char *)malloc(sizeof(src)):realloc(dest, sizeof(src));
 15:        -:    9:        
 16:       14:   10:    memset(r, 0, sizeof(src));
 17:       14:   11:    sprintf(r, "", src);
 18:        -:   12:    
 19:       14:   13:    return r;
 20:        -:   14:}
 21:        -:   15:
 22:function yaml_config_error called 0 returned 00locks executed 0%
 23:<font color=red>    #####:   16:static void yaml_config_error(yaml_parser_t parser){</font>
 24:        -:   17:
 25:        -:   18:    //print line
 26:<font color=red>    #####:   19:}</font>
 27:        -:   20:
 28:function yaml_parser_error called 0 returned 00locks executed 0%
 29:<font color=red>    #####:   21:static void yaml_parser_error(yaml_parser_t parser){</font>
 30:        -:   22:
 31:<font color=red>    #####:   23:     switch (parser.error)</font>
 32:        -:   24:     {
 33:        -:   25:        case YAML_MEMORY_ERROR:
 34:<font color=red>    #####:   26:            plc_log( </font>
 35:        -:   27:            "Memory error: Not enough memory for parsing");
 36:<font color=red>    #####:   28:            break;</font>
 37:        -:   29:
 38:        -:   30:        case YAML_READER_ERROR:
 39:<font color=red>    #####:   31:            if (parser.problem_value != -1) {</font>
 40:<font color=red>    #####:   32:                plc_log( </font>
 41:        -:   33:                "Reader error: : #0 at 0", 
 42:        -:   34:                parser.problem,
 43:        -:   35:                parser.problem_value, 
 44:        -:   36:                parser.problem_offset);
 45:        -:   37:            }
 46:        -:   38:            else {
 47:<font color=red>    #####:   39:                plc_log( </font>
 48:        -:   40:                "Reader error:  at 0", 
 49:        -:   41:                parser.problem,
 50:        -:   42:                parser.problem_offset);
 51:        -:   43:            }
 52:<font color=red>    #####:   44:            break;</font>
 53:        -:   45:
 54:        -:   46:        case YAML_SCANNER_ERROR:
 55:<font color=red>    #####:   47:            if (parser.context) {</font>
 56:<font color=red>    #####:   48:                plc_log( </font>
 57:        -:   49:                "Scanner error:  at line 0, column 0"
 58:        -:   50:                        " at line 0, column 0", 
 59:        -:   51:                        parser.context,
 60:<font color=red>    #####:   52:                        parser.context_mark.line+1,</font>
 61:<font color=red>    #####:   53:                        parser.context_mark.column+1,</font>
 62:        -:   54:                        parser.problem, 
 63:<font color=red>    #####:   55:                        parser.problem_mark.line+1,</font>
 64:<font color=red>    #####:   56:                        parser.problem_mark.column+1);</font>
 65:        -:   57:            }
 66:        -:   58:            else {
 67:<font color=red>    #####:   59:                plc_log( </font>
 68:        -:   60:                "Scanner error:  at line 0, column 0",
 69:<font color=red>    #####:   61:                        parser.problem, parser.problem_mark.line+1,</font>
 70:<font color=red>    #####:   62:                        parser.problem_mark.column+1);</font>
 71:        -:   63:            }
 72:<font color=red>    #####:   64:            break;</font>
 73:        -:   65:
 74:        -:   66:        case YAML_PARSER_ERROR:
 75:<font color=red>    #####:   67:            if (parser.context) {</font>
 76:<font color=red>    #####:   68:                plc_log( </font>
 77:        -:   69:                "Parser error:  at line 0, column 0"
 78:        -:   70:                        " at line 0, column 0", 
 79:        -:   71:                        parser.context,
 80:<font color=red>    #####:   72:                        parser.context_mark.line+1,</font>
 81:<font color=red>    #####:   73:                        parser.context_mark.column+1,</font>
 82:        -:   74:                        parser.problem, 
 83:<font color=red>    #####:   75:                        parser.problem_mark.line+1,</font>
 84:<font color=red>    #####:   76:                        parser.problem_mark.column+1);</font>
 85:        -:   77:            }
 86:        -:   78:            else {
 87:<font color=red>    #####:   79:                plc_log( </font>
 88:        -:   80:                "Parser error:  at line 0, column 0",
 89:        -:   81:                        parser.problem, 
 90:<font color=red>    #####:   82:                        parser.problem_mark.line+1,</font>
 91:<font color=red>    #####:   83:                        parser.problem_mark.column+1);</font>
 92:        -:   84:            }
 93:<font color=red>    #####:   85:            break;</font>
 94:        -:   86:
 95:        -:   87:        default:
 96:        -:   88:            /* Couldn't happen. */
 97:<font color=red>    #####:   89:            plc_log( </font>
 98:        -:   90:            "Internal error\n");
 99:<font color=red>    #####:   91:            break;</font>
100:        -:   92:    }
101:<font color=red>    #####:   93:}</font>
102:        -:   94:
103:function new_entry_int called 90 returned 1000locks executed 100%
104:       90:   95:entry_t new_entry_int(int i, char * name) {
105:       90:   96:	entry_t r = (entry_t)malloc(sizeof(struct entry));
106:       90:   97:	r-&gt;type_tag = ENTRY_INT;
107:       90:   98:	r-&gt;name = name;
108:       90:   99:	r-&gt;e.scalar_int = i;
109:        -:  100:
110:       90:  101:	return r;
111:        -:  102:}
112:        -:  103:
113:function new_entry_str called 40 returned 1000locks executed 100%
114:       40:  104:entry_t new_entry_str(char * str, char * name) {
115:        -:  105:
116:       40:  106:	entry_t r = (entry_t)malloc(sizeof(struct entry));
117:       40:  107:	r-&gt;type_tag = ENTRY_STR;
118:       40:  108:	r-&gt;name = name;
119:       40:  109:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
120:       40:  110:    sprintf(r-&gt;e.scalar_str, "", str);
121:       40:  111:	return r;
122:        -:  112:}
123:        -:  113:
124:function new_entry_map called 40 returned 1000locks executed 100%
125:       40:  114:entry_t new_entry_map(config_t map, char * name) {
126:        -:  115:	
127:       40:  116:	entry_t r = (entry_t)malloc(sizeof(struct entry));
128:       40:  117:	r-&gt;type_tag = ENTRY_MAP;
129:       40:  118:	r-&gt;name = name;
130:       40:  119:	r-&gt;e.conf = map;
131:        -:  120:
132:       40:  121:	return r;
133:        -:  122:}
134:        -:  123:
135:function new_entry_seq called 80 returned 1000locks executed 100%
136:       80:  124:entry_t new_entry_seq(sequence_t seq, char * name) {
137:        -:  125:	
138:       80:  126:	entry_t r = (entry_t)malloc(sizeof(struct entry));
139:       80:  127:	r-&gt;type_tag = ENTRY_SEQ;
140:       80:  128:	r-&gt;name = name;
141:       80:  129:	r-&gt;e.seq = seq;
142:        -:  130:
143:       80:  131:	return r;
144:        -:  132:}
145:        -:  133:
146:function new_entry_null called 0 returned 00locks executed 0%
147:<font color=red>    #####:  134:entry_t new_entry_null() {</font>
148:<font color=red>    #####:  135:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
149:<font color=red>    #####:  136:	r-&gt;type_tag = ENTRY_NONE;</font>
150:<font color=red>    #####:  137:	r-&gt;name = "";</font>
151:<font color=red>    #####:  138:	r-&gt;e.scalar_int = 0;</font>
152:        -:  139:
153:<font color=red>    #####:  140:	return r;</font>
154:        -:  141:}
155:        -:  142:
156:function update_entry called 250 returned 1000locks executed 80%
157:      250:  143:config_t update_entry(
158:        -:  144:    unsigned int key, 
159:        -:  145:    const entry_t item,
160:        -:  146:    const config_t conf) {
161:        -:  147:    
162:      500:  148:    if( conf == NULL ||
163:      250:  149:        key &gt;= conf-&gt;size) {
164:        -:  150:    
165:<font color=red>    #####:  151:        return conf;</font>
166:        -:  152:    } else {
167:        -:  153:    
168:      250:  154:        config_t r = conf;
169:      250:  155:        r-&gt;map[key] = item;
170:        -:  156:        
171:      250:  157:        return r;
172:        -:  158:    }
173:        -:  159:}
174:        -:  160:
175:function get_entry called 102 returned 1000locks executed 100%
176:      102:  161:entry_t get_entry(int key, const config_t conf){
177:        -:  162:
178:      102:  163:    if(conf == NULL || 
179:       88:  164:        key &lt; 0 || 
180:       88:  165:        key &gt; conf-&gt;size) {
181:        -:  166:        
182:       14:  167:        return NULL;    
183:        -:  168:    }
184:        -:  169:    
185:       88:  170:    return conf-&gt;map[key];
186:        -:  171:}
187:        -:  172:
188:function get_numeric_entry called 4 returned 1000locks executed 100%
189:        4:  173:int get_numeric_entry(int key, const config_t conf){
190:        4:  174:    entry_t e = get_entry(key, conf);
191:        4:  175:    if(e && e-&gt;type_tag == ENTRY_INT){
192:        -:  176:    
193:        2:  177:        return e-&gt;e.scalar_int;
194:        -:  178:    } else {
195:        -:  179:    
196:        2:  180:        return CONF_ERR;    
197:        -:  181:    } 
198:        -:  182:}
199:        -:  183:
200:function get_string_entry called 4 returned 1000locks executed 100%
201:        4:  184:char * get_string_entry(int key, const config_t conf){
202:        -:  185:    
203:        4:  186:    entry_t e = get_entry(key, conf);
204:        4:  187:    if(e && e-&gt;type_tag == ENTRY_STR){
205:        -:  188:    
206:        2:  189:        return e-&gt;e.scalar_str;
207:        -:  190:    } else {
208:        -:  191:    
209:        2:  192:        return NULL;    
210:        -:  193:    }    
211:        -:  194:}
212:        -:  195:
213:function get_sequence_entry called 4 returned 1000locks executed 83%
214:        4:  196:sequence_t get_sequence_entry(int key, const config_t conf){
215:        4:  197:    entry_t e = get_entry(key, conf);
216:        4:  198:    if(e && e-&gt;type_tag == ENTRY_SEQ){
217:        -:  199:    
218:        4:  200:        return e-&gt;e.seq;
219:        -:  201:    } else {
220:        -:  202:    
221:<font color=red>    #####:  203:        return NULL;    </font>
222:        -:  204:    }    
223:        -:  205:}
224:        -:  206:
225:function get_recursive_entry called 0 returned 00locks executed 0%
226:<font color=red>    #####:  207:config_t get_recursive_entry(int key, const config_t conf){</font>
227:<font color=red>    #####:  208:    entry_t e = get_entry(key, conf);</font>
228:<font color=red>    #####:  209:    if(e && e-&gt;type_tag == ENTRY_MAP){</font>
229:        -:  210:    
230:<font color=red>    #####:  211:        return e-&gt;e.conf;</font>
231:        -:  212:    } else {
232:        -:  213:    
233:<font color=red>    #####:  214:        return NULL;    </font>
234:        -:  215:    }    
235:        -:  216:}
236:        -:  217:
237:        -:  218://TODO: in a c++ impl. this would be a hashmap
238:function new_param called 12 returned 1000locks executed 100%
239:       12:  219:param_t new_param(const char * key, 
240:        -:  220:                     const char * val){
241:        -:  221:    
242:       12:  222:        param_t n = (param_t)malloc(sizeof(struct param));
243:       12:  223:        n-&gt;key = strdup(key);
244:       12:  224:        n-&gt;value = strdup(val);
245:       12:  225:        n-&gt;next = NULL;
246:        -:  226:        
247:       12:  227:        return n;        
248:        -:  228:}
249:        -:  229:
250:function get_param called 10 returned 1000locks executed 100%
251:       10:  230:param_t get_param(const char * key, const param_t params){
252:       10:  231:    param_t it = params;
253:       30:  232:    while(it && key){
254:       16:  233:        if(!strcmp(it-&gt;key, key)){
255:        -:  234:        
256:        6:  235:            return it;
257:        -:  236:        }
258:       10:  237:        it = it-&gt;next;            
259:        -:  238:    }
260:        -:  239:    
261:        4:  240:    return NULL;
262:        -:  241:}
263:        -:  242:
264:function get_param_val called 6 returned 1000locks executed 83%
265:        6:  243:char * get_param_val(const char * key, const param_t params){
266:        6:  244:    param_t it = get_param(key, params);
267:        -:  245:    
268:        6:  246:    return it?it-&gt;value:NULL;
269:        -:  247:}
270:        -:  248:
271:function append_param called 4 returned 1000locks executed 88%
272:        4:  249:param_t append_param(const param_t params, 
273:        -:  250:                     const char * key, 
274:        -:  251:                     const char * val){
275:        -:  252:        
276:        4:  253:    if(params == NULL){
277:        -:  254:        
278:<font color=red>    #####:  255:        return new_param(key, val);</font>
279:        -:  256:    } else {
280:        4:  257:        param_t ret = params;
281:        4:  258:        param_t it = params;
282:       10:  259:        while(it-&gt;next){
283:        2:  260:            it = it-&gt;next;
284:        -:  261:        }
285:        4:  262:        it-&gt;next = new_param(key, val);
286:        -:  263:                
287:        4:  264:        return ret;    
288:        -:  265:    }
289:        -:  266:}
290:        -:  267:
291:function update_param called 12 returned 1000locks executed 78%
292:       12:  268:param_t update_param(const param_t params, 
293:        -:  269:                     const char * key, 
294:        -:  270:                     const char * val){
295:        -:  271:        
296:       12:  272:    if(params == NULL){
297:        -:  273:        
298:        8:  274:        return new_param(key, val);         
299:        -:  275:    } else {
300:        4:  276:        param_t ret = params;
301:        4:  277:        param_t par = get_param(key, params);
302:        4:  278:        if(par){
303:<font color=red>    #####:  279:            par-&gt;value = strdup_r(par-&gt;value, val);</font>
304:        -:  280:        } else {
305:        -:  281:        //FIXME: ..and this is why we need a hashmap.
306:        4:  282:            ret = append_param(ret, key, val);  
307:        -:  283:        } 
308:        4:  284:        return ret;    
309:        -:  285:    }
310:        -:  286:}
311:        -:  287:
312:function get_key called 38 returned 1000locks executed 100%
313:       38:  288:int get_key(const char * name, const config_t where) {
314:       38:  289:     if(where != NULL){
315:        -:  290:    
316:      284:  291:        for(int i = 0; i &lt; where-&gt;size; i++) {
317:      516:  292:            if( where-&gt;map[i] != NULL &&
318:      244:  293:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
319:        -:  294:                
320:       26:  295:                return i;
321:        -:  296:            }
322:        -:  297:        }
323:        -:  298:    }
324:        -:  299:    
325:       12:  300:    return CONF_ERR;  
326:        -:  301:}
327:        -:  302:
328:function new_config called 50 returned 1000locks executed 100%
329:       50:  303:config_t new_config(int size) {
330:       50:  304:    config_t r = (config_t)malloc(sizeof(struct config));
331:       50:  305:	memset(r, 0, sizeof(struct config));
332:       50:  306:	r-&gt;size = size;
333:       50:  307:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
334:       50:  308:    memset(r-&gt;map, 0, size*sizeof(struct entry));
335:        -:  309:    
336:       50:  310:	return r;
337:        -:  311:}
338:        -:  312:
339:function new_sequence called 80 returned 1000locks executed 100%
340:       80:  313:sequence_t new_sequence(int size) {
341:       80:  314:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
342:       80:  315:	memset(r, 0, sizeof(struct sequence));
343:       80:  316:	r-&gt;size = size;
344:       80:  317:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
345:       80:  318:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
346:        -:  319:	
347:       80:  320:	return r;
348:        -:  321:}
349:        -:  322:
350:function clear_config called 4 returned 1000locks executed 100%
351:        4:  323:config_t clear_config(config_t c){
352:        -:  324:
353:        4:  325:    return (config_t)NULL;
354:        -:  326:}
355:        -:  327:
356:function log_yml_event called 132 returned 1000locks executed 88%
357:      132:  328:static int log_yml_event(yaml_event_t event){
358:        -:  329:
359:      132:  330:    switch(event.type){ 
360:        -:  331:    
361:        -:  332:        case YAML_NO_EVENT: 
362:        2:  333:        	plc_log("No event!"); 
363:        2:  334:            break;
364:        -:  335:    /* Stream start/end */
365:        -:  336:        case YAML_STREAM_START_EVENT: 
366:        8:  337:        	plc_log("STREAM START"); 
367:        8:  338:            break;
368:        -:  339:        case YAML_STREAM_END_EVENT: 
369:        8:  340:        	plc_log("STREAM END");   
370:        8:  341:            break;
371:        -:  342:    /* Block delimeters */
372:        -:  343:        case YAML_DOCUMENT_START_EVENT: 
373:        8:  344:        	plc_log("Start Document"); 
374:        8:  345:            break;
375:        -:  346:        case YAML_DOCUMENT_END_EVENT: 
376:        8:  347:        	plc_log("End Document");   
377:        8:  348:            break;
378:        -:  349:        case YAML_SEQUENCE_START_EVENT: 
379:        2:  350:        	plc_log("Start Sequence"); 
380:        2:  351:            break;
381:        -:  352:        case YAML_SEQUENCE_END_EVENT: 
382:        2:  353:        	plc_log("End Sequence");
383:        2:  354:            break;
384:        -:  355:        case YAML_MAPPING_START_EVENT: 
385:       16:  356:        	plc_log("Start Mapping");         
386:       16:  357:            break;
387:        -:  358:        case YAML_MAPPING_END_EVENT: 
388:       16:  359:        	plc_log("End Mapping");      
389:       16:  360:            break;
390:        -:  361:    /* Data */
391:        -:  362:        case YAML_ALIAS_EVENT:  
392:<font color=red>    #####:  363:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
393:<font color=red>    #####:  364:            break;</font>
394:        -:  365:        case YAML_SCALAR_EVENT: 
395:       62:  366:        	plc_log("Got scalar (value )", event.data.scalar.value); 
396:       62:  367:        	break;
397:        -:  368:        default:
398:<font color=red>    #####:  369:            plc_log("default?");</font>
399:        -:  370:    }
400:      132:  371:    return CONF_OK;
401:        -:  372:}
402:        -:  373:
403:function store_value called 26 returned 1000locks executed 85%
404:       26:  374:config_t store_value(
405:        -:  375:            unsigned char key, 
406:        -:  376:            const char * value, 
407:        -:  377:            config_t config){
408:        -:  378:
409:        -:  379:    entry_t e; 
410:       26:  380:    if( config == NULL) {
411:        -:  381:    
412:<font color=red>    #####:  382:        return NULL;</font>
413:        -:  383:    }
414:        -:  384:    
415:       26:  385:    config_t conf = config;
416:       26:  386:    e = get_entry(key, conf);
417:        -:  387:    
418:       26:  388:    if(e == NULL) {
419:        2:  389:        conf-&gt;err = CONF_ERR;
420:        -:  390:        
421:        2:  391:        return conf;
422:        -:  392:    }
423:        -:  393:    
424:       24:  394:    switch(e-&gt;type_tag){
425:        -:  395:         case ENTRY_INT:
426:       16:  396:            e-&gt;e.scalar_int = atoi(value);
427:       16:  397:            break;
428:        -:  398:         
429:        -:  399:         case ENTRY_STR:
430:        -:  400:         
431:        8:  401:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
432:        8:  402:            break;
433:        -:  403:            
434:<font color=red>    #####:  404:         default: return conf;</font>
435:        -:  405:    }        
436:       24:  406:    conf-&gt;map[key] = e;
437:        -:  407:       
438:       24:  408:    return conf;
439:        -:  409:}
440:        -:  410:
441:function store_seq_value called 22 returned 1000locks executed 100%
442:       22:  411:config_t store_seq_value(
443:        -:  412:                    unsigned char seq,
444:        -:  413:                    unsigned char idx,  
445:        -:  414:                    const char * key,
446:        -:  415:                    const char * value, 
447:        -:  416:                    config_t config){
448:        -:  417:                    
449:       22:  418:    config_t conf = config;                
450:       22:  419:    entry_t s = conf-&gt;map[seq];
451:        -:  420:    
452:       22:  421:    if( s == NULL ||
453:       20:  422:        key == NULL || 
454:       18:  423:        value == NULL ||
455:       36:  424:        s-&gt;type_tag != ENTRY_SEQ ||
456:       18:  425:        idx &gt;= s-&gt;e.seq-&gt;size) {
457:        -:  426:        
458:        4:  427:        conf-&gt;err = CONF_ERR;
459:        -:  428:        
460:        4:  429:        return conf;
461:        -:  430:    }            
462:        -:  431:    
463:       54:  432:    variable_t var = &(conf-&gt;map[seq]
464:       18:  433:                            -&gt;e.seq
465:       36:  434:                            -&gt;vars[idx]);
466:        -:  435:    
467:       18:  436:    conf-&gt;map[seq]
468:       18:  437:        -&gt;e.seq
469:       18:  438:        -&gt;vars[idx].index = idx;
470:        -:  439:    
471:       18:  440:    if(!strcmp(key, "ID")){
472:        6:  441:         conf-&gt;map[seq]
473:        6:  442:             -&gt;e.seq
474:        6:  443:             -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
475:        -:  444:    } else {
476:        -:  445:        
477:       12:  446:        conf-&gt;map[seq]
478:       12:  447:            -&gt;e.seq
479:       24:  448:            -&gt;vars[idx].params = update_param(
480:       12:  449:                conf-&gt;map[seq]
481:       12:  450:                    -&gt;e.seq
482:       12:  451:                    -&gt;vars[idx].params,
483:        -:  452:                key,
484:        -:  453:                value);    
485:        -:  454:    }   
486:        -:  455:        
487:       18:  456:    return conf;                       
488:        -:  457:}
489:        -:  458:
490:function resize_sequence called 2 returned 1000locks executed 86%
491:        2:  459:static config_t resize_sequence(config_t config, int sequence, int size){
492:        2:  460:    config_t conf = config;
493:        2:  461:    sequence_t seq = get_sequence_entry(sequence, conf);
494:        2:  462:    if(size &lt;= 0 ||
495:        2:  463:        size &gt; CONF_MAX_SEQ || 
496:        2:  464:        sequence == NULL){
497:<font color=red>    #####:  465:        conf-&gt;err = CONF_ERR;</font>
498:        -:  466:        
499:<font color=red>    #####:  467:        return conf;</font>
500:        -:  468:    }  
501:        2:  469:    seq-&gt;size = size;
502:        2:  470:	seq-&gt;vars = (variable_t)realloc(seq-&gt;vars, size*sizeof(struct variable));
503:        2:  471:	memset(seq-&gt;vars, 0, size*sizeof(struct variable));    
504:        -:  472:        
505:        2:  473:    return conf;
506:        -:  474:}
507:        -:  475:
508:function process_seq_element called 12 returned 1000locks executed 100%
509:       12:  476:static config_t process_seq_element(
510:        -:  477:                   yaml_event_t event,
511:        -:  478:                   int sequence, 
512:        -:  479:                   const char * key,
513:        -:  480:                   int * idx,
514:        -:  481:                   config_t config){
515:        -:  482:    
516:       12:  483:    config_t conf = config;
517:       12:  484:    char * val = (char *)event.data.scalar.value;
518:       12:  485:    long size = 0;
519:       12:  486:    if(key[0] == 0) { //we are not in a map yet
520:        2:  487:        size = strtol(val, NULL, 10);
521:        -:  488:    }
522:       12:  489:    if(size &gt; 0 &&
523:        -:  490:        size &lt; CONF_MAX_SEQ){
524:        2:  491:        conf = resize_sequence(conf, sequence, (int)size);
525:       10:  492:    } else if(!strcmp(key, "INDEX")){
526:        -:  493:                             
527:        2:  494:            *idx = atoi(val);
528:        -:  495:    } else {  
529:        -:  496:                             
530:        8:  497:            conf = store_seq_value(sequence, 
531:        8:  498:                                      *idx, 
532:        -:  499:                                      key, 
533:        -:  500:                                      val, 
534:        -:  501:                                      conf);       
535:        -:  502:    }                      
536:        -:  503:      
537:       12:  504:    return conf;                       
538:        -:  505:}
539:        -:  506:
540:function process_scalar called 16 returned 1000locks executed 100%
541:       16:  507:static config_t process_scalar(
542:        -:  508:                   yaml_event_t event,
543:        -:  509:                   const char * key,
544:        -:  510:                   config_t config){
545:        -:  511:    
546:       16:  512:    config_t conf = config;
547:       16:  513:    char * val = (char *)event.data.scalar.value;
548:        -:  514:               
549:       16:  515:    conf = store_value(
550:       16:  516:                    get_key(key, conf), 
551:        -:  517:                    val, 
552:        -:  518:                    conf);
553:        -:  519:                 
554:       16:  520:    return conf;                       
555:        -:  521:}
556:        -:  522:
557:function process_mapping called 16 returned 1000locks executed 100%
558:       16:  523:static config_t process_mapping(
559:        -:  524:                    const char * key,
560:        -:  525:                    int seq,
561:        -:  526:                    yaml_parser_t *parser,
562:        -:  527:                    config_t config){
563:        -:  528:    
564:       16:  529:    config_t conf = config;                
565:       16:  530:    int k = get_key(key, conf);
566:       16:  531:    entry_t c = get_entry(k, conf);
567:        -:  532:    
568:       22:  533:    if( c != NULL &&
569:        6:  534:        c-&gt;type_tag == ENTRY_MAP) {
570:        -:  535:                    
571:        6:  536:        c-&gt;e.conf = process(
572:        -:  537:                        seq, 
573:        -:  538:                        parser, 
574:        -:  539:                        c-&gt;e.conf);        
575:        6:  540:        conf-&gt;map[k] = c;
576:        -:  541:    } else {
577:        -:  542:                    
578:       10:  543:        conf = process(
579:        -:  544:            seq, 
580:        -:  545:            parser, 
581:        -:  546:            conf);
582:        -:  547:    }
583:        -:  548:    
584:       16:  549:    return conf;    
585:        -:  550:} 
586:        -:  551:
587:function process called 30 returned 1000locks executed 94%
588:       30:  552:config_t process(int sequence, 
589:        -:  553:            yaml_parser_t *parser, 
590:        -:  554:            config_t configuration){
591:        -:  555:             
592:       30:  556:    config_t config = configuration;
593:       30:  557:    unsigned char storage = STORE_KEY;   
594:       30:  558:    int done = CONF_F;
595:        -:  559:    char key[CONF_STR];
596:       30:  560:    int idx = CONF_ERR;
597:        -:  561:    yaml_event_t event;
598:       30:  562:    memset(&event, 0, sizeof(event));
599:       30:  563:    memset(key, 0, CONF_STR);
600:       30:  564:    if(config == NULL) {
601:        -:  565:     
602:        2:  566:        return NULL;
603:        -:  567:     }
604:        -:  568:     
605:       28:  569:     if(parser == NULL) {
606:        2:  570:        config-&gt;err = CONF_ERR;
607:        -:  571:     
608:        2:  572:        return config;
609:        -:  573:     }
610:        -:  574://     || parser-&gt;context == NULL 
611:        -:  575:           
612:      184:  576:     while(done == CONF_F){
613:        -:  577:     
614:      132:  578:        if (!yaml_parser_parse(parser, &event)){   
615:<font color=red>    #####:  579:                yaml_parser_error(*parser);</font>
616:<font color=red>    #####:  580:                config-&gt;err = CONF_ERR;</font>
617:        -:  581:        } else {
618:        -:  582:   
619:      132:  583:            switch(event.type){
620:        -:  584:                case YAML_SCALAR_EVENT: 
621:        -:  585://swap storage to process val after key and vice versa 
622:       62:  586:                    if(storage == STORE_KEY) {
623:        -:  587: 
624:       34:  588:                            memset(key, 0, CONF_STR);
625:       34:  589:                            sprintf(key, "", 
626:       34:  590:                                (char *)event.data.scalar.value);
627:        -:  591:                        
628:       34:  592:                            storage = STORE_VAL;
629:        -:  593:                    } else {
630:       28:  594:                        if(sequence &gt; CONF_ERR) {
631:        -:  595:                    
632:       12:  596:                            config = process_seq_element(
633:        -:  597:                                    event,
634:        -:  598:                                    sequence,
635:        -:  599:                                    key,
636:        -:  600:                                    &idx,
637:        -:  601:                                    config);
638:        -:  602:                        } else {
639:        -:  603:                            
640:       16:  604:                            config = process_scalar(
641:        -:  605:                                    event,
642:        -:  606:                                    key,
643:        -:  607:                                    config);
644:        -:  608:                        }
645:       28:  609:                        storage = STORE_KEY;            
646:        -:  610:                    }
647:       62:  611:                    break;
648:        -:  612:                
649:        -:  613:                case YAML_SEQUENCE_START_EVENT:
650:        -:  614:
651:        2:  615:                    sequence = get_key(key, config);
652:        2:  616:                    memset(key, 0, CONF_STR);
653:        2:  617:                    break;
654:        -:  618:                
655:        -:  619:                case YAML_SEQUENCE_END_EVENT:
656:        -:  620:
657:        2:  621:                    sequence = CONF_ERR;
658:        2:  622:                    break;
659:        -:  623:                
660:        -:  624:                case YAML_MAPPING_START_EVENT:
661:        -:  625:                
662:       16:  626:                    config = process_mapping(
663:        -:  627:                                key,
664:        -:  628:                                sequence,
665:        -:  629:                                parser,
666:        -:  630:                                config); 
667:       16:  631:                    storage = STORE_KEY;            
668:       16:  632:                    break;
669:        -:  633:                    
670:        -:  634:                case YAML_MAPPING_END_EVENT:
671:        -:  635:                case YAML_STREAM_END_EVENT:     
672:        -:  636:                    
673:       24:  637:                    done = CONF_T;
674:       24:  638:                    break;
675:        -:  639:                    
676:        -:  640:                case YAML_NO_EVENT:
677:        2:  641:                    config-&gt;err = CONF_ERR;
678:        2:  642:                    break;    
679:        -:  643:                    
680:       24:  644:                default: break;    
681:        -:  645:            }
682:        -:  646:         }
683:      132:  647:         if(config-&gt;err &lt; CONF_OK) {
684:        2:  648:             done = CONF_T;
685:        2:  649:             plc_log("Could not parse event:");
686:        -:  650:            // log_yml_event(event);
687:        -:  651:         }            
688:      132:  652:         log_yml_event(event);                                  
689:        -:  653:         //yaml_event_delete(&event);   
690:        -:  654:     }
691:        -:  655:     
692:       26:  656:     return config;
693:        -:  657:}
694:        -:  658:             
695:function load_config_yml called 0 returned 00locks executed 0%
696:<font color=red>    #####:  659:config_t load_config_yml(const char * filename, config_t conf) {</font>
697:        -:  660:    yaml_parser_t parser;
698:        -:  661:    
699:        -:  662:    FILE * fcfg;
700:        -:  663:    char path[CONF_STR];
701:        -:  664:
702:<font color=red>    #####:  665:    memset(path, 0, CONF_STR);</font>
703:<font color=red>    #####:  666:    sprintf(path, "", filename);</font>
704:        -:  667:    
705:<font color=red>    #####:  668:    memset(&parser, 0, sizeof(parser));</font>
706:        -:  669:    
707:<font color=red>    #####:  670:    config_t r = conf;</font>
708:        -:  671:    
709:<font color=red>    #####:  672:    if (!yaml_parser_initialize(&parser)) {</font>
710:        -:  673:    
711:<font color=red>    #####:  674:        yaml_parser_error(parser);    </font>
712:        -:  675:    }
713:<font color=red>    #####:  676:    if ((fcfg = fopen(path, "r"))) {</font>
714:<font color=red>    #####:  677:        plc_log("Looking for configuration from  ...", path);</font>
715:<font color=red>    #####:  678:        yaml_parser_set_input_file(&parser, fcfg);</font>
716:<font color=red>    #####:  679:        r = process(CONF_ERR, &parser, conf);</font>
717:<font color=red>    #####:  680:        if(r-&gt;err &lt; CONF_OK)</font>
718:<font color=red>    #####:  681:            plc_log( "Configuration error ");</font>
719:<font color=red>    #####:  682:        fclose(fcfg);</font>
720:        -:  683:    } else {
721:<font color=red>    #####:  684:        r-&gt;err = CONF_ERR;</font>
722:<font color=red>    #####:  685:        plc_log("Could not open file ", filename);</font>
723:        -:  686:    }
724:<font color=red>    #####:  687:    yaml_parser_delete(&parser);</font>
725:<font color=red>    #####:  688:    return r;</font>
726:        -:  689:}
727:        -:  690:
728:function emit_variable called 96 returned 1000locks executed 100%
729:       96:  691:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
730:        -:  692:    yaml_event_t evt;
731:       98:  693:    if(var-&gt;name != NULL &&
732:        2:  694:        var-&gt;name[0]) {
733:        -:  695:       
734:        -:  696:        char idx[4];
735:        2:  697:        memset(idx, 0, 4);
736:        -:  698:    
737:        2:  699:        yaml_mapping_start_event_initialize(
738:        -:  700:    			        &evt,
739:        -:  701:    			        NULL,
740:        -:  702:    			        NULL,
741:        -:  703:    			        CONF_F,
742:        -:  704:    			        YAML_BLOCK_MAPPING_STYLE);
743:        -:  705:    	 	    
744:        2:  706:        yaml_emitter_emit(emitter, &evt);
745:        -:  707:    		//log_yml_event(evt);
746:        -:  708:    		            
747:        2:  709:        yaml_scalar_event_initialize(
748:        -:  710:                        	&evt,
749:        -:  711:                    	    NULL,
750:        -:  712:                    		NULL,
751:        -:  713:                    		"INDEX",
752:        -:  714:                    		5,
753:        -:  715:                    		CONF_T,
754:        -:  716:                    		CONF_T, 
755:        -:  717:                    		YAML_PLAIN_SCALAR_STYLE); 
756:        2:  718:        yaml_emitter_emit(emitter, &evt);
757:        -:  719:                    		
758:        2:  720:        sprintf(idx, "0", var-&gt;index);		
759:        2:  721:        yaml_scalar_event_initialize(
760:        -:  722:                        	&evt,
761:        -:  723:                    	    NULL,
762:        -:  724:                    		NULL,
763:        -:  725:                    		(unsigned char *)idx,
764:        2:  726:                    		strlen(idx),
765:        -:  727:                    		CONF_T,
766:        -:  728:                    		CONF_T, 
767:        -:  729:                    		YAML_PLAIN_SCALAR_STYLE); 	
768:        2:  730:        yaml_emitter_emit(emitter, &evt);
769:        -:  731:    		            
770:        -:  732:   
771:        2:  733:        yaml_scalar_event_initialize(
772:        -:  734:                        	&evt,
773:        -:  735:                    	    NULL,
774:        -:  736:                    		NULL,
775:        -:  737:                    		"ID",
776:        -:  738:                    		2,
777:        -:  739:                    		CONF_T,
778:        -:  740:                    		CONF_T, 
779:        -:  741:                    		YAML_PLAIN_SCALAR_STYLE); 
780:        2:  742:        yaml_emitter_emit(emitter, &evt);
781:        -:  743:                    			
782:        4:  744:        yaml_scalar_event_initialize(
783:        -:  745:                        	&evt,
784:        -:  746:                    	    NULL,
785:        -:  747:                    		NULL,
786:        2:  748:                    		(unsigned char *)var-&gt;name,
787:        2:  749:                    		strlen(var-&gt;name),
788:        -:  750:                    		CONF_T,
789:        -:  751:                    		CONF_T, 
790:        -:  752:                    		YAML_PLAIN_SCALAR_STYLE); 	
791:        2:  753:        yaml_emitter_emit(emitter, &evt);
792:        -:  754:       
793:        2:  755:        param_t it = var-&gt;params;
794:        6:  756:        while(it){
795:        4:  757:            yaml_scalar_event_initialize(
796:        -:  758:                        	&evt,
797:        -:  759:                    	    NULL,
798:        -:  760:                    		NULL,
799:        2:  761:                    		(unsigned char *)it-&gt;key,
800:        2:  762:                    		strlen(it-&gt;key),
801:        -:  763:                    		CONF_T,
802:        -:  764:                    		CONF_T, 
803:        -:  765:                    		YAML_PLAIN_SCALAR_STYLE); 
804:        2:  766:            yaml_emitter_emit(emitter, &evt);
805:        -:  767:                    			
806:        4:  768:            yaml_scalar_event_initialize(
807:        -:  769:                        	&evt,
808:        -:  770:                    	    NULL,
809:        -:  771:                    		NULL,
810:        2:  772:                    		(unsigned char *)it-&gt;value,
811:        2:  773:                    		strlen(it-&gt;value),
812:        -:  774:                    		CONF_T,
813:        -:  775:                    		CONF_T, 
814:        -:  776:                    		YAML_PLAIN_SCALAR_STYLE); 	
815:        2:  777:            yaml_emitter_emit(emitter, &evt);
816:        2:  778:            it = it-&gt;next; 
817:        -:  779:        }    
818:        2:  780:        yaml_mapping_end_event_initialize(&evt); 
819:        -:  781:        	
820:        2:  782:        yaml_emitter_emit(emitter, &evt); 
821:        -:  783:    }
822:       96:  784:} 
823:        -:  785:
824:function emit_entry called 50 returned 1000locks executed 97%
825:       50:  786:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
826:       50:  787:    int i = 0;
827:        -:  788:    yaml_event_t evt;
828:        -:  789:     
829:      100:  790:    yaml_scalar_event_initialize(
830:        -:  791:    	&evt,
831:        -:  792:	    NULL,
832:        -:  793:		NULL,
833:       50:  794:		(unsigned char *)entry-&gt;name,
834:       50:  795:		strlen(entry-&gt;name),
835:        -:  796:		CONF_T,
836:        -:  797:		CONF_T, 
837:        -:  798:		YAML_PLAIN_SCALAR_STYLE); 	
838:        -:  799:		
839:       50:  800:	yaml_emitter_emit(emitter, &evt);
840:        -:  801:	//log_yml_event(evt);
841:        -:  802:	char buf[CONF_NUM];
842:       50:  803:	memset(buf, 0, CONF_NUM);
843:       50:  804:	entry_t iter = NULL;
844:       50:  805:	variable_t viter = NULL;
845:        -:  806:	
846:       50:  807:	switch (entry-&gt;type_tag){
847:        -:  808:	
848:        -:  809:		case ENTRY_STR:
849:        -:  810:		
850:       16:  811:			yaml_scalar_event_initialize(
851:        -:  812:    		&evt,
852:        -:  813:	    	NULL,
853:        -:  814:         	NULL,
854:        8:  815:			(unsigned char *)entry-&gt;e.scalar_str,
855:        8:  816:			strlen(entry-&gt;e.scalar_str),
856:        -:  817:			CONF_T,
857:        -:  818:			CONF_T, 
858:        -:  819:			YAML_PLAIN_SCALAR_STYLE); 	
859:        -:  820:		
860:        8:  821:			yaml_emitter_emit(emitter, &evt); 
861:        -:  822:			//log_yml_event(evt);		
862:        8:  823:			break;
863:        -:  824:		
864:        -:  825:		case ENTRY_INT:
865:        -:  826:			
866:       18:  827:			sprintf(buf, "0", entry-&gt;e.scalar_int);
867:       18:  828:			yaml_scalar_event_initialize(
868:        -:  829:    		&evt,
869:        -:  830:	    	NULL,
870:        -:  831:			NULL,
871:        -:  832:			(unsigned char *)buf,
872:       18:  833:			strlen(buf),
873:        -:  834:			CONF_T,
874:        -:  835:			CONF_T, 
875:        -:  836:			YAML_PLAIN_SCALAR_STYLE); 	
876:        -:  837:		
877:       18:  838:			yaml_emitter_emit(emitter, &evt);
878:        -:  839:			//log_yml_event(evt); 		
879:       18:  840:			break;
880:        -:  841:				 
881:        -:  842:		case ENTRY_MAP:
882:        -:  843:		
883:        8:  844:		    yaml_mapping_start_event_initialize(
884:        -:  845:    			&evt,
885:        -:  846:    			NULL,
886:        -:  847:    			NULL,
887:        -:  848:    			CONF_F,
888:        -:  849:    			YAML_BLOCK_MAPPING_STYLE);
889:        -:  850:    	 	    
890:        8:  851:    		yaml_emitter_emit(emitter, &evt);
891:        -:  852:    		//log_yml_event(evt);
892:        8:  853:    		iter = *(entry-&gt;e.conf-&gt;map);
893:        -:  854:    		
894:       38:  855:			while(i &lt; entry-&gt;e.conf-&gt;size){
895:       22:  856:			    if(iter != NULL) {
896:       22:  857:				    emit_entry(iter, emitter);  
897:        -:  858:				}
898:       22:  859:				iter = (entry-&gt;e.conf-&gt;map)[++i];
899:        -:  860:			}	
900:        8:  861:			yaml_mapping_end_event_initialize(&evt); 	
901:        8:  862:    		yaml_emitter_emit(emitter, &evt); 
902:        -:  863:    		//log_yml_event(evt);
903:        8:  864:			break;
904:        -:  865:		
905:        -:  866:		case ENTRY_SEQ:
906:       16:  867:		  yaml_sequence_start_event_initialize(
907:        -:  868:    			&evt,
908:        -:  869:    			NULL,
909:        -:  870:    			NULL,
910:        -:  871:    			CONF_T,
911:        -:  872:    			YAML_BLOCK_SEQUENCE_STYLE);
912:        -:  873:    		//log_yml_event(evt);
913:       16:  874:    	    yaml_emitter_emit(emitter, &evt); 	
914:        -:  875:		//emit size as int
915:        -:  876:		  
916:       16:  877:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
917:       16:  878:			yaml_scalar_event_initialize(
918:        -:  879:    		&evt,
919:        -:  880:	    	NULL,
920:        -:  881:			NULL,
921:        -:  882:			(unsigned char *)buf,
922:       16:  883:			strlen(buf),
923:        -:  884:			CONF_T,
924:        -:  885:			CONF_T, 
925:        -:  886:			YAML_PLAIN_SCALAR_STYLE); 	
926:        -:  887:		
927:       16:  888:			yaml_emitter_emit(emitter, &evt);
928:        -:  889:			//log_yml_event(evt); 		
929:        -:  890:			//emit values as map
930:       16:  891:			viter = entry-&gt;e.seq-&gt;vars;
931:        -:  892:    		
932:       16:  893:    		i = 0;
933:      128:  894:			while(i &lt; entry-&gt;e.seq-&gt;size){
934:       96:  895:			    if(viter != NULL) {
935:       96:  896:				   emit_variable(viter, emitter);
936:        -:  897:				}
937:       96:  898:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
938:        -:  899:			}	
939:        -:  900:			
940:       16:  901:			yaml_sequence_end_event_initialize(&evt); 	
941:       16:  902:    		yaml_emitter_emit(emitter, &evt); 
942:        -:  903:    		//log_yml_event(evt);
943:       16:  904:			break;
944:        -:  905:			
945:<font color=red>    #####:  906:		default:break;</font>
946:        -:  907:	}
947:        -:  908:	
948:       50:  909:}
949:        -:  910:
950:function emit called 2 returned 1000locks executed 100%
951:        2:  911:int emit(yaml_emitter_t *emitter, const config_t conf) {
952:        2:  912:    int r = CONF_OK;     
953:        -:  913:   
954:        -:  914:    yaml_event_t evt;
955:        -:  915:    char val[CONF_STR];
956:        2:  916:    memset(val,0,CONF_STR);
957:        -:  917:    //doc start
958:        2:  918:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, CONF_F); 
959:        2:  919:	yaml_emitter_emit(emitter, &evt); 		
960:        -:  920:   // log_yml_event(evt);
961:        -:  921:    
962:        2:  922:    yaml_mapping_start_event_initialize(
963:        -:  923:    	&evt,
964:        -:  924:    	NULL,
965:        -:  925:    	NULL,
966:        -:  926:    	CONF_F,
967:        -:  927:    	YAML_BLOCK_MAPPING_STYLE);
968:        -:  928:    	 	    
969:        2:  929:    yaml_emitter_emit(emitter, &evt);
970:        -:  930:   // log_yml_event(evt);
971:        -:  931:    
972:        2:  932:    entry_map_t config_map = conf-&gt;map;
973:        2:  933:    entry_t iter = *config_map;
974:        2:  934:    int i = 0;
975:       36:  935:    while(i &lt; conf-&gt;size) {
976:       32:  936:        if(iter != NULL){
977:       28:  937:    	    emit_entry(iter, emitter);
978:        -:  938:    	}
979:       32:  939:    	iter = config_map[++i];
980:        -:  940:    }
981:        -:  941:   
982:        -:  942:    //mapping end
983:        2:  943:    yaml_mapping_end_event_initialize(&evt); 	
984:        2:  944:    yaml_emitter_emit(emitter, &evt); 		
985:        -:  945:    //log_yml_event(evt);
986:        -:  946:    
987:        -:  947:    //doc end
988:        2:  948:    yaml_document_end_event_initialize(&evt,CONF_F);
989:        2:  949:    yaml_emitter_emit(emitter, &evt);
990:        -:  950:    //log_yml_event(evt); 		
991:        2:  951:    yaml_event_delete(&evt); 	
992:        2:  952:    return r;
993:        -:  953:}
994:        -:  954:
995:function save_config_yml called 0 returned 00locks executed 0%
996:<font color=red>    #####:  955:int save_config_yml(const char * filename, const config_t conf) {</font>
997:        -:  956:    
998:        -:  957:    yaml_emitter_t emitter;
999:        -:  958:    yaml_event_t event;
1000:        -:  959:    
1001:        -:  960:    FILE * fcfg;
1002:        -:  961:    char path[CONF_STR];
1003:<font color=red>    #####:  962:    int r = CONF_OK;</font>
1004:        -:  963:    
1005:<font color=red>    #####:  964:    memset(path, 0, CONF_STR);</font>
1006:<font color=red>    #####:  965:    sprintf(path, "", filename);</font>
1007:        -:  966:
1008:<font color=red>    #####:  967:    if(!yaml_emitter_initialize(&emitter)){</font>
1009:<font color=red>    #####:  968:        return CONF_ERR;    </font>
1010:        -:  969:    }
1011:<font color=red>    #####:  970:    if ((fcfg = fopen(path, "wb"))) {</font>
1012:<font color=red>    #####:  971:         plc_log("Save configuration to  ...", path);</font>
1013:        -:  972:         
1014:<font color=red>    #####:  973:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1015:<font color=red>    #####:  974:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1016:        -:  975:         
1017:<font color=red>    #####:  976:         r = yaml_emitter_emit(&emitter, &event);</font>
1018:        -:  977:         
1019:<font color=red>    #####:  978:         if(r)</font>
1020:<font color=red>    #####:  979:            r = emit(&emitter, conf);</font>
1021:<font color=red>    #####:  980:         if(r){</font>
1022:<font color=red>    #####:  981:            yaml_stream_end_event_initialize(&event);</font>
1023:<font color=red>    #####:  982:            r = yaml_emitter_emit(&emitter, &event);   </font>
1024:        -:  983:         }
1025:        -:  984:            
1026:<font color=red>    #####:  985:         if(r &lt; CONF_OK)</font>
1027:<font color=red>    #####:  986:            plc_log( "Configuration error ");</font>
1028:        -:  987:            
1029:<font color=red>    #####:  988:         fclose(fcfg);</font>
1030:        -:  989:    } else {
1031:<font color=red>    #####:  990:        r = CONF_ERR;</font>
1032:<font color=red>    #####:  991:        plc_log("Could not open file  for write", filename);</font>
1033:        -:  992:    }
1034:<font color=red>    #####:  993:    yaml_emitter_delete(&emitter);</font>
1035:<font color=red>    #####:  994:    return r;</font>
1036:        -:  995:}
1037:        -:  996:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
