<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:#include "plclib.h"
 10:        -:    5:
 11:        -:    6:const char * Config_vars[N_CONFIG_VARIABLES] = {
 12:        -:    7:    "STEP",
 13:        -:    8:    "PIPE",
 14:        -:    9:    "SIGENABLE",
 15:        -:   10:    "PAGELEN",
 16:        -:   11:    "PAGEWIDTH",
 17:        -:   12:    "HW",
 18:        -:   13:    "NT",
 19:        -:   14:    "NS",
 20:        -:   15:    "NR",
 21:        -:   16:    "NM",
 22:        -:   17:    "NDI",
 23:        -:   18:    "NDQ",
 24:        -:   19:    "NAI",
 25:        -:   20:    "NAQ",
 26:        -:   21:    "RESPONSE",
 27:        -:   22:    "USPACE",
 28:        -:   23:    "COMEDI",
 29:        -:   24:    "SIM",
 30:        -:   25:    "IL",
 31:        -:   26:    "LD",
 32:        -:   27:    //sequences
 33:        -:   28:    "AI",
 34:        -:   29:    "AQ",
 35:        -:   30:    "DI",
 36:        -:   31:    "DQ",
 37:        -:   32:    "MVAR",
 38:        -:   33:    "MREG",
 39:        -:   34:    "TIMER",
 40:        -:   35:    "PULSE"
 41:        -:   36:};
 42:        -:   37:
 43:        -:   38:/*
 44:        -:   39:const char * Variable_params[N_VARIABLE_PARAMS] = {
 45:        -:   40:    "INDEX",
 46:        -:   41:    "ID",
 47:        -:   42:    "VALUE",
 48:        -:   43:    "MIN",
 49:        -:   44:    "MAX"
 50:        -:   45:};
 51:        -:   46:*/
 52:function strdup_r called 12 returned 1000locks executed 100%
 53:       12:   47:char * strdup_r(const char * dest, const char * src) {
 54:        -:   48://strdup with realloc
 55:       12:   49:    char * r = (dest == NULL)?(char *)malloc(sizeof(src)):dest;
 56:        -:   50:        
 57:       12:   51:    r = realloc(r, sizeof(src));
 58:       12:   52:    memset(r, 0, sizeof(src));
 59:       12:   53:    sprintf(r, "", src);
 60:        -:   54:    
 61:       12:   55:    return r;
 62:        -:   56:}
 63:        -:   57:
 64:        -:   58:
 65:function yaml_config_error called 0 returned 00locks executed 0%
 66:<font color=red>    #####:   59:static void yaml_config_error(yaml_parser_t parser){</font>
 67:        -:   60:
 68:        -:   61:    //print line
 69:<font color=red>    #####:   62:}</font>
 70:        -:   63:
 71:function yaml_parser_error called 0 returned 00locks executed 0%
 72:<font color=red>    #####:   64:static void yaml_parser_error(yaml_parser_t parser){</font>
 73:        -:   65:
 74:<font color=red>    #####:   66:     switch (parser.error)</font>
 75:        -:   67:     {
 76:        -:   68:        case YAML_MEMORY_ERROR:
 77:<font color=red>    #####:   69:            plc_log( </font>
 78:        -:   70:            "Memory error: Not enough memory for parsing");
 79:<font color=red>    #####:   71:            break;</font>
 80:        -:   72:
 81:        -:   73:        case YAML_READER_ERROR:
 82:<font color=red>    #####:   74:            if (parser.problem_value != -1) {</font>
 83:<font color=red>    #####:   75:                plc_log( </font>
 84:        -:   76:                "Reader error: : #0 at 0", 
 85:        -:   77:                parser.problem,
 86:        -:   78:                parser.problem_value, 
 87:        -:   79:                parser.problem_offset);
 88:        -:   80:            }
 89:        -:   81:            else {
 90:<font color=red>    #####:   82:                plc_log( </font>
 91:        -:   83:                "Reader error:  at 0", 
 92:        -:   84:                parser.problem,
 93:        -:   85:                parser.problem_offset);
 94:        -:   86:            }
 95:<font color=red>    #####:   87:            break;</font>
 96:        -:   88:
 97:        -:   89:        case YAML_SCANNER_ERROR:
 98:<font color=red>    #####:   90:            if (parser.context) {</font>
 99:<font color=red>    #####:   91:                plc_log( </font>
100:        -:   92:                "Scanner error:  at line 0, column 0"
101:        -:   93:                        " at line 0, column 0", 
102:        -:   94:                        parser.context,
103:<font color=red>    #####:   95:                        parser.context_mark.line+1,</font>
104:<font color=red>    #####:   96:                        parser.context_mark.column+1,</font>
105:        -:   97:                        parser.problem, 
106:<font color=red>    #####:   98:                        parser.problem_mark.line+1,</font>
107:<font color=red>    #####:   99:                        parser.problem_mark.column+1);</font>
108:        -:  100:            }
109:        -:  101:            else {
110:<font color=red>    #####:  102:                plc_log( </font>
111:        -:  103:                "Scanner error:  at line 0, column 0",
112:<font color=red>    #####:  104:                        parser.problem, parser.problem_mark.line+1,</font>
113:<font color=red>    #####:  105:                        parser.problem_mark.column+1);</font>
114:        -:  106:            }
115:<font color=red>    #####:  107:            break;</font>
116:        -:  108:
117:        -:  109:        case YAML_PARSER_ERROR:
118:<font color=red>    #####:  110:            if (parser.context) {</font>
119:<font color=red>    #####:  111:                plc_log( </font>
120:        -:  112:                "Parser error:  at line 0, column 0"
121:        -:  113:                        " at line 0, column 0", 
122:        -:  114:                        parser.context,
123:<font color=red>    #####:  115:                        parser.context_mark.line+1,</font>
124:<font color=red>    #####:  116:                        parser.context_mark.column+1,</font>
125:        -:  117:                        parser.problem, 
126:<font color=red>    #####:  118:                        parser.problem_mark.line+1,</font>
127:<font color=red>    #####:  119:                        parser.problem_mark.column+1);</font>
128:        -:  120:            }
129:        -:  121:            else {
130:<font color=red>    #####:  122:                plc_log( </font>
131:        -:  123:                "Parser error:  at line 0, column 0",
132:        -:  124:                        parser.problem, 
133:<font color=red>    #####:  125:                        parser.problem_mark.line+1,</font>
134:<font color=red>    #####:  126:                        parser.problem_mark.column+1);</font>
135:        -:  127:            }
136:<font color=red>    #####:  128:            break;</font>
137:        -:  129:
138:        -:  130:        default:
139:        -:  131:            /* Couldn't happen. */
140:<font color=red>    #####:  132:            plc_log( </font>
141:        -:  133:            "Internal error\n");
142:<font color=red>    #####:  134:            break;</font>
143:        -:  135:    }
144:<font color=red>    #####:  136:}</font>
145:        -:  137:
146:function new_entry_int called 72 returned 1000locks executed 100%
147:       72:  138:static entry_t new_entry_int(int i, char * name) {
148:        -:  139:
149:       72:  140:	entry_t r = (entry_t)malloc(sizeof(struct entry));
150:       72:  141:	r-&gt;type_tag = ENTRY_INT;
151:       72:  142:	r-&gt;name = name;
152:       72:  143:	r-&gt;e.scalar_int = i;
153:        -:  144:
154:       72:  145:	return r;
155:        -:  146:}
156:        -:  147:
157:function new_entry_str called 32 returned 1000locks executed 100%
158:       32:  148:static entry_t new_entry_str(char * str, char * name) {
159:        -:  149:
160:       32:  150:	entry_t r = (entry_t)malloc(sizeof(struct entry));
161:       32:  151:	r-&gt;type_tag = ENTRY_STR;
162:       32:  152:	r-&gt;name = name;
163:       32:  153:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
164:       32:  154:    sprintf(r-&gt;e.scalar_str, "", str);
165:       32:  155:	return r;
166:        -:  156:}
167:        -:  157:
168:function new_entry_map called 32 returned 1000locks executed 100%
169:       32:  158:static entry_t new_entry_map(config_t map, char * name) {
170:        -:  159:	
171:       32:  160:	entry_t r = (entry_t)malloc(sizeof(struct entry));
172:       32:  161:	r-&gt;type_tag = ENTRY_MAP;
173:       32:  162:	r-&gt;name = name;
174:       32:  163:	r-&gt;e.conf = map;
175:        -:  164:
176:       32:  165:	return r;
177:        -:  166:}
178:        -:  167:
179:function new_entry_seq called 64 returned 1000locks executed 100%
180:       64:  168:static entry_t new_entry_seq(sequence_t seq, char * name) {
181:        -:  169:	
182:       64:  170:	entry_t r = (entry_t)malloc(sizeof(struct entry));
183:       64:  171:	r-&gt;type_tag = ENTRY_SEQ;
184:       64:  172:	r-&gt;name = name;
185:       64:  173:	r-&gt;e.seq = seq;
186:        -:  174:
187:       64:  175:	return r;
188:        -:  176:}
189:        -:  177:
190:function new_entry_null called 0 returned 00locks executed 0%
191:<font color=red>    #####:  178:static entry_t new_entry_null() {</font>
192:<font color=red>    #####:  179:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
193:<font color=red>    #####:  180:	r-&gt;type_tag = ENTRY_NONE;</font>
194:<font color=red>    #####:  181:	r-&gt;name = "";</font>
195:<font color=red>    #####:  182:	r-&gt;e.scalar_int = 0;</font>
196:        -:  183:
197:<font color=red>    #####:  184:	return r;</font>
198:        -:  185:}
199:        -:  186:
200:function update_entry called 200 returned 1000locks executed 80%
201:      200:  187:static config_t update_entry(
202:        -:  188:    unsigned int key, 
203:        -:  189:    const entry_t item,
204:        -:  190:    const config_t conf) {
205:        -:  191:    
206:      400:  192:    if( conf == NULL ||
207:      200:  193:        key &gt;= conf-&gt;size) {
208:        -:  194:    
209:<font color=red>    #####:  195:        return conf;</font>
210:        -:  196:    } else {
211:        -:  197:    
212:      200:  198:        config_t r = conf;
213:      200:  199:        r-&gt;map[key] = item;
214:        -:  200:        
215:      200:  201:        return r;
216:        -:  202:    }
217:        -:  203:}
218:        -:  204:
219:function get_entry called 90 returned 1000locks executed 100%
220:       90:  205:entry_t get_entry(int key, const config_t conf){
221:        -:  206:
222:       90:  207:    if(conf == NULL || 
223:       80:  208:        key &lt; 0 || 
224:       80:  209:        key &gt; conf-&gt;size) {
225:        -:  210:        
226:       10:  211:        return NULL;    
227:        -:  212:    }
228:        -:  213:    
229:       80:  214:    return conf-&gt;map[key];
230:        -:  215:}
231:        -:  216:
232:        -:  217:/*
233:        -:  218:int get_var_key(const char * name){
234:        -:  219:    for(int i = 0; i &lt; N_VARIABLE_PARAMS; i++) {
235:        -:  220:        if(!strcmp(name, Variable_params[i])) {
236:        -:  221:            
237:        -:  222:            return i;
238:        -:  223:        }
239:        -:  224:    }
240:        -:  225:    
241:        -:  226:    return PLC_ERR;
242:        -:  227:}
243:        -:  228:*/
244:        -:  229://TODO: in a c++ impl. this would be a hashmap
245:function new_param called 10 returned 1000locks executed 100%
246:       10:  230:param_t new_param(const char * key, 
247:        -:  231:                     const char * val){
248:        -:  232:    
249:       10:  233:        param_t n = (param_t)malloc(sizeof(struct param));
250:       10:  234:        n-&gt;key = strdup(key);
251:       10:  235:        n-&gt;value = strdup(val);
252:       10:  236:        n-&gt;next = NULL;
253:        -:  237:        
254:       10:  238:        return n;        
255:        -:  239:}
256:        -:  240:
257:function get_param called 8 returned 1000locks executed 100%
258:        8:  241:param_t get_param(const char * key, const param_t params){
259:        8:  242:    param_t it = params;
260:       26:  243:    while(it && key){
261:       14:  244:        if(!strcmp(it-&gt;key, key)){
262:        -:  245:        
263:        4:  246:            return it;
264:        -:  247:        }
265:       10:  248:        it = it-&gt;next;            
266:        -:  249:    }
267:        -:  250:    
268:        4:  251:    return NULL;
269:        -:  252:}
270:        -:  253:
271:function get_param_val called 4 returned 1000locks executed 83%
272:        4:  254:char * get_param_val(const char * key, const param_t params){
273:        4:  255:    param_t it = get_param(key, params);
274:        -:  256:    
275:        4:  257:    return it?it-&gt;value:NULL;
276:        -:  258:}
277:        -:  259:
278:function append_param called 4 returned 1000locks executed 88%
279:        4:  260:param_t append_param(const param_t params, 
280:        -:  261:                     const char * key, 
281:        -:  262:                     const char * val){
282:        -:  263:        
283:        4:  264:    if(params == NULL){
284:        -:  265:        
285:<font color=red>    #####:  266:        return new_param(key, val);</font>
286:        -:  267:    } else {
287:        4:  268:        param_t ret = params;
288:        4:  269:        param_t it = params;
289:       10:  270:        while(it-&gt;next){
290:        2:  271:            it = it-&gt;next;
291:        -:  272:        }
292:        4:  273:        it-&gt;next = new_param(key, val);
293:        -:  274:                
294:        4:  275:        return ret;    
295:        -:  276:    }
296:        -:  277:}
297:        -:  278:
298:function update_param called 10 returned 1000locks executed 78%
299:       10:  279:param_t update_param(const param_t params, 
300:        -:  280:                     const char * key, 
301:        -:  281:                     const char * val){
302:        -:  282:        
303:       10:  283:    if(params == NULL){
304:        -:  284:        
305:        6:  285:        return new_param(key, val);         
306:        -:  286:    } else {
307:        4:  287:        param_t ret = params;
308:        4:  288:        param_t par = get_param(key, params);
309:        4:  289:        if(par){
310:<font color=red>    #####:  290:            par-&gt;value = strdup_r(par-&gt;value, val);</font>
311:        -:  291:        } else {
312:        -:  292:        //FIXME: ..and this is why we need a hashmap.
313:        4:  293:            ret = append_param(ret, key, val);  
314:        -:  294:        } 
315:        4:  295:        return ret;    
316:        -:  296:    }
317:        -:  297:}
318:        -:  298:
319:function get_key called 38 returned 1000locks executed 100%
320:       38:  299:int get_key(const char * name, const config_t where) {
321:       38:  300:     if(where != NULL){
322:        -:  301:    
323:      490:  302:        for(int i = 0; i &lt; where-&gt;size; i++) {
324:      710:  303:            if( where-&gt;map[i] != NULL &&
325:      230:  304:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
326:        -:  305:                
327:       28:  306:                return i;
328:        -:  307:            }
329:        -:  308:        }
330:        -:  309:    }
331:        -:  310:    
332:       10:  311:    return PLC_ERR;  
333:        -:  312:}
334:        -:  313:
335:function new_config called 40 returned 1000locks executed 100%
336:       40:  314:config_t new_config(int size) {
337:       40:  315:    config_t r = (config_t)malloc(sizeof(struct config));
338:       40:  316:	memset(r, 0, sizeof(struct config));
339:       40:  317:	r-&gt;size = size;
340:       40:  318:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
341:       40:  319:    memset(r-&gt;map, 0, size*sizeof(struct entry));
342:        -:  320:    
343:       40:  321:	return r;
344:        -:  322:}
345:        -:  323:
346:function new_sequence called 64 returned 1000locks executed 100%
347:       64:  324:sequence_t new_sequence(int size) {
348:       64:  325:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
349:       64:  326:	memset(r, 0, sizeof(struct sequence));
350:       64:  327:	r-&gt;size = size;
351:       64:  328:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
352:       64:  329:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
353:        -:  330:	
354:       64:  331:	return r;
355:        -:  332:}
356:        -:  333:
357:function init_config called 8 returned 1000locks executed 100%
358:        8:  334:config_t init_config(){
359:        -:  335: //TODO: in a c++ implementation this all can be done automatically 
360:        -:  336: //using a hashmap
361:        8:  337:    config_t conf = new_config(N_CONFIG_VARIABLES);
362:        -:  338:   
363:        8:  339:    config_t uspace = new_config(N_USPACE_VARS);
364:        -:  340:        
365:        8:  341:    uspace = update_entry(
366:        -:  342:        USPACE_BASE,
367:        -:  343:	    new_entry_int(50176, "USPACE_BASE"),
368:        -:  344:	    uspace);
369:        -:  345:	
370:        8:  346:	uspace = update_entry(
371:        -:  347:	    USPACE_WR, 
372:        -:  348:	    new_entry_int(0, "USPACE_WR"),
373:        -:  349:	    uspace);
374:        -:  350:	    
375:        8:  351:	uspace = update_entry(
376:        -:  352:	    USPACE_RD, 
377:        -:  353:	    new_entry_int(8, "USPACE_RD"),
378:        -:  354:	    uspace);
379:        -:  355:	
380:        8:  356:	config_t subdev = new_config(N_SUBDEV_VARS);
381:        -:  357:	
382:        8:  358:    subdev = update_entry(
383:        -:  359:        SUBDEV_IN,
384:        -:  360:	    new_entry_int(0, "SUBDEV_IN"),
385:        -:  361:	    subdev);
386:        -:  362:	    
387:        8:  363:	subdev = update_entry(
388:        -:  364:	    SUBDEV_OUT,
389:        -:  365:	    new_entry_int(1, "SUBDEV_OUT"),
390:        -:  366:	    subdev);
391:        -:  367:	    
392:        8:  368:    subdev = update_entry(
393:        -:  369:        SUBDEV_ADC, 
394:        -:  370:	    new_entry_int(2, "SUBDEV_ADC"),
395:        -:  371:	    subdev);
396:        -:  372:	    
397:        8:  373:	subdev = update_entry(
398:        -:  374:	    SUBDEV_DAC, 
399:        -:  375:	    new_entry_int(3, "SUBDEV_DAC"),
400:        -:  376:	    subdev);
401:        -:  377:	
402:        8:  378:	config_t comedi = new_config(N_COMEDI_VARS);
403:        -:  379:	
404:        8:  380:	comedi = update_entry(
405:        -:  381:	    COMEDI_FILE,
406:        -:  382:	    new_entry_int(0, "COMEDI_FILE"),
407:        -:  383:	    comedi);
408:        -:  384:	    
409:        8:  385:	comedi = update_entry(
410:        -:  386:	    COMEDI_SUBDEV, 
411:        -:  387:	    new_entry_map(subdev, "COMEDI_SUBDEV"),
412:        -:  388:	    comedi);
413:        -:  389:    
414:        8:  390:    config_t sim = new_config(N_SIM_VARS);
415:        -:  391:    
416:        8:  392:    sim = update_entry(
417:        -:  393:        SIM_INPUT,
418:        -:  394:        new_entry_str("sim.in", "SIM_INPUT"), 
419:        -:  395:        sim);
420:        -:  396:        
421:        8:  397:    sim = update_entry(
422:        -:  398:        SIM_OUTPUT,
423:        -:  399:        new_entry_str("sim.out", "SIM_OUTPUT"),
424:        -:  400:        sim);    
425:        -:  401:
426:        8:  402:    conf = update_entry(
427:        -:  403:        CONFIG_STEP,
428:        -:  404:        new_entry_int(1, "STEP"),
429:        -:  405:        conf);
430:        -:  406:    
431:        8:  407:    conf = update_entry(
432:        -:  408:        CONFIG_PIPE,
433:        -:  409:        new_entry_str("plcpipe", "PIPE"),
434:        -:  410:        conf);
435:        -:  411:    
436:        8:  412:    conf = update_entry(
437:        -:  413:        CONFIG_HW,
438:        -:  414:        new_entry_str("STDI/O", "HW"),
439:        -:  415:        conf);
440:        -:  416:        
441:        8:  417:    conf = update_entry(
442:        -:  418:        CONFIG_USPACE,
443:        -:  419:        new_entry_map(uspace, "USPACE"),
444:        -:  420:        conf);
445:        -:  421:    
446:        8:  422:    conf = update_entry(
447:        -:  423:        CONFIG_COMEDI,
448:        -:  424:        new_entry_map(comedi, "COMEDI"),
449:        -:  425:        conf);
450:        -:  426:    
451:        8:  427:    conf = update_entry(
452:        -:  428:        CONFIG_SIM,
453:        -:  429:        new_entry_map(sim, "SIM"),
454:        -:  430:        conf);
455:        -:  431:   /*******************************************/
456:        -:  432:   
457:        8:  433:    conf = update_entry(
458:        -:  434:        CONFIG_TIMER,
459:        -:  435:        new_entry_seq(new_sequence(4), "TIMERS"),
460:        -:  436:        conf);
461:        -:  437:    
462:        8:  438:    conf = update_entry(
463:        -:  439:        CONFIG_PULSE,
464:        -:  440:        new_entry_seq(new_sequence(4), "PULSES"),
465:        -:  441:        conf);
466:        -:  442:        
467:        8:  443:    conf = update_entry(
468:        -:  444:        CONFIG_MREG,
469:        -:  445:        new_entry_seq(new_sequence(4), "MREG"),
470:        -:  446:        conf);
471:        -:  447:        
472:        8:  448:    conf = update_entry(
473:        -:  449:        CONFIG_MVAR,
474:        -:  450:        new_entry_seq(new_sequence(4), "MVAR"),
475:        -:  451:        conf);
476:        -:  452:    
477:        8:  453:    conf = update_entry(
478:        -:  454:        CONFIG_DI,
479:        -:  455:        new_entry_seq(new_sequence(8), "DI"),
480:        -:  456:        conf);
481:        -:  457: 
482:        8:  458:    conf = update_entry(
483:        -:  459:        CONFIG_DQ,
484:        -:  460:        new_entry_seq(new_sequence(8), "DQ"),
485:        -:  461:        conf);
486:        -:  462:    
487:        8:  463:    conf = update_entry(
488:        -:  464:        CONFIG_AI,
489:        -:  465:        new_entry_seq(new_sequence(8), "AI"),
490:        -:  466:        conf);
491:        -:  467:    
492:        8:  468:    conf = update_entry(
493:        -:  469:        CONFIG_AQ,
494:        -:  470:        new_entry_seq(new_sequence(8), "AQ"),
495:        -:  471:        conf);
496:        -:  472:
497:        8:  473:    return conf;
498:        -:  474:}
499:        -:  475:
500:function clear_config called 4 returned 1000locks executed 100%
501:        4:  476:config_t clear_config(config_t c){
502:        -:  477:
503:        4:  478:    return (config_t)NULL;
504:        -:  479:}
505:        -:  480:
506:function log_yml_event called 0 returned 00locks executed 0%
507:<font color=red>    #####:  481:static int log_yml_event(yaml_event_t event){</font>
508:        -:  482:
509:<font color=red>    #####:  483:    switch(event.type){ </font>
510:        -:  484:    
511:        -:  485:        case YAML_NO_EVENT: 
512:<font color=red>    #####:  486:        	plc_log("No event!"); </font>
513:<font color=red>    #####:  487:            break;</font>
514:        -:  488:    /* Stream start/end */
515:        -:  489:        case YAML_STREAM_START_EVENT: 
516:<font color=red>    #####:  490:        	plc_log("STREAM START"); </font>
517:<font color=red>    #####:  491:            break;</font>
518:        -:  492:        case YAML_STREAM_END_EVENT: 
519:<font color=red>    #####:  493:        	plc_log("STREAM END");   </font>
520:<font color=red>    #####:  494:            break;</font>
521:        -:  495:    /* Block delimeters */
522:        -:  496:        case YAML_DOCUMENT_START_EVENT: 
523:<font color=red>    #####:  497:        	plc_log("Start Document"); </font>
524:<font color=red>    #####:  498:            break;</font>
525:        -:  499:        case YAML_DOCUMENT_END_EVENT: 
526:<font color=red>    #####:  500:        	plc_log("End Document");   </font>
527:<font color=red>    #####:  501:            break;</font>
528:        -:  502:        case YAML_SEQUENCE_START_EVENT: 
529:<font color=red>    #####:  503:        	plc_log("Start Sequence"); </font>
530:<font color=red>    #####:  504:            break;</font>
531:        -:  505:        case YAML_SEQUENCE_END_EVENT: 
532:<font color=red>    #####:  506:        	plc_log("End Sequence");</font>
533:<font color=red>    #####:  507:            break;</font>
534:        -:  508:        case YAML_MAPPING_START_EVENT: 
535:<font color=red>    #####:  509:        	plc_log("Start Mapping");         </font>
536:<font color=red>    #####:  510:            break;</font>
537:        -:  511:        case YAML_MAPPING_END_EVENT: 
538:<font color=red>    #####:  512:        	plc_log("End Mapping");      </font>
539:<font color=red>    #####:  513:            break;</font>
540:        -:  514:    /* Data */
541:        -:  515:        case YAML_ALIAS_EVENT:  
542:<font color=red>    #####:  516:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
543:<font color=red>    #####:  517:            break;</font>
544:        -:  518:        case YAML_SCALAR_EVENT: 
545:<font color=red>    #####:  519:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
546:<font color=red>    #####:  520:        	break;</font>
547:        -:  521:        default:
548:<font color=red>    #####:  522:            plc_log("default?");</font>
549:        -:  523:    }
550:<font color=red>    #####:  524:    return PLC_OK;</font>
551:        -:  525:}
552:        -:  526:
553:function store_value called 26 returned 1000locks executed 85%
554:       26:  527:config_t store_value(BYTE key, const char * value, config_t config){
555:        -:  528:
556:        -:  529:    entry_t e; 
557:       26:  530:    if( config == NULL) {
558:        -:  531:    
559:<font color=red>    #####:  532:        return NULL;</font>
560:        -:  533:    }
561:        -:  534:    
562:       26:  535:    config_t conf = config;
563:       26:  536:    e = get_entry(key, conf);
564:        -:  537:    
565:       26:  538:    if(e == NULL) {
566:        2:  539:        conf-&gt;err = PLC_ERR;
567:        -:  540:        
568:        2:  541:        return conf;
569:        -:  542:    }
570:        -:  543:    
571:       24:  544:    switch(e-&gt;type_tag){
572:        -:  545:         case ENTRY_INT:
573:       16:  546:            e-&gt;e.scalar_int = atoi(value);
574:       16:  547:            break;
575:        -:  548:         
576:        -:  549:         case ENTRY_STR:
577:        -:  550:         
578:        8:  551:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
579:        8:  552:            break;
580:        -:  553:            
581:<font color=red>    #####:  554:         default: return conf;</font>
582:        -:  555:    }        
583:       24:  556:    conf-&gt;map[key] = e;
584:        -:  557:       
585:       24:  558:    return conf;
586:        -:  559:}
587:        -:  560:
588:function store_seq_value called 18 returned 1000locks executed 100%
589:       18:  561:config_t store_seq_value(BYTE seq,
590:        -:  562:                    BYTE idx,  
591:        -:  563:                    const char * key,
592:        -:  564:                    const char * value, 
593:        -:  565:                    config_t config){
594:        -:  566:                    
595:       18:  567:    config_t conf = config;                
596:       18:  568:    entry_t s = conf-&gt;map[seq];
597:        -:  569:    
598:       18:  570:    if( s == NULL ||
599:       16:  571:        key == NULL || 
600:       14:  572:        value == NULL ||
601:       28:  573:        s-&gt;type_tag != ENTRY_SEQ ||
602:       14:  574:        idx &gt;= s-&gt;e.seq-&gt;size) {
603:        -:  575:        
604:        4:  576:        conf-&gt;err = PLC_ERR;
605:        -:  577:        
606:        4:  578:        return conf;
607:        -:  579:    }            
608:        -:  580:    
609:       42:  581:    variable_t var = &(conf-&gt;map[seq]
610:       14:  582:                            -&gt;e.seq
611:       28:  583:                            -&gt;vars[idx]);
612:        -:  584:    
613:       14:  585:    conf-&gt;map[seq]
614:       14:  586:        -&gt;e.seq
615:       14:  587:        -&gt;vars[idx].index = idx;
616:        -:  588:    
617:       14:  589:    if(!strcmp(key, "ID")){
618:        4:  590:         conf-&gt;map[seq]
619:        4:  591:             -&gt;e.seq
620:        4:  592:             -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
621:        -:  593:    } else {
622:        -:  594:        
623:       10:  595:        conf-&gt;map[seq]
624:       10:  596:            -&gt;e.seq
625:       20:  597:            -&gt;vars[idx].params = update_param(
626:       10:  598:                conf-&gt;map[seq]
627:       10:  599:                    -&gt;e.seq
628:       10:  600:                    -&gt;vars[idx].params,
629:        -:  601:                key,
630:        -:  602:                value);    
631:        -:  603:    }   
632:        -:  604:        
633:       14:  605:    return conf;                       
634:        -:  606:}
635:        -:  607:
636:function process_seq_element called 10 returned 1000locks executed 100%
637:       10:  608:static config_t process_seq_element(
638:        -:  609:                   yaml_event_t event,
639:        -:  610:                   int sequence, 
640:        -:  611:                   const char * key,
641:        -:  612:                   int * idx,
642:        -:  613:                   config_t config){
643:        -:  614:    
644:       10:  615:    config_t conf = config;
645:       10:  616:    char * val = (char *)event.data.scalar.value;
646:        -:  617:                    
647:       10:  618:    if(!strcmp(key, "INDEX")){
648:        -:  619:                             
649:        2:  620:            *idx = atoi(val);
650:        -:  621:    } else {  
651:        -:  622:                             
652:        8:  623:            conf = store_seq_value(sequence, 
653:        8:  624:                                      *idx, 
654:        -:  625:                                      key, 
655:        -:  626:                                      val, 
656:        -:  627:                                      conf);       
657:        -:  628:    }                      
658:        -:  629:      
659:       10:  630:    return conf;                       
660:        -:  631:}
661:        -:  632:
662:function process_scalar called 16 returned 1000locks executed 100%
663:       16:  633:static config_t process_scalar(
664:        -:  634:                   yaml_event_t event,
665:        -:  635:                   const char * key,
666:        -:  636:                   config_t config){
667:        -:  637:    
668:       16:  638:    config_t conf = config;
669:       16:  639:    char * val = (char *)event.data.scalar.value;
670:        -:  640:               
671:       16:  641:    conf = store_value(
672:       16:  642:                    get_key(key, conf), 
673:        -:  643:                    val, 
674:        -:  644:                    conf);
675:        -:  645:                 
676:       16:  646:    return conf;                       
677:        -:  647:}
678:        -:  648:
679:function process_mapping called 16 returned 1000locks executed 100%
680:       16:  649:static config_t process_mapping(
681:        -:  650:                    const char * key,
682:        -:  651:                    int seq,
683:        -:  652:                    yaml_parser_t *parser,
684:        -:  653:                    config_t config){
685:        -:  654:    
686:       16:  655:    config_t conf = config;                
687:       16:  656:    int k = get_key(key, conf);
688:       16:  657:    entry_t c = get_entry(k, conf);
689:        -:  658:    
690:       24:  659:    if( c != NULL &&
691:        8:  660:        c-&gt;type_tag == ENTRY_MAP) {
692:        -:  661:                    
693:        6:  662:        c-&gt;e.conf = process(
694:        -:  663:                        seq, 
695:        -:  664:                        parser, 
696:        -:  665:                        c-&gt;e.conf);        
697:        6:  666:        conf-&gt;map[k] = c;
698:        -:  667:    } else {
699:        -:  668:                    
700:       10:  669:        conf = process(
701:        -:  670:            seq, 
702:        -:  671:            parser, 
703:        -:  672:            conf);
704:        -:  673:    }
705:        -:  674:    
706:       16:  675:    return conf;    
707:        -:  676:} 
708:        -:  677:
709:function process called 30 returned 1000locks executed 94%
710:       30:  678:config_t process(int sequence, 
711:        -:  679:            yaml_parser_t *parser, 
712:        -:  680:            config_t configuration){
713:        -:  681:             
714:       30:  682:    config_t config = configuration;
715:       30:  683:    BYTE storage = STORE_KEY;   
716:       30:  684:    int done = FALSE;
717:        -:  685:    char key[MAXSTR];
718:       30:  686:    int idx = PLC_ERR;
719:        -:  687:    yaml_event_t event;
720:       30:  688:    memset(&event, 0, sizeof(event));
721:       30:  689:    memset(key, 0, MAXSTR);
722:       30:  690:    if(config == NULL) {
723:        -:  691:     
724:        2:  692:        return NULL;
725:        -:  693:     }
726:        -:  694:     
727:       28:  695:     if(parser == NULL) {
728:        2:  696:        config-&gt;err = PLC_ERR;
729:        -:  697:     
730:        2:  698:        return config;
731:        -:  699:     }
732:        -:  700://     || parser-&gt;context == NULL 
733:        -:  701:           
734:      182:  702:     while(done == FALSE){
735:        -:  703:     
736:      130:  704:        if (!yaml_parser_parse(parser, &event)){   
737:<font color=red>    #####:  705:                yaml_parser_error(*parser);</font>
738:<font color=red>    #####:  706:                config-&gt;err = PLC_ERR;</font>
739:        -:  707:        } else {
740:        -:  708:   
741:      130:  709:            switch(event.type){
742:        -:  710:                case YAML_SCALAR_EVENT: 
743:        -:  711://swap storage to process val after key and vice versa 
744:       60:  712:                    if(storage == STORE_KEY) {
745:       34:  713:                        memset(key, 0, MAXSTR);
746:       34:  714:                        sprintf(key, "", 
747:       34:  715:                            (char *)event.data.scalar.value);
748:        -:  716:                        
749:       34:  717:                        storage = STORE_VAL;
750:        -:  718:                    } else {
751:       26:  719:                        if(sequence &gt; PLC_ERR) {
752:        -:  720:                    
753:       10:  721:                            config = process_seq_element(
754:        -:  722:                                    event,
755:        -:  723:                                    sequence,
756:        -:  724:                                    key,
757:        -:  725:                                    &idx,
758:        -:  726:                                    config);
759:        -:  727:                        } else {
760:        -:  728:                            
761:       16:  729:                            config = process_scalar(
762:        -:  730:                                    event,
763:        -:  731:                                    key,
764:        -:  732:                                    config);
765:        -:  733:                        }
766:       26:  734:                        storage = STORE_KEY;            
767:        -:  735:                    }
768:       60:  736:                    break;
769:        -:  737:                
770:        -:  738:                case YAML_SEQUENCE_START_EVENT:
771:        -:  739:
772:        2:  740:                    sequence = get_key(key, config);
773:        2:  741:                    break;
774:        -:  742:                
775:        -:  743:                case YAML_SEQUENCE_END_EVENT:
776:        -:  744:
777:        2:  745:                    sequence = PLC_ERR;
778:        2:  746:                    break;
779:        -:  747:                
780:        -:  748:                case YAML_MAPPING_START_EVENT:
781:        -:  749:                
782:       16:  750:                    config = process_mapping(
783:        -:  751:                                key,
784:        -:  752:                                sequence,
785:        -:  753:                                parser,
786:        -:  754:                                config); 
787:       16:  755:                    storage = STORE_KEY;            
788:       16:  756:                    break;
789:        -:  757:                    
790:        -:  758:                case YAML_MAPPING_END_EVENT:
791:        -:  759:                case YAML_STREAM_END_EVENT:     
792:        -:  760:                    
793:       24:  761:                    done = TRUE;
794:       24:  762:                    break;
795:        -:  763:                    
796:        -:  764:                case YAML_NO_EVENT:
797:        2:  765:                    config-&gt;err = PLC_ERR;
798:        2:  766:                    break;    
799:        -:  767:                    
800:       24:  768:                default: break;    
801:        -:  769:            }
802:        -:  770:         }
803:      130:  771:         if(config-&gt;err &lt; PLC_OK) {
804:        2:  772:             done = TRUE;
805:        -:  773:             //log_yml_event(event);
806:        -:  774:         }                                              
807:      130:  775:         yaml_event_delete(&event);   
808:        -:  776:     }
809:        -:  777:     
810:       26:  778:     return config;
811:        -:  779:}
812:        -:  780:             
813:function load_config_yml called 0 returned 00locks executed 0%
814:<font color=red>    #####:  781:config_t load_config_yml(const char * filename, config_t conf) {</font>
815:        -:  782:    yaml_parser_t parser;
816:        -:  783:    
817:        -:  784:    FILE * fcfg;
818:        -:  785:    char path[MAXSTR];
819:        -:  786:
820:<font color=red>    #####:  787:    memset(path, 0, MAXSTR);</font>
821:<font color=red>    #####:  788:    sprintf(path, "", filename);</font>
822:        -:  789:    
823:<font color=red>    #####:  790:    memset(&parser, 0, sizeof(parser));</font>
824:        -:  791:    
825:<font color=red>    #####:  792:    config_t r = conf;</font>
826:        -:  793:    
827:<font color=red>    #####:  794:    if (!yaml_parser_initialize(&parser)) {</font>
828:        -:  795:    
829:<font color=red>    #####:  796:        yaml_parser_error(parser);    </font>
830:        -:  797:    }
831:<font color=red>    #####:  798:    if ((fcfg = fopen(path, "r"))) {</font>
832:<font color=red>    #####:  799:        plc_log("Looking for configuration from  ...", path);</font>
833:<font color=red>    #####:  800:        yaml_parser_set_input_file(&parser, fcfg);</font>
834:<font color=red>    #####:  801:        r = process(PLC_ERR, &parser, conf);</font>
835:<font color=red>    #####:  802:        if(r-&gt;err &lt; PLC_OK)</font>
836:<font color=red>    #####:  803:            plc_log( "Configuration error ");</font>
837:<font color=red>    #####:  804:        fclose(fcfg);</font>
838:        -:  805:    } else {
839:<font color=red>    #####:  806:        r-&gt;err = PLC_ERR;</font>
840:<font color=red>    #####:  807:        plc_log("Could not open file ", filename);</font>
841:        -:  808:    }
842:<font color=red>    #####:  809:    yaml_parser_delete(&parser);</font>
843:<font color=red>    #####:  810:    return r;</font>
844:        -:  811:}
845:        -:  812:
846:function emit_variable called 96 returned 1000locks executed 100%
847:       96:  813:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
848:        -:  814:    yaml_event_t evt;
849:       98:  815:    if(var-&gt;name != NULL &&
850:        2:  816:        var-&gt;name[0]) {
851:        -:  817:       
852:        -:  818:        char idx[4];
853:        2:  819:        memset(idx, 0, 4);
854:        -:  820:    
855:        2:  821:        yaml_mapping_start_event_initialize(
856:        -:  822:    			        &evt,
857:        -:  823:    			        NULL,
858:        -:  824:    			        NULL,
859:        -:  825:    			        FALSE,
860:        -:  826:    			        YAML_BLOCK_MAPPING_STYLE);
861:        -:  827:    	 	    
862:        2:  828:        yaml_emitter_emit(emitter, &evt);
863:        -:  829:    		//log_yml_event(evt);
864:        -:  830:    		            
865:        2:  831:        yaml_scalar_event_initialize(
866:        -:  832:                        	&evt,
867:        -:  833:                    	    NULL,
868:        -:  834:                    		NULL,
869:        -:  835:                    		"INDEX",
870:        -:  836:                    		5,
871:        -:  837:                    		TRUE,
872:        -:  838:                    		TRUE, 
873:        -:  839:                    		YAML_PLAIN_SCALAR_STYLE); 
874:        2:  840:        yaml_emitter_emit(emitter, &evt);
875:        -:  841:                    		
876:        2:  842:        sprintf(idx, "0", var-&gt;index);		
877:        2:  843:        yaml_scalar_event_initialize(
878:        -:  844:                        	&evt,
879:        -:  845:                    	    NULL,
880:        -:  846:                    		NULL,
881:        -:  847:                    		(unsigned char *)idx,
882:        2:  848:                    		strlen(idx),
883:        -:  849:                    		TRUE,
884:        -:  850:                    		TRUE, 
885:        -:  851:                    		YAML_PLAIN_SCALAR_STYLE); 	
886:        2:  852:        yaml_emitter_emit(emitter, &evt);
887:        -:  853:    		            
888:        -:  854:   
889:        2:  855:        yaml_scalar_event_initialize(
890:        -:  856:                        	&evt,
891:        -:  857:                    	    NULL,
892:        -:  858:                    		NULL,
893:        -:  859:                    		"ID",
894:        -:  860:                    		2,
895:        -:  861:                    		TRUE,
896:        -:  862:                    		TRUE, 
897:        -:  863:                    		YAML_PLAIN_SCALAR_STYLE); 
898:        2:  864:        yaml_emitter_emit(emitter, &evt);
899:        -:  865:                    			
900:        4:  866:        yaml_scalar_event_initialize(
901:        -:  867:                        	&evt,
902:        -:  868:                    	    NULL,
903:        -:  869:                    		NULL,
904:        2:  870:                    		(unsigned char *)var-&gt;name,
905:        2:  871:                    		strlen(var-&gt;name),
906:        -:  872:                    		TRUE,
907:        -:  873:                    		TRUE, 
908:        -:  874:                    		YAML_PLAIN_SCALAR_STYLE); 	
909:        2:  875:        yaml_emitter_emit(emitter, &evt);
910:        -:  876:       
911:        2:  877:        param_t it = var-&gt;params;
912:        6:  878:        while(it){
913:        4:  879:            yaml_scalar_event_initialize(
914:        -:  880:                        	&evt,
915:        -:  881:                    	    NULL,
916:        -:  882:                    		NULL,
917:        2:  883:                    		(unsigned char *)it-&gt;key,
918:        2:  884:                    		strlen(it-&gt;key),
919:        -:  885:                    		TRUE,
920:        -:  886:                    		TRUE, 
921:        -:  887:                    		YAML_PLAIN_SCALAR_STYLE); 
922:        2:  888:            yaml_emitter_emit(emitter, &evt);
923:        -:  889:                    			
924:        4:  890:            yaml_scalar_event_initialize(
925:        -:  891:                        	&evt,
926:        -:  892:                    	    NULL,
927:        -:  893:                    		NULL,
928:        2:  894:                    		(unsigned char *)it-&gt;value,
929:        2:  895:                    		strlen(it-&gt;value),
930:        -:  896:                    		TRUE,
931:        -:  897:                    		TRUE, 
932:        -:  898:                    		YAML_PLAIN_SCALAR_STYLE); 	
933:        2:  899:            yaml_emitter_emit(emitter, &evt);
934:        2:  900:            it = it-&gt;next; 
935:        -:  901:        }    
936:        2:  902:        yaml_mapping_end_event_initialize(&evt); 
937:        -:  903:        	
938:        2:  904:        yaml_emitter_emit(emitter, &evt); 
939:        -:  905:    }
940:       96:  906:} 
941:        -:  907:
942:function emit_entry called 50 returned 1000locks executed 97%
943:       50:  908:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
944:       50:  909:    int i = 0;
945:        -:  910:    yaml_event_t evt;
946:        -:  911:     
947:      100:  912:    yaml_scalar_event_initialize(
948:        -:  913:    	&evt,
949:        -:  914:	    NULL,
950:        -:  915:		NULL,
951:       50:  916:		(unsigned char *)entry-&gt;name,
952:       50:  917:		strlen(entry-&gt;name),
953:        -:  918:		TRUE,
954:        -:  919:		TRUE, 
955:        -:  920:		YAML_PLAIN_SCALAR_STYLE); 	
956:        -:  921:		
957:       50:  922:	yaml_emitter_emit(emitter, &evt);
958:        -:  923:	//log_yml_event(evt);
959:        -:  924:	char buf[TINYBUF];
960:       50:  925:	memset(buf, 0, TINYBUF);
961:       50:  926:	entry_t iter = NULL;
962:       50:  927:	variable_t viter = NULL;
963:        -:  928:	
964:       50:  929:	switch (entry-&gt;type_tag){
965:        -:  930:	
966:        -:  931:		case ENTRY_STR:
967:        -:  932:		
968:       16:  933:			yaml_scalar_event_initialize(
969:        -:  934:    		&evt,
970:        -:  935:	    	NULL,
971:        -:  936:         	NULL,
972:        8:  937:			(unsigned char *)entry-&gt;e.scalar_str,
973:        8:  938:			strlen(entry-&gt;e.scalar_str),
974:        -:  939:			TRUE,
975:        -:  940:			TRUE, 
976:        -:  941:			YAML_PLAIN_SCALAR_STYLE); 	
977:        -:  942:		
978:        8:  943:			yaml_emitter_emit(emitter, &evt); 
979:        -:  944:			//log_yml_event(evt);		
980:        8:  945:			break;
981:        -:  946:		
982:        -:  947:		case ENTRY_INT:
983:        -:  948:			
984:       18:  949:			sprintf(buf, "0", entry-&gt;e.scalar_int);
985:       18:  950:			yaml_scalar_event_initialize(
986:        -:  951:    		&evt,
987:        -:  952:	    	NULL,
988:        -:  953:			NULL,
989:        -:  954:			(unsigned char *)buf,
990:       18:  955:			strlen(buf),
991:        -:  956:			TRUE,
992:        -:  957:			TRUE, 
993:        -:  958:			YAML_PLAIN_SCALAR_STYLE); 	
994:        -:  959:		
995:       18:  960:			yaml_emitter_emit(emitter, &evt);
996:        -:  961:			//log_yml_event(evt); 		
997:       18:  962:			break;
998:        -:  963:				 
999:        -:  964:		case ENTRY_MAP:
1000:        -:  965:		
1001:        8:  966:		    yaml_mapping_start_event_initialize(
1002:        -:  967:    			&evt,
1003:        -:  968:    			NULL,
1004:        -:  969:    			NULL,
1005:        -:  970:    			FALSE,
1006:        -:  971:    			YAML_BLOCK_MAPPING_STYLE);
1007:        -:  972:    	 	    
1008:        8:  973:    		yaml_emitter_emit(emitter, &evt);
1009:        -:  974:    		//log_yml_event(evt);
1010:        8:  975:    		iter = *(entry-&gt;e.conf-&gt;map);
1011:        -:  976:    		
1012:       38:  977:			while(i &lt; entry-&gt;e.conf-&gt;size){
1013:       22:  978:			    if(iter != NULL) {
1014:       22:  979:				    emit_entry(iter, emitter);  
1015:        -:  980:				}
1016:       22:  981:				iter = (entry-&gt;e.conf-&gt;map)[++i];
1017:        -:  982:			}	
1018:        8:  983:			yaml_mapping_end_event_initialize(&evt); 	
1019:        8:  984:    		yaml_emitter_emit(emitter, &evt); 
1020:        -:  985:    		//log_yml_event(evt);
1021:        8:  986:			break;
1022:        -:  987:		
1023:        -:  988:		case ENTRY_SEQ:
1024:       16:  989:		  yaml_sequence_start_event_initialize(
1025:        -:  990:    			&evt,
1026:        -:  991:    			NULL,
1027:        -:  992:    			NULL,
1028:        -:  993:    			TRUE,
1029:        -:  994:    			YAML_BLOCK_SEQUENCE_STYLE);
1030:        -:  995:    		//log_yml_event(evt);
1031:       16:  996:    	    yaml_emitter_emit(emitter, &evt); 	
1032:        -:  997:		//emit size as int
1033:        -:  998:		  
1034:       16:  999:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
1035:       16: 1000:			yaml_scalar_event_initialize(
1036:        -: 1001:    		&evt,
1037:        -: 1002:	    	NULL,
1038:        -: 1003:			NULL,
1039:        -: 1004:			(unsigned char *)buf,
1040:       16: 1005:			strlen(buf),
1041:        -: 1006:			TRUE,
1042:        -: 1007:			TRUE, 
1043:        -: 1008:			YAML_PLAIN_SCALAR_STYLE); 	
1044:        -: 1009:		
1045:       16: 1010:			yaml_emitter_emit(emitter, &evt);
1046:        -: 1011:			//log_yml_event(evt); 		
1047:        -: 1012:			//emit values as map
1048:       16: 1013:			viter = entry-&gt;e.seq-&gt;vars;
1049:        -: 1014:    		
1050:       16: 1015:    		i = 0;
1051:      128: 1016:			while(i &lt; entry-&gt;e.seq-&gt;size){
1052:       96: 1017:			    if(viter != NULL) {
1053:       96: 1018:				   emit_variable(viter, emitter);
1054:        -: 1019:				}
1055:       96: 1020:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
1056:        -: 1021:			}	
1057:        -: 1022:			
1058:       16: 1023:			yaml_sequence_end_event_initialize(&evt); 	
1059:       16: 1024:    		yaml_emitter_emit(emitter, &evt); 
1060:        -: 1025:    		//log_yml_event(evt);
1061:       16: 1026:			break;
1062:        -: 1027:			
1063:<font color=red>    #####: 1028:		default:break;</font>
1064:        -: 1029:	}
1065:        -: 1030:	
1066:       50: 1031:}
1067:        -: 1032:
1068:function emit called 2 returned 1000locks executed 100%
1069:        2: 1033:int emit(yaml_emitter_t *emitter, const config_t conf) {
1070:        2: 1034:    int r = PLC_OK;     
1071:        -: 1035:   
1072:        -: 1036:    yaml_event_t evt;
1073:        -: 1037:    char val[MAXSTR];
1074:        2: 1038:    memset(val,0,MAXSTR);
1075:        -: 1039:    //doc start
1076:        2: 1040:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, FALSE); 
1077:        2: 1041:	yaml_emitter_emit(emitter, &evt); 		
1078:        -: 1042:   // log_yml_event(evt);
1079:        -: 1043:    
1080:        2: 1044:    yaml_mapping_start_event_initialize(
1081:        -: 1045:    	&evt,
1082:        -: 1046:    	NULL,
1083:        -: 1047:    	NULL,
1084:        -: 1048:    	FALSE,
1085:        -: 1049:    	YAML_BLOCK_MAPPING_STYLE);
1086:        -: 1050:    	 	    
1087:        2: 1051:    yaml_emitter_emit(emitter, &evt);
1088:        -: 1052:   // log_yml_event(evt);
1089:        -: 1053:    
1090:        2: 1054:    entry_map_t config_map = conf-&gt;map;
1091:        2: 1055:    entry_t iter = *config_map;
1092:        2: 1056:    int i = 0;
1093:       60: 1057:    while(i &lt; N_CONFIG_VARIABLES) {
1094:       56: 1058:        if(iter != NULL){
1095:       28: 1059:    	    emit_entry(iter, emitter);
1096:        -: 1060:    	}
1097:       56: 1061:    	iter = config_map[++i];
1098:        -: 1062:    }
1099:        -: 1063:   
1100:        -: 1064:    //mapping end
1101:        2: 1065:    yaml_mapping_end_event_initialize(&evt); 	
1102:        2: 1066:    yaml_emitter_emit(emitter, &evt); 		
1103:        -: 1067:    //log_yml_event(evt);
1104:        -: 1068:    
1105:        -: 1069:    //doc end
1106:        2: 1070:    yaml_document_end_event_initialize(&evt,FALSE);
1107:        2: 1071:    yaml_emitter_emit(emitter, &evt);
1108:        -: 1072:    //log_yml_event(evt); 		
1109:        2: 1073:    yaml_event_delete(&evt); 	
1110:        2: 1074:    return r;
1111:        -: 1075:}
1112:        -: 1076:
1113:function save_config_yml called 0 returned 00locks executed 0%
1114:<font color=red>    #####: 1077:int save_config_yml(const char * filename, const config_t conf) {</font>
1115:        -: 1078:    
1116:        -: 1079:    yaml_emitter_t emitter;
1117:        -: 1080:    yaml_event_t event;
1118:        -: 1081:    
1119:        -: 1082:    FILE * fcfg;
1120:        -: 1083:    char path[MAXSTR];
1121:<font color=red>    #####: 1084:    int r = PLC_OK;</font>
1122:        -: 1085:    
1123:<font color=red>    #####: 1086:    memset(path, 0, MAXSTR);</font>
1124:<font color=red>    #####: 1087:    sprintf(path, "", filename);</font>
1125:        -: 1088:
1126:<font color=red>    #####: 1089:    if(!yaml_emitter_initialize(&emitter)){</font>
1127:<font color=red>    #####: 1090:        return PLC_ERR;    </font>
1128:        -: 1091:    }
1129:<font color=red>    #####: 1092:    if ((fcfg = fopen(path, "wb"))) {</font>
1130:<font color=red>    #####: 1093:         plc_log("Save configuration to  ...", path);</font>
1131:        -: 1094:         
1132:<font color=red>    #####: 1095:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1133:<font color=red>    #####: 1096:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1134:        -: 1097:         
1135:<font color=red>    #####: 1098:         r = yaml_emitter_emit(&emitter, &event);</font>
1136:        -: 1099:         
1137:<font color=red>    #####: 1100:         if(r)</font>
1138:<font color=red>    #####: 1101:            r = emit(&emitter, conf);</font>
1139:<font color=red>    #####: 1102:         if(r){</font>
1140:<font color=red>    #####: 1103:            yaml_stream_end_event_initialize(&event);</font>
1141:<font color=red>    #####: 1104:            r = yaml_emitter_emit(&emitter, &event);   </font>
1142:        -: 1105:         }
1143:        -: 1106:            
1144:<font color=red>    #####: 1107:         if(r &lt; PLC_OK)</font>
1145:<font color=red>    #####: 1108:            plc_log( "Configuration error ");</font>
1146:        -: 1109:            
1147:<font color=red>    #####: 1110:         fclose(fcfg);</font>
1148:        -: 1111:    } else {
1149:<font color=red>    #####: 1112:        r = PLC_ERR;</font>
1150:<font color=red>    #####: 1113:        plc_log("Could not open file  for write", filename);</font>
1151:        -: 1114:    }
1152:<font color=red>    #####: 1115:    yaml_emitter_delete(&emitter);</font>
1153:<font color=red>    #####: 1116:    return r;</font>
1154:        -: 1117:}
1155:        -: 1118:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
