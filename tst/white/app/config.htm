<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "plclib.h"
  9:        -:    4:#include "config.h"
 10:        -:    5:
 11:        -:    6:const char * Config_vars[N_CONFIG_VARIABLES] = {
 12:        -:    7:    "STEP",
 13:        -:    8:    "PIPE",
 14:        -:    9:    "SIGENABLE",
 15:        -:   10:    "PAGELEN",
 16:        -:   11:    "PAGEWIDTH",
 17:        -:   12:    "HW",
 18:        -:   13:    "NT",
 19:        -:   14:    "NS",
 20:        -:   15:    "NR",
 21:        -:   16:    "NM",
 22:        -:   17:    "NDI",
 23:        -:   18:    "NDQ",
 24:        -:   19:    "NAI",
 25:        -:   20:    "NAQ",
 26:        -:   21:    "RESPONSE",
 27:        -:   22:    "USPACE",
 28:        -:   23:    "USPACE_BASE",
 29:        -:   24:    "USPACE_WR",
 30:        -:   25:    "USPACE_RD",
 31:        -:   26:    "COMEDI",
 32:        -:   27:    "COMEDI_FILE",
 33:        -:   28:    "COMEDI_SUBDEV",
 34:        -:   29:    "SUBDEV_IN",
 35:        -:   30:    "SUBDEV_OUT",
 36:        -:   31:    "SUBDEV_ADC",
 37:        -:   32:    "SUBDEV_DAC",
 38:        -:   33:    "SIM",
 39:        -:   34:    "SIM_INPUT",
 40:        -:   35:    "SIM_OUTPUT",
 41:        -:   36:    "IL",
 42:        -:   37:    "LD",
 43:        -:   38:    //sequences
 44:        -:   39:    "AI",
 45:        -:   40:    "AQ",
 46:        -:   41:    "DI",
 47:        -:   42:    "DQ",
 48:        -:   43:    "MVAR",
 49:        -:   44:    "MREG",
 50:        -:   45:    "TIMER",
 51:        -:   46:    "PULSE"
 52:        -:   47:};
 53:        -:   48:
 54:        -:   49:const char * Variable_params[N_VARIABLE_PARAMS] = {
 55:        -:   50:
 56:        -:   51:    "INDEX",
 57:        -:   52:    "ID",
 58:        -:   53:    "VALUE",
 59:        -:   54:    "MIN",
 60:        -:   55:    "MAX"
 61:        -:   56:};
 62:        -:   57:
 63:function yaml_config_error called 0 returned 00locks executed 0%
 64:<font color=red>    #####:   58:void yaml_config_error(yaml_parser_t parser){</font>
 65:        -:   59:
 66:        -:   60:    //print line
 67:<font color=red>    #####:   61:}</font>
 68:        -:   62:
 69:function yaml_parser_error called 1 returned 1000locks executed 22%
 70:        1:   63:void yaml_parser_error(yaml_parser_t parser){
 71:        -:   64:
 72:        1:   65:     switch (parser.error)
 73:        -:   66:     {
 74:        -:   67:        case YAML_MEMORY_ERROR:
 75:<font color=red>    #####:   68:            plc_log( </font>
 76:        -:   69:            "Memory error: Not enough memory for parsing");
 77:<font color=red>    #####:   70:            break;</font>
 78:        -:   71:
 79:        -:   72:        case YAML_READER_ERROR:
 80:<font color=red>    #####:   73:            if (parser.problem_value != -1) {</font>
 81:<font color=red>    #####:   74:                plc_log( </font>
 82:        -:   75:                "Reader error: : #0 at 0", 
 83:        -:   76:                parser.problem,
 84:        -:   77:                parser.problem_value, 
 85:        -:   78:                parser.problem_offset);
 86:        -:   79:            }
 87:        -:   80:            else {
 88:<font color=red>    #####:   81:                plc_log( </font>
 89:        -:   82:                "Reader error:  at 0", 
 90:        -:   83:                parser.problem,
 91:        -:   84:                parser.problem_offset);
 92:        -:   85:            }
 93:<font color=red>    #####:   86:            break;</font>
 94:        -:   87:
 95:        -:   88:        case YAML_SCANNER_ERROR:
 96:<font color=red>    #####:   89:            if (parser.context) {</font>
 97:<font color=red>    #####:   90:                plc_log( </font>
 98:        -:   91:                "Scanner error:  at line 0, column 0"
 99:        -:   92:                        " at line 0, column 0", 
100:        -:   93:                        parser.context,
101:<font color=red>    #####:   94:                        parser.context_mark.line+1,</font>
102:<font color=red>    #####:   95:                        parser.context_mark.column+1,</font>
103:        -:   96:                        parser.problem, 
104:<font color=red>    #####:   97:                        parser.problem_mark.line+1,</font>
105:<font color=red>    #####:   98:                        parser.problem_mark.column+1);</font>
106:        -:   99:            }
107:        -:  100:            else {
108:<font color=red>    #####:  101:                plc_log( </font>
109:        -:  102:                "Scanner error:  at line 0, column 0",
110:<font color=red>    #####:  103:                        parser.problem, parser.problem_mark.line+1,</font>
111:<font color=red>    #####:  104:                        parser.problem_mark.column+1);</font>
112:        -:  105:            }
113:<font color=red>    #####:  106:            break;</font>
114:        -:  107:
115:        -:  108:        case YAML_PARSER_ERROR:
116:<font color=red>    #####:  109:            if (parser.context) {</font>
117:<font color=red>    #####:  110:                plc_log( </font>
118:        -:  111:                "Parser error:  at line 0, column 0"
119:        -:  112:                        " at line 0, column 0", 
120:        -:  113:                        parser.context,
121:<font color=red>    #####:  114:                        parser.context_mark.line+1,</font>
122:<font color=red>    #####:  115:                        parser.context_mark.column+1,</font>
123:        -:  116:                        parser.problem, 
124:<font color=red>    #####:  117:                        parser.problem_mark.line+1,</font>
125:<font color=red>    #####:  118:                        parser.problem_mark.column+1);</font>
126:        -:  119:            }
127:        -:  120:            else {
128:<font color=red>    #####:  121:                plc_log( </font>
129:        -:  122:                "Parser error:  at line 0, column 0",
130:        -:  123:                        parser.problem, 
131:<font color=red>    #####:  124:                        parser.problem_mark.line+1,</font>
132:<font color=red>    #####:  125:                        parser.problem_mark.column+1);</font>
133:        -:  126:            }
134:<font color=red>    #####:  127:            break;</font>
135:        -:  128:
136:        -:  129:        default:
137:        -:  130:            /* Couldn't happen. */
138:        1:  131:            plc_log( 
139:        -:  132:            "Internal error\n");
140:        1:  133:            break;
141:        -:  134:    }
142:        1:  135:}
143:        -:  136:
144:function config_timer_vars called 12 returned 1000locks executed 100%
145:       12:  137:void config_timer_vars(BYTE n, config_t * conf){
146:        -:  138:
147:       12:  139:    (*conf)-&gt;nt = n;
148:       12:  140:    if((*conf)-&gt;timers != NULL){
149:        2:  141:        free((*conf)-&gt;timers);
150:        2:  142:        (*conf)-&gt;timers = NULL;
151:        -:  143:    }    
152:       12:  144:    (*conf)-&gt;timers = (variable_t )malloc(n * sizeof(struct variable));
153:       12:  145:}
154:        -:  146:
155:function config_pulse_vars called 12 returned 1000locks executed 100%
156:       12:  147:void config_pulse_vars(BYTE n, config_t * conf){
157:        -:  148:
158:       12:  149:    (*conf)-&gt;ns = n;
159:       12:  150:    if((*conf)-&gt;pulses != NULL){
160:        2:  151:        free((*conf)-&gt;pulses);
161:        2:  152:        (*conf)-&gt;pulses = NULL;
162:        -:  153:    }    
163:       12:  154:    (*conf)-&gt;pulses = (variable_t )malloc(n * sizeof(struct variable));
164:       12:  155:}
165:        -:  156:
166:function config_mem_vars called 12 returned 1000locks executed 100%
167:       12:  157:void config_mem_vars(BYTE n, config_t * conf){
168:        -:  158:
169:       12:  159:    (*conf)-&gt;nr = n;
170:       12:  160:    if((*conf)-&gt;mvars != NULL){
171:        2:  161:        free((*conf)-&gt;mvars);
172:        2:  162:        (*conf)-&gt;mvars = NULL;
173:        -:  163:    }    
174:       12:  164:    (*conf)-&gt;mvars = (variable_t )malloc(n * sizeof(struct variable));
175:       12:  165:}
176:        -:  166:
177:function config_reg_vars called 12 returned 1000locks executed 100%
178:       12:  167:void config_reg_vars(BYTE n, config_t * conf){
179:        -:  168:
180:       12:  169:    (*conf)-&gt;nm = n;
181:       12:  170:    if((*conf)-&gt;mregs != NULL){
182:        2:  171:        free((*conf)-&gt;mregs);
183:        2:  172:        (*conf)-&gt;mregs = NULL;
184:        -:  173:    }    
185:       12:  174:    (*conf)-&gt;mregs = (variable_t )malloc(n * sizeof(struct variable));
186:       12:  175:}
187:        -:  176:
188:function config_di_vars called 12 returned 1000locks executed 100%
189:       12:  177:void config_di_vars(BYTE n, config_t * conf){
190:        -:  178:
191:       12:  179:    (*conf)-&gt;di = n;
192:       12:  180:    if((*conf)-&gt;dinps != NULL){
193:        2:  181:        free((*conf)-&gt;dinps);
194:        2:  182:        (*conf)-&gt;dinps = NULL;
195:        -:  183:    }    
196:       12:  184:    (*conf)-&gt;dinps = (variable_t )malloc(n * sizeof(struct variable));
197:       12:  185:}
198:        -:  186:
199:function config_dq_vars called 12 returned 1000locks executed 100%
200:       12:  187:void config_dq_vars(BYTE n, config_t * conf){
201:        -:  188:
202:       12:  189:    (*conf)-&gt;dq = n;
203:       12:  190:    if((*conf)-&gt;douts != NULL){
204:        2:  191:        free((*conf)-&gt;douts);
205:        2:  192:        (*conf)-&gt;douts = NULL;
206:        -:  193:    }    
207:       12:  194:    (*conf)-&gt;douts = (variable_t )malloc(n * sizeof(struct variable));
208:       12:  195:}
209:        -:  196:
210:function config_ai_vars called 12 returned 1000locks executed 100%
211:       12:  197:void config_ai_vars(BYTE n, config_t * conf){
212:        -:  198:
213:       12:  199:    (*conf)-&gt;ai = n;
214:       12:  200:    if((*conf)-&gt;ainps != NULL){
215:        2:  201:        free((*conf)-&gt;ainps);
216:        2:  202:        (*conf)-&gt;ainps = NULL;
217:        -:  203:    }    
218:       12:  204:    (*conf)-&gt;ainps = (variable_t )malloc(n * sizeof(struct variable));
219:       12:  205:}
220:        -:  206:
221:function config_aq_vars called 12 returned 1000locks executed 100%
222:       12:  207:void config_aq_vars(BYTE n, config_t * conf){
223:        -:  208:
224:       12:  209:    (*conf)-&gt;aq = n;
225:       12:  210:    if((*conf)-&gt;aouts != NULL){
226:        2:  211:        free((*conf)-&gt;aouts);
227:        2:  212:        (*conf)-&gt;aouts = NULL;
228:        -:  213:    }    
229:       12:  214:    (*conf)-&gt;aouts = (variable_t )malloc(n * sizeof(struct variable));
230:        -:  215:
231:       12:  216:}
232:        -:  217:
233:function init_config called 10 returned 1000locks executed 100%
234:       10:  218:config_t init_config(){
235:        -:  219: 
236:       10:  220:    config_t conf = (config_t)malloc(sizeof(struct config));
237:       10:  221:    memset(conf, 0, sizeof(struct config));
238:        -:  222://registers    
239:       10:  223:    config_timer_vars(4, &conf);
240:       10:  224:    config_pulse_vars(4, &conf);
241:        -:  225:    
242:       10:  226:    config_reg_vars(4, &conf);
243:        -:  227:    
244:       10:  228:    config_mem_vars(4, &conf);
245:        -:  229:    
246:       10:  230:    config_di_vars(8, &conf);
247:        -:  231:    
248:       10:  232:    config_dq_vars(8, &conf);
249:        -:  233:    
250:       10:  234:    config_ai_vars(4, &conf);
251:        -:  235:    
252:       10:  236:    config_aq_vars(4, &conf);
253:        -:  237:    
254:        -:  238://ui    
255:       10:  239:    conf-&gt;sigenable = 36;
256:       10:  240:    conf-&gt;page_width = 80;
257:       10:  241:    conf-&gt;page_len = 24;
258:        -:  242://hardware
259:       10:  243:    sprintf(conf-&gt;hw, "", "STDI/O"); //simulation is default    
260:       10:  244:    conf-&gt;base = ADVANTECH_HISTORICAL_BASE;
261:       10:  245:    conf-&gt;wr_offs = 0;
262:       10:  246:    conf-&gt;rd_offs = 8;
263:       10:  247:    conf-&gt;comedi_file = 0;
264:       10:  248:    conf-&gt;comedi_subdev_i = 0;
265:       10:  249:    conf-&gt;comedi_subdev_q = 1;
266:       10:  250:    conf-&gt;comedi_subdev_ai = 2;
267:       10:  251:    conf-&gt;comedi_subdev_aq = 3;
268:        -:  252://polling    
269:       10:  253:    conf-&gt;step = 1;
270:       10:  254:    sprintf(conf-&gt;pipe, "", "plcpipe");
271:       10:  255:    return conf;
272:        -:  256:}
273:        -:  257:
274:function clear_config called 6 returned 1000locks executed 100%
275:        6:  258:void clear_config(config_t *c){
276:        -:  259:
277:        6:  260:    if (*c != NULL){
278:        6:  261:        if((*c)-&gt;aouts != NULL){
279:        6:  262:            free((*c)-&gt;aouts);
280:        6:  263:            (*c)-&gt;aouts = NULL;
281:        -:  264:        }
282:        6:  265:        if((*c)-&gt;ainps != NULL){
283:        6:  266:            free((*c)-&gt;ainps);
284:        6:  267:            (*c)-&gt;ainps = NULL; 
285:        -:  268:        }
286:        6:  269:        if((*c)-&gt;douts != NULL){
287:        6:  270:            free((*c)-&gt;douts);
288:        6:  271:            (*c)-&gt;douts = NULL;
289:        -:  272:        }    
290:        6:  273:        if((*c)-&gt;dinps != NULL){
291:        6:  274:            free((*c)-&gt;dinps);
292:        6:  275:            (*c)-&gt;dinps = NULL;
293:        -:  276:        }
294:        6:  277:        if((*c)-&gt;mvars != NULL){
295:        6:  278:            free((*c)-&gt;mvars);
296:        6:  279:            (*c)-&gt;mvars = NULL;
297:        -:  280:        }    
298:        6:  281:        if((*c)-&gt;mregs != NULL){
299:        6:  282:            free((*c)-&gt;mregs);
300:        6:  283:            (*c)-&gt;mregs = NULL;
301:        -:  284:        }
302:        6:  285:        if((*c)-&gt;timers != NULL){
303:        6:  286:            free((*c)-&gt;timers);
304:        6:  287:            (*c)-&gt;timers = NULL;
305:        -:  288:        }
306:        6:  289:        if((*c)-&gt;pulses != NULL){
307:        6:  290:            free((*c)-&gt;pulses);
308:        6:  291:            (*c)-&gt;pulses = NULL;
309:        -:  292:        }
310:        6:  293:        free(*c);
311:        -:  294:    }
312:        6:  295:    *c = NULL;    
313:        6:  296:}
314:        -:  297:
315:function log_yml_event called 2 returned 1000locks executed 19%
316:        2:  298:int log_yml_event(yaml_event_t event){
317:        -:  299:
318:        2:  300:    switch(event.type){ 
319:        -:  301:    
320:        -:  302:        case YAML_NO_EVENT: 
321:        2:  303:        	plc_log("No event!"); 
322:        2:  304:            break;
323:        -:  305:    /* Stream start/end */
324:        -:  306:        case YAML_STREAM_START_EVENT: 
325:<font color=red>    #####:  307:        	plc_log("STREAM START"); </font>
326:<font color=red>    #####:  308:            break;</font>
327:        -:  309:        case YAML_STREAM_END_EVENT: 
328:<font color=red>    #####:  310:        	plc_log("STREAM END");   </font>
329:<font color=red>    #####:  311:            break;</font>
330:        -:  312:    /* Block delimeters */
331:        -:  313:        case YAML_DOCUMENT_START_EVENT: 
332:<font color=red>    #####:  314:        	plc_log("Start Document"); </font>
333:<font color=red>    #####:  315:            break;</font>
334:        -:  316:        case YAML_DOCUMENT_END_EVENT: 
335:<font color=red>    #####:  317:        	plc_log("End Document");   </font>
336:<font color=red>    #####:  318:            break;</font>
337:        -:  319:        case YAML_SEQUENCE_START_EVENT: 
338:<font color=red>    #####:  320:        	plc_log("Start Sequence"); </font>
339:<font color=red>    #####:  321:            break;</font>
340:        -:  322:        case YAML_SEQUENCE_END_EVENT: 
341:<font color=red>    #####:  323:        	plc_log("End Sequence");</font>
342:<font color=red>    #####:  324:            break;</font>
343:        -:  325:        case YAML_MAPPING_START_EVENT: 
344:<font color=red>    #####:  326:        	plc_log("Start Mapping");         </font>
345:<font color=red>    #####:  327:            break;</font>
346:        -:  328:        case YAML_MAPPING_END_EVENT: 
347:<font color=red>    #####:  329:        	plc_log("End Mapping");      </font>
348:<font color=red>    #####:  330:            break;</font>
349:        -:  331:    /* Data */
350:        -:  332:        case YAML_ALIAS_EVENT:  
351:<font color=red>    #####:  333:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
352:<font color=red>    #####:  334:            break;</font>
353:        -:  335:        case YAML_SCALAR_EVENT: 
354:<font color=red>    #####:  336:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
355:<font color=red>    #####:  337:        	break;</font>
356:        -:  338:        default:
357:<font color=red>    #####:  339:            plc_log("default?");</font>
358:        -:  340:    }
359:        2:  341:    return PLC_OK;
360:        -:  342:}
361:        -:  343:
362:function store_value called 66 returned 1000locks executed 100%
363:       66:  344:int store_value(BYTE key, const char * value, config_t * c){
364:       66:  345:    switch(key){
365:        -:  346:        case CONFIG_HW:
366:        4:  347:            strncpy((*c)-&gt;hw, value, MAXSTR);
367:        4:  348:            break;
368:        -:  349:        case CONFIG_PIPE:
369:        2:  350:            strncpy((*c)-&gt;pipe, value, MAXSTR);
370:        2:  351:            break;    
371:        -:  352:        case CONFIG_STEP:
372:        4:  353:            (*c)-&gt;step = atol(value);
373:        4:  354:            break;
374:        -:  355:        case CONFIG_USPACE_BASE:
375:        2:  356:            (*c)-&gt;base = atol(value);
376:        2:  357:            break;
377:        -:  358:        case CONFIG_USPACE_WR:
378:        2:  359:            (*c)-&gt;wr_offs = atoi(value);
379:        2:  360:            break;
380:        -:  361:        case CONFIG_USPACE_RD:
381:        2:  362:            (*c)-&gt;rd_offs = atoi(value);
382:        2:  363:            break;                
383:        -:  364:        case CONFIG_COMEDI_FILE:
384:        4:  365:            (*c)-&gt;comedi_file = atoi(value);
385:        4:  366:            break;
386:        -:  367:        case CONFIG_SUBDEV_IN:
387:        4:  368:            (*c)-&gt;comedi_subdev_i = atol(value);
388:        4:  369:            break;
389:        -:  370:        case CONFIG_SUBDEV_OUT:
390:        4:  371:            (*c)-&gt;comedi_subdev_q = atol(value);
391:        4:  372:            break;
392:        -:  373:        case CONFIG_SUBDEV_ADC:
393:        4:  374:            (*c)-&gt;comedi_subdev_ai = atoi(value);
394:        4:  375:            break;
395:        -:  376:        case CONFIG_SUBDEV_DAC:
396:        4:  377:            (*c)-&gt;comedi_subdev_aq = atoi(value);
397:        4:  378:            break;                    
398:        -:  379:        case CONFIG_SIM_INPUT:
399:        4:  380:            strncpy((*c)-&gt;sim_in_file, value, MAXSTR);
400:        4:  381:            break;
401:        -:  382:        case CONFIG_SIM_OUTPUT:
402:        4:  383:            strncpy((*c)-&gt;sim_out_file, value, MAXSTR);
403:        4:  384:            break;
404:        -:  385:            
405:        -:  386:        case CONFIG_PROGRAM_IL:
406:        -:  387:        case CONFIG_PROGRAM_LD:
407:        4:  388:            strncpy((*c)-&gt;program_file, value, MAXSTR);
408:        4:  389:            break;  
409:        -:  390:            
410:        -:  391:        case CONFIG_NT:
411:        2:  392:            config_timer_vars(atoi(value), c);
412:        2:  393:            break;                
413:        -:  394:        case CONFIG_NS:
414:        2:  395:            config_pulse_vars(atoi(value), c);
415:        2:  396:            break;
416:        -:  397:        case CONFIG_NM:
417:        2:  398:            config_reg_vars(atoi(value), c);
418:        2:  399:            break;
419:        -:  400:        case CONFIG_NR:
420:        2:  401:            config_mem_vars(atoi(value), c);
421:        2:  402:            break;
422:        -:  403:        case CONFIG_NDI:
423:        2:  404:            config_di_vars(atoi(value), c);
424:        2:  405:            break;
425:        -:  406:        case CONFIG_NDQ:
426:        2:  407:            config_dq_vars(atoi(value), c);
427:        2:  408:            break;                    
428:        -:  409:        case CONFIG_NAI:
429:        2:  410:            config_ai_vars(atoi(value), c);
430:        2:  411:            break;
431:        -:  412:        case CONFIG_NAQ:
432:        2:  413:            config_aq_vars(atoi(value), c);
433:        2:  414:            break;                    
434:        2:  415:        default: return PLC_ERR;
435:        -:  416:    }
436:       64:  417:    return PLC_OK;
437:        -:  418:}
438:        -:  419:
439:function store_seq_value called 20 returned 1000locks executed 67%
440:       20:  420:int store_seq_value(BYTE seq,
441:        -:  421:                    BYTE idx, 
442:        -:  422:                    BYTE key, 
443:        -:  423:                    const char * value, 
444:        -:  424:                    config_t * c){
445:        -:  425:                    
446:        -:  426:    variable_t vars;
447:       20:  427:    switch(seq) {
448:        -:  428:        case SEQ_AI:
449:        8:  429:            vars = (*c)-&gt;ainps;
450:        8:  430:            if(idx &gt;= (*c)-&gt;ai)
451:<font color=red>    #####:  431:                return PLC_ERR;</font>
452:        8:  432:            break;
453:        -:  433:        case SEQ_AQ:
454:        2:  434:            vars = (*c)-&gt;aouts;
455:        2:  435:            if(idx &gt;= (*c)-&gt;aq)
456:<font color=red>    #####:  436:                return PLC_ERR;</font>
457:        2:  437:            break;    
458:        -:  438:        case SEQ_DI:
459:        2:  439:            vars = (*c)-&gt;dinps;
460:        2:  440:            if(idx &gt;= (*c)-&gt;di)
461:<font color=red>    #####:  441:                return PLC_ERR;</font>
462:        2:  442:            break;
463:        -:  443:        case SEQ_DQ:
464:        2:  444:            vars = (*c)-&gt;douts;
465:        2:  445:            if(idx &gt;= (*c)-&gt;dq)
466:        2:  446:                return PLC_ERR;
467:<font color=red>    #####:  447:            break;   </font>
468:        -:  448:        case SEQ_MVAR:
469:        2:  449:            vars = (*c)-&gt;mvars;
470:        2:  450:            if(idx &gt;= (*c)-&gt;nr)
471:<font color=red>    #####:  451:                return PLC_ERR;</font>
472:        2:  452:            break;
473:        -:  453:        case SEQ_MREG:
474:<font color=red>    #####:  454:            vars = (*c)-&gt;mregs;</font>
475:<font color=red>    #####:  455:            if(idx &gt;= (*c)-&gt;nr)</font>
476:<font color=red>    #####:  456:                return PLC_ERR;</font>
477:<font color=red>    #####:  457:            break;    </font>
478:        -:  458:        case SEQ_TIMER:
479:        2:  459:            vars = (*c)-&gt;timers;
480:        2:  460:            if(idx &gt;= (*c)-&gt;nt)
481:<font color=red>    #####:  461:                return PLC_ERR;</font>
482:        2:  462:            break;
483:        -:  463:        case SEQ_PULSE:
484:<font color=red>    #####:  464:            vars = (*c)-&gt;pulses;</font>
485:<font color=red>    #####:  465:            if(idx &gt;= (*c)-&gt;ns)</font>
486:<font color=red>    #####:  466:                return PLC_ERR;</font>
487:<font color=red>    #####:  467:            break;         </font>
488:        -:  468:        
489:        -:  469:        default:
490:        2:  470:            return PLC_ERR;
491:        -:  471:    }
492:       16:  472:    switch(key) {
493:        -:  473:        case VARIABLE_INDEX: 
494:        2:  474:            vars[idx].index = atoi(value);
495:        2:  475:            break;
496:        -:  476:        case VARIABLE_ID: 
497:        4:  477:            strncpy(vars[idx].name, value, MAXSTR);
498:        4:  478:            break;
499:        -:  479:        case VARIABLE_VALUE: 
500:        2:  480:            strncpy(vars[idx].value, value, MAXSTR);
501:        2:  481:            break;
502:        -:  482:        case VARIABLE_MAX: 
503:        4:  483:            strncpy(vars[idx].max, value, MAXSTR);
504:        4:  484:            break; 
505:        -:  485:        case VARIABLE_MIN: 
506:        2:  486:            strncpy(vars[idx].min, value, MAXSTR);
507:        2:  487:            break;            
508:        -:  488:        default: 
509:        2:  489:            return PLC_ERR;    
510:        -:  490:    }    
511:       14:  491:    return PLC_OK;                       
512:        -:  492:}
513:        -:  493:
514:function find_config_var called 32 returned 1000locks executed 86%
515:       32:  494:int find_config_var(const char *name, 
516:        -:  495:                    const char **where, 
517:        -:  496:                    unsigned int size){
518:        -:  497:
519:      580:  498:    for(int i = 0; i &lt; size; i++)
520:      580:  499:        if(!strcmp(name, where[i]))
521:       32:  500:            return i;
522:<font color=red>    #####:  501:    return PLC_ERR;        </font>
523:        -:  502:}
524:        -:  503:
525:function process_scalar called 56 returned 1000locks executed 95%
526:       56:  504:int process_scalar(const unsigned char *value,
527:        -:  505:                   BYTE is_seq,  
528:        -:  506:                   config_t *conf, 
529:        -:  507:                   BYTE *storage, 
530:        -:  508:                   int *key,
531:        -:  509:                   int *seq,
532:        -:  510:                   int *idx){
533:        -:  511:                   
534:       56:  512:    int ret = PLC_OK;
535:        -:  513:    
536:       56:  514:    if(*storage == STORE_KEY){
537:       32:  515:        if(is_seq)
538:        8:  516:            *key = find_config_var(
539:        -:  517:                (char *)value, 
540:        -:  518:                Variable_params,
541:        -:  519:                N_VARIABLE_PARAMS);
542:        -:  520:        else{         
543:       24:  521:            *key = find_config_var(
544:        -:  522:                (char *)value, 
545:        -:  523:                Config_vars,
546:        -:  524:                N_CONFIG_VARIABLES);
547:       24:  525:            if(IS_SEQUENCE(*key))
548:        2:  526:                *seq = SEQUENCE(*key);
549:        -:  527:        }      
550:       32:  528:        if(*key &lt; PLC_OK)
551:<font color=red>    #####:  529:            ret = *key;                          </font>
552:       32:  530:        *storage = STORE_VAL;
553:        -:  531:    }
554:        -:  532:    else{ //val
555:       24:  533:        if(is_seq){
556:        8:  534:            if(*key == VARIABLE_INDEX)
557:        2:  535:                    *idx = atoi((char *)value);
558:        -:  536:            else  
559:       12:  537:                ret = store_seq_value(*seq, 
560:        6:  538:                                          *idx, 
561:        6:  539:                                          *key, 
562:        -:  540:                                          (char *)value, 
563:        -:  541:                                          conf);        
564:        -:  542:        } else 
565:       16:  543:             ret = store_value(*key, (char *)value, conf);
566:       24:  544:        *storage = STORE_KEY; 
567:        -:  545:    } 
568:        -:  546:    
569:       56:  547:    return ret;                
570:        -:  548:}
571:        -:  549:
572:function process called 30 returned 1000locks executed 100%
573:       30:  550:int process(int sequence, 
574:        -:  551:            yaml_parser_t *parser, 
575:        -:  552:            config_t conf){
576:        -:  553:             
577:       30:  554:     int ret = PLC_OK;
578:       30:  555:     BYTE storage = STORE_KEY;   
579:       30:  556:     int done = FALSE;
580:       30:  557:     int key = PLC_ERR;
581:       30:  558:     int seq = sequence;
582:       30:  559:     int found_seq = sequence &gt; PLC_ERR;
583:       30:  560:     int idx = PLC_ERR;
584:        -:  561:     yaml_event_t event;
585:       30:  562:     memset(&event, 0, sizeof(event));
586:        -:  563:     
587:       30:  564:     if(parser == NULL
588:       26:  565:     || conf == NULL)
589:        -:  566:     
590:        4:  567:        return PLC_ERR;
591:        -:  568:           
592:      178:  569:     while(done == FALSE){
593:        -:  570:     
594:      126:  571:        if (!yaml_parser_parse(parser, &event)){   
595:        1:  572:                yaml_parser_error(*parser);
596:        1:  573:                ret = PLC_ERR;
597:        -:  574:        }
598:        -:  575:        else {
599:        -:  576:            
600:      125:  577:            switch(event.type){
601:        -:  578:            
602:        -:  579:                case YAML_SCALAR_EVENT:
603:      112:  580:                    ret = process_scalar(
604:        -:  581:                        event.data
605:        -:  582:                             .scalar
606:       56:  583:                             .value,
607:        -:  584:                        found_seq,
608:        -:  585:                        &conf,
609:        -:  586:                        &storage,
610:        -:  587:                        &key,
611:        -:  588:                        &seq,
612:        -:  589:                        &idx);
613:       56:  590:                    break;
614:        -:  591:                
615:        -:  592:                case YAML_SEQUENCE_START_EVENT:
616:        2:  593:                    found_seq = TRUE;
617:        2:  594:                    break;
618:        -:  595:                
619:        -:  596:                case YAML_SEQUENCE_END_EVENT:
620:        2:  597:                    found_seq = FALSE;
621:        2:  598:                    break;
622:        -:  599:                
623:        -:  600:                case YAML_MAPPING_START_EVENT:
624:       16:  601:                    ret = process(seq, parser, conf);
625:       16:  602:                    storage = STORE_KEY;   
626:       16:  603:                    break;
627:        -:  604:                    
628:        -:  605:                case YAML_MAPPING_END_EVENT:
629:        -:  606:                case YAML_STREAM_END_EVENT:     
630:       24:  607:                    done = TRUE;
631:       24:  608:                    break;
632:        -:  609:                    
633:        -:  610:                case YAML_NO_EVENT:
634:        1:  611:                    ret = PLC_ERR;
635:        1:  612:                    break;    
636:        -:  613:                    
637:       24:  614:                default: break;    
638:        -:  615:            }
639:        -:  616:         }
640:      126:  617:         if(ret &lt; PLC_OK) {
641:        2:  618:             done = TRUE;
642:        2:  619:             log_yml_event(event);
643:        -:  620:         }                                              
644:      126:  621:         yaml_event_delete(&event);   
645:        -:  622:     }
646:        -:  623:     
647:       26:  624:     return ret;
648:        -:  625:}
649:        -:  626:             
650:function load_config_yml called 0 returned 00locks executed 0%
651:<font color=red>    #####:  627:int load_config_yml(const char * filename, config_t conf) {</font>
652:        -:  628:    yaml_parser_t parser;
653:        -:  629:    
654:        -:  630:    FILE * fcfg;
655:        -:  631:    char path[MAXSTR];
656:        -:  632:
657:<font color=red>    #####:  633:    memset(path, 0, MAXSTR);</font>
658:<font color=red>    #####:  634:    sprintf(path, "", filename);</font>
659:        -:  635:    
660:<font color=red>    #####:  636:    memset(&parser, 0, sizeof(parser));</font>
661:        -:  637:    
662:<font color=red>    #####:  638:    int r = PLC_OK;</font>
663:        -:  639:    
664:<font color=red>    #####:  640:    if (!yaml_parser_initialize(&parser)) {</font>
665:<font color=red>    #####:  641:        yaml_parser_error(parser);</font>
666:<font color=red>    #####:  642:        return PLC_ERR;    </font>
667:        -:  643:    }
668:<font color=red>    #####:  644:    if ((fcfg = fopen(path, "r"))) {</font>
669:<font color=red>    #####:  645:        plc_log("Looking for configuration from  ...", path);</font>
670:<font color=red>    #####:  646:        yaml_parser_set_input_file(&parser, fcfg);</font>
671:<font color=red>    #####:  647:        r = process(PLC_ERR, &parser, conf);</font>
672:<font color=red>    #####:  648:        if(r &lt; PLC_OK)</font>
673:<font color=red>    #####:  649:            plc_log( "Configuration error ");</font>
674:<font color=red>    #####:  650:        fclose(fcfg);</font>
675:        -:  651:    } else {
676:<font color=red>    #####:  652:        r = PLC_ERR;</font>
677:<font color=red>    #####:  653:        plc_log("Could not open file ", filename);</font>
678:        -:  654:    }
679:<font color=red>    #####:  655:    yaml_parser_delete(&parser);</font>
680:<font color=red>    #####:  656:    return r;</font>
681:        -:  657:}
682:        -:  658:
683:function emit_map_entry called 22 returned 1000locks executed 100%
684:       22:  659:int emit_map_entry(
685:        -:  660:	char * name, 
686:        -:  661:	char * value,
687:        -:  662:	yaml_emitter_t *emitter) {
688:        -:  663:    
689:       22:  664:    int r = PLC_OK;     
690:        -:  665:	yaml_event_t e;
691:        -:  666:    
692:       22:  667:    yaml_mapping_style_t  	style =  YAML_PLAIN_SCALAR_STYLE;
693:        -:  668:    
694:       22:  669:    yaml_scalar_event_initialize(
695:        -:  670:    	&e,
696:        -:  671:	    NULL,
697:        -:  672:		NULL,
698:        -:  673:		(unsigned char *)name,
699:       22:  674:		strlen(name),
700:        -:  675:		TRUE,TRUE, style); 	
701:        -:  676:		
702:       22:  677:	yaml_emitter_emit(emitter, &e);
703:        -:  678:    
704:       22:  679:    yaml_scalar_event_initialize(
705:        -:  680:    	&e,
706:        -:  681:	    NULL,
707:        -:  682:		NULL,
708:        -:  683:		(unsigned char *)value,
709:       22:  684:		strlen(value),
710:        -:  685:		TRUE,TRUE, style); 	
711:        -:  686:		
712:       22:  687:	yaml_emitter_emit(emitter, &e); 		
713:        -:  688:    //yaml_event_delete(&e);
714:        -:  689:    
715:       22:  690:    return r; 
716:        -:  691:}
717:        -:  692:
718:function emit called 2 returned 1000locks executed 100%
719:        2:  693:int emit(yaml_emitter_t *emitter, const config_t conf) {
720:        2:  694:    int r = PLC_OK;     
721:        -:  695:   
722:        -:  696:    yaml_event_t e;
723:        -:  697:    char val[MAXSTR];
724:        2:  698:    memset(val,0,MAXSTR);
725:        -:  699:    //doc start
726:        2:  700:    yaml_document_start_event_initialize(&e, NULL, NULL, NULL, FALSE); 
727:        2:  701:	yaml_emitter_emit(emitter, &e); 		
728:        -:  702:    //mapping start
729:        2:  703:    yaml_mapping_style_t  	map_style =  YAML_BLOCK_MAPPING_STYLE;
730:        -:  704:     
731:        2:  705:    yaml_mapping_start_event_initialize(&e,NULL,NULL,FALSE,map_style); 	    
732:        2:  706:    yaml_emitter_emit(emitter, &e); 		
733:        -:  707:    
734:        -:  708:    //emit step
735:        2:  709:    sprintf(val, "0", conf-&gt;step);
736:        -:  710:    
737:        2:  711:    emit_map_entry("STEP", val, emitter);
738:        2:  712:    memset(val,0,MAXSTR);
739:        -:  713:    	
740:        -:  714:    //emit pipe
741:        2:  715:    emit_map_entry("PIPE", conf-&gt;pipe, emitter);
742:        -:  716:    
743:        -:  717:    //emit timers and pulses
744:        2:  718:    sprintf(val, "0", conf-&gt;nt);
745:        -:  719:    
746:        2:  720:    emit_map_entry("NT", val, emitter);
747:        2:  721:    memset(val,0,MAXSTR);
748:        -:  722:    
749:        2:  723:    sprintf(val, "0", conf-&gt;ns);
750:        -:  724:    
751:        2:  725:    emit_map_entry("NS", val, emitter);
752:        2:  726:    memset(val,0,MAXSTR);
753:        -:  727:    
754:        -:  728:    //emit variables 
755:        2:  729:    sprintf(val, "0", conf-&gt;nm);
756:        -:  730:    
757:        2:  731:    emit_map_entry("NM", val, emitter);
758:        2:  732:    memset(val,0,MAXSTR);
759:        -:  733:    
760:        2:  734:    sprintf(val, "0", conf-&gt;nr);
761:        -:  735:    
762:        2:  736:    emit_map_entry("NR", val, emitter);
763:        2:  737:    memset(val,0,MAXSTR);
764:        -:  738:    
765:        2:  739:    sprintf(val, "0", conf-&gt;di);
766:        -:  740:    //emit hardware tag
767:        2:  741:    emit_map_entry("HW", conf-&gt;hw, emitter);
768:        -:  742:    //emit hardware variables
769:        -:  743:    
770:        2:  744:    emit_map_entry("NDI", val, emitter);
771:        2:  745:    memset(val,0,MAXSTR);
772:        -:  746:    
773:        2:  747:    sprintf(val, "0", conf-&gt;dq);
774:        -:  748:    
775:        2:  749:    emit_map_entry("NDQ", val, emitter);
776:        2:  750:    memset(val,0,MAXSTR);
777:        -:  751:   
778:        2:  752:    sprintf(val, "0", conf-&gt;ai);
779:        -:  753:    
780:        2:  754:    emit_map_entry("NAI", val, emitter);
781:        2:  755:    memset(val,0,MAXSTR);
782:        -:  756:    
783:        2:  757:    sprintf(val, "0", conf-&gt;aq);
784:        -:  758:    
785:        2:  759:    emit_map_entry("NAQ", val, emitter);
786:        2:  760:    memset(val,0,MAXSTR);
787:        -:  761:   
788:        -:  762:
789:        -:  763:    //emit user space
790:        -:  764:    
791:        -:  765:    //emit comedi
792:        -:  766:    
793:        -:  767:    //emit simulation
794:        -:  768:    
795:        -:  769:    //emit variables configuration
796:        -:  770:    
797:        -:  771:    //emit program filename
798:        -:  772:    
799:        -:  773:
800:        -:  774:
801:        -:  775:    //mapping end
802:        2:  776:    yaml_mapping_end_event_initialize(&e); 	
803:        2:  777:    yaml_emitter_emit(emitter, &e); 		
804:        -:  778:    
805:        -:  779:    //doc end
806:        2:  780:    yaml_document_end_event_initialize(&e,FALSE);
807:        2:  781:    yaml_emitter_emit(emitter, &e); 		
808:        2:  782:    yaml_event_delete(&e); 	
809:        2:  783:    return r;
810:        -:  784:}
811:        -:  785:
812:function save_config_yml called 0 returned 00locks executed 0%
813:<font color=red>    #####:  786:int save_config_yml(const char * filename, const config_t conf) {</font>
814:        -:  787:    
815:        -:  788:    yaml_emitter_t emitter;
816:        -:  789:    yaml_event_t event;
817:        -:  790:    
818:        -:  791:    FILE * fcfg;
819:        -:  792:    char path[MAXSTR];
820:<font color=red>    #####:  793:    int r = PLC_OK;</font>
821:        -:  794:    
822:<font color=red>    #####:  795:    memset(path, 0, MAXSTR);</font>
823:<font color=red>    #####:  796:    sprintf(path, "", filename);</font>
824:        -:  797:
825:<font color=red>    #####:  798:    if(!yaml_emitter_initialize(&emitter)){</font>
826:<font color=red>    #####:  799:        return PLC_ERR;    </font>
827:        -:  800:    }
828:<font color=red>    #####:  801:    if ((fcfg = fopen(path, "wb"))) {</font>
829:<font color=red>    #####:  802:         plc_log("Save configuration to  ...", path);</font>
830:        -:  803:         
831:<font color=red>    #####:  804:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
832:<font color=red>    #####:  805:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
833:        -:  806:         
834:<font color=red>    #####:  807:         r = yaml_emitter_emit(&emitter, &event);</font>
835:        -:  808:         
836:<font color=red>    #####:  809:         if(r)</font>
837:<font color=red>    #####:  810:            r = emit(&emitter, conf);</font>
838:<font color=red>    #####:  811:         if(r){</font>
839:<font color=red>    #####:  812:            yaml_stream_end_event_initialize(&event);</font>
840:<font color=red>    #####:  813:            r = yaml_emitter_emit(&emitter, &event);   </font>
841:        -:  814:         }
842:        -:  815:            
843:<font color=red>    #####:  816:         if(r &lt; PLC_OK)</font>
844:<font color=red>    #####:  817:            plc_log( "Configuration error ");</font>
845:        -:  818:            
846:<font color=red>    #####:  819:         fclose(fcfg);</font>
847:        -:  820:    } else {
848:<font color=red>    #####:  821:        r = PLC_ERR;</font>
849:<font color=red>    #####:  822:        plc_log("Could not open file  for write", filename);</font>
850:        -:  823:    }
851:<font color=red>    #####:  824:    yaml_emitter_delete(&emitter);</font>
852:<font color=red>    #####:  825:    return r;</font>
853:        -:  826:}
854:        -:  827:
855:        -:  828:
856:        -:  829:
857:function configure called 2 returned 1000locks executed 100%
858:        2:  830:void configure(const config_t conf, plc_t plc){
859:        -:  831:
860:        2:  832:    plc-&gt;ni = conf-&gt;di;
861:        2:  833:    plc-&gt;nq = conf-&gt;dq;
862:        2:  834:    plc-&gt;nai = conf-&gt;ai;
863:        2:  835:    plc-&gt;naq = conf-&gt;aq;
864:        2:  836:    plc-&gt;nt = conf-&gt;nt;
865:        2:  837:    plc-&gt;ns = conf-&gt;ns;
866:        2:  838:    plc-&gt;nm = conf-&gt;nm;
867:        2:  839:    plc-&gt;nmr = conf-&gt;nr;
868:        -:  840:    
869:        2:  841:    sprintf(plc-&gt;hw, "", conf-&gt;hw);
870:        -:  842:    
871:        2:  843:    plc-&gt;inputs = (BYTE *) malloc(plc-&gt;ni);
872:        2:  844:    plc-&gt;outputs = (BYTE *) malloc(plc-&gt;nq);
873:        2:  845:    plc-&gt;edgein = (BYTE *) malloc(plc-&gt;ni);
874:        2:  846:    plc-&gt;maskin = (BYTE *) malloc(plc-&gt;ni);
875:        2:  847:    plc-&gt;maskout = (BYTE *) malloc(plc-&gt;nq);
876:        2:  848:    plc-&gt;maskin_N = (BYTE *) malloc(plc-&gt;ni);
877:        2:  849:    plc-&gt;maskout_N = (BYTE *) malloc(plc-&gt;nq);
878:        2:  850:    plc-&gt;real_in = (uint64_t *) malloc(conf-&gt;ai * sizeof(uint64_t));
879:        2:  851:    plc-&gt;real_out = (uint64_t *) malloc(conf-&gt;aq * sizeof(uint64_t));
880:        2:  852:    plc-&gt;mask_ai = (double *) malloc(conf-&gt;ai * sizeof(double));
881:        2:  853:    plc-&gt;mask_aq = (double *) malloc(conf-&gt;aq * sizeof(double));
882:        2:  854:    plc-&gt;di = (di_t) malloc(
883:        2:  855:            BYTESIZE * plc-&gt;ni * sizeof(struct digital_input));
884:        2:  856:    plc-&gt;dq = (do_t) malloc(
885:        2:  857:            BYTESIZE * plc-&gt;nq * sizeof(struct digital_output));
886:        -:  858:    
887:        2:  859:    plc-&gt;t = (dt_t) malloc(plc-&gt;nt * sizeof(struct timer));
888:        2:  860:    plc-&gt;s = (blink_t) malloc(plc-&gt;ns * sizeof(struct blink));
889:        2:  861:    plc-&gt;m = (mvar_t) malloc(plc-&gt;nm * sizeof(struct mvar));
890:        2:  862:    plc-&gt;mr = (mreal_t) malloc(plc-&gt;nmr * sizeof(struct mreal));
891:        -:  863:   
892:        2:  864:    plc-&gt;ai = (aio_t) malloc(
893:        2:  865:             conf-&gt;ai * sizeof(struct analog_io));
894:        2:  866:    plc-&gt;aq = (aio_t) malloc(
895:        2:  867:             conf-&gt;aq * sizeof(struct analog_io));
896:        -:  868:   
897:        2:  869:    memset(plc-&gt;real_in, 0, plc-&gt;nai*sizeof(uint64_t));
898:        2:  870:    memset(plc-&gt;real_out, 0, plc-&gt;naq*sizeof(uint64_t));
899:        2:  871:    memset(plc-&gt;inputs, 0, plc-&gt;ni);
900:        2:  872:    memset(plc-&gt;outputs, 0, plc-&gt;nq);
901:        2:  873:    memset(plc-&gt;maskin, 0, plc-&gt;ni);
902:        2:  874:    memset(plc-&gt;maskout, 0, plc-&gt;nq);
903:        2:  875:    memset(plc-&gt;maskin_N, 0, plc-&gt;ni);
904:        2:  876:    memset(plc-&gt;maskout_N, 0, plc-&gt;nq);
905:        -:  877:    
906:        2:  878:    memset(plc-&gt;mask_ai, 0, plc-&gt;nai * sizeof(double));
907:        2:  879:    memset(plc-&gt;mask_aq, 0, plc-&gt;naq * sizeof(double));
908:        -:  880:    
909:        2:  881:    memset(plc-&gt;di, 0, BYTESIZE * plc-&gt;ni * sizeof(struct digital_input));
910:        2:  882:    memset(plc-&gt;dq, 0, BYTESIZE * plc-&gt;nq * sizeof(struct digital_output));
911:        2:  883:    memset(plc-&gt;t, 0, plc-&gt;nt * sizeof(struct timer));
912:        2:  884:    memset(plc-&gt;s, 0, plc-&gt;ns * sizeof(struct blink));
913:        2:  885:    memset(plc-&gt;m, 0, plc-&gt;nm * sizeof(struct mvar));
914:        2:  886:    memset(plc-&gt;mr, 0, plc-&gt;nmr * sizeof(struct mreal));
915:        -:  887:
916:        2:  888:    plc_t p_old=NULL;
917:        2:  889:    p_old = (plc_t) malloc(sizeof(struct PLC_regs));
918:        -:  890:
919:        2:  891:    p_old-&gt;ni = conf-&gt;di;
920:        2:  892:    p_old-&gt;nq = conf-&gt;dq;
921:        2:  893:    p_old-&gt;nai = conf-&gt;ai;
922:        2:  894:    p_old-&gt;naq = conf-&gt;aq;
923:        2:  895:    p_old-&gt;nt = conf-&gt;nt;
924:        2:  896:    p_old-&gt;ns = conf-&gt;ns;
925:        2:  897:    p_old-&gt;nm = conf-&gt;nm;
926:        2:  898:    p_old-&gt;nmr = conf-&gt;nr;
927:        -:  899:    
928:        2:  900:    p_old-&gt;inputs = (BYTE *) malloc(conf-&gt;di);
929:        2:  901:    p_old-&gt;outputs = (BYTE *) malloc(conf-&gt;dq);
930:        2:  902:    p_old-&gt;maskin = (BYTE *) malloc(conf-&gt;di);
931:        2:  903:    p_old-&gt;edgein = (BYTE *) malloc(conf-&gt;di);
932:        2:  904:    p_old-&gt;maskout = (BYTE *) malloc(conf-&gt;dq);
933:        2:  905:    p_old-&gt;maskin_N = (BYTE *) malloc(conf-&gt;di);
934:        2:  906:    p_old-&gt;maskout_N = (BYTE *) malloc(conf-&gt;dq);
935:        2:  907:    p_old-&gt;di = (di_t) malloc(
936:        2:  908:            BYTESIZE * conf-&gt;di * sizeof(struct digital_input));
937:        2:  909:    p_old-&gt;dq = (do_t) malloc(
938:        2:  910:            BYTESIZE * conf-&gt;dq * sizeof(struct digital_output));
939:        2:  911:    p_old-&gt;t = (dt_t) malloc(conf-&gt;nt * sizeof(struct timer));
940:        2:  912:    p_old-&gt;s = (blink_t) malloc(conf-&gt;ns * sizeof(struct blink));
941:        2:  913:    p_old-&gt;m = (mvar_t) malloc(conf-&gt;nm * sizeof(struct mvar));
942:        2:  914:    p_old-&gt;mr = (mreal_t) malloc(conf-&gt;nr * sizeof(struct mreal));
943:        -:  915:    
944:        -:  916:    
945:        2:  917:    p_old-&gt;real_in = (uint64_t *) malloc(conf-&gt;ai * sizeof(uint64_t));
946:        2:  918:    p_old-&gt;real_out = (uint64_t *) malloc(conf-&gt;aq * sizeof(uint64_t));
947:        2:  919:    p_old-&gt;mask_ai = (double *) malloc(conf-&gt;ai * sizeof(double));
948:        2:  920:    p_old-&gt;mask_aq = (double *) malloc(conf-&gt;aq * sizeof(double));
949:        2:  921:    p_old-&gt;ai = (aio_t) malloc(
950:        2:  922:             conf-&gt;ai * sizeof(struct analog_io));
951:        2:  923:    p_old-&gt;aq = (aio_t) malloc(
952:        2:  924:             conf-&gt;aq * sizeof(struct analog_io));
953:        -:  925:    
954:        2:  926:    p_old-&gt;di = (di_t) malloc(
955:        2:  927:            BYTESIZE * plc-&gt;ni * sizeof(struct digital_input));
956:        2:  928:    p_old-&gt;dq = (do_t) malloc(
957:        2:  929:            BYTESIZE * plc-&gt;nq * sizeof(struct digital_output));
958:        -:  930:    
959:        2:  931:    memcpy(p_old-&gt;inputs, plc-&gt;inputs, conf-&gt;di);
960:        2:  932:    memcpy(p_old-&gt;outputs, plc-&gt;outputs, conf-&gt;dq);
961:        2:  933:    memset(p_old-&gt;real_in, 0, plc-&gt;nai*sizeof(uint64_t));
962:        2:  934:    memset(p_old-&gt;real_out, 0, plc-&gt;naq*sizeof(uint64_t));
963:        -:  935:    
964:        2:  936:    memcpy(p_old-&gt;m, plc-&gt;m, conf-&gt;nm * sizeof(struct mvar));
965:        2:  937:    memcpy(p_old-&gt;mr, plc-&gt;mr, conf-&gt;nr * sizeof(struct mreal));
966:        2:  938:    memcpy(p_old-&gt;t, plc-&gt;t, conf-&gt;nt * sizeof(struct timer));
967:        2:  939:    memcpy(p_old-&gt;s, plc-&gt;s, conf-&gt;ns * sizeof(struct blink));
968:        -:  940:    
969:        2:  941:    plc-&gt;old = p_old;
970:        2:  942:    plc-&gt;command = 0;
971:        2:  943:    plc-&gt;status = ST_RUNNING;
972:        2:  944:    plc-&gt;step = conf-&gt;step;
973:        2:  945:    plc-&gt;response_file = conf-&gt;response_file;
974:        2:  946:}
975:        -:  947:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
