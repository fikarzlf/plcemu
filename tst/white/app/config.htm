<br><h2>Line by line analysis of config.c </h2>
<pre>  1:        -:    0:Source:config.c
  2:        -:    0:Graph:config.gcno
  3:        -:    0:Data:config.gcda
  4:        -:    0:Runs:1
  5:        -:    0:Programs:1
  6:        -:    1:#include &lt;yaml.h&gt;
  7:        -:    2:#include "util.h"
  8:        -:    3:#include "config.h"
  9:        -:    4:
 10:function strdup_r called 14 returned 1000locks executed 100%
 11:       14:    5:char * strdup_r(const char * dest, const char * src) {
 12:        -:    6://strdup with realloc
 13:        -:    7:
 14:       14:    8:    char * r = (!dest)?(char *)malloc(sizeof(src)):realloc(dest, sizeof(src));
 15:        -:    9:        
 16:       14:   10:    memset(r, 0, sizeof(src));
 17:       14:   11:    sprintf(r, "", src);
 18:        -:   12:    
 19:       14:   13:    return r;
 20:        -:   14:}
 21:        -:   15:
 22:function yaml_config_error called 0 returned 00locks executed 0%
 23:<font color=red>    #####:   16:static void yaml_config_error(yaml_parser_t parser){</font>
 24:        -:   17:
 25:        -:   18:    //print line
 26:<font color=red>    #####:   19:}</font>
 27:        -:   20:
 28:function yaml_parser_error called 0 returned 00locks executed 0%
 29:<font color=red>    #####:   21:static void yaml_parser_error(yaml_parser_t parser){</font>
 30:        -:   22:
 31:<font color=red>    #####:   23:     switch (parser.error)</font>
 32:        -:   24:     {
 33:        -:   25:        case YAML_MEMORY_ERROR:
 34:<font color=red>    #####:   26:            plc_log( </font>
 35:        -:   27:            "Memory error: Not enough memory for parsing");
 36:<font color=red>    #####:   28:            break;</font>
 37:        -:   29:
 38:        -:   30:        case YAML_READER_ERROR:
 39:<font color=red>    #####:   31:            if (parser.problem_value != -1) {</font>
 40:<font color=red>    #####:   32:                plc_log( </font>
 41:        -:   33:                "Reader error: : #0 at 0", 
 42:        -:   34:                parser.problem,
 43:        -:   35:                parser.problem_value, 
 44:        -:   36:                parser.problem_offset);
 45:        -:   37:            }
 46:        -:   38:            else {
 47:<font color=red>    #####:   39:                plc_log( </font>
 48:        -:   40:                "Reader error:  at 0", 
 49:        -:   41:                parser.problem,
 50:        -:   42:                parser.problem_offset);
 51:        -:   43:            }
 52:<font color=red>    #####:   44:            break;</font>
 53:        -:   45:
 54:        -:   46:        case YAML_SCANNER_ERROR:
 55:<font color=red>    #####:   47:            if (parser.context) {</font>
 56:<font color=red>    #####:   48:                plc_log( </font>
 57:        -:   49:                "Scanner error:  at line 0, column 0"
 58:        -:   50:                        " at line 0, column 0", 
 59:        -:   51:                        parser.context,
 60:<font color=red>    #####:   52:                        parser.context_mark.line+1,</font>
 61:<font color=red>    #####:   53:                        parser.context_mark.column+1,</font>
 62:        -:   54:                        parser.problem, 
 63:<font color=red>    #####:   55:                        parser.problem_mark.line+1,</font>
 64:<font color=red>    #####:   56:                        parser.problem_mark.column+1);</font>
 65:        -:   57:            }
 66:        -:   58:            else {
 67:<font color=red>    #####:   59:                plc_log( </font>
 68:        -:   60:                "Scanner error:  at line 0, column 0",
 69:<font color=red>    #####:   61:                        parser.problem, parser.problem_mark.line+1,</font>
 70:<font color=red>    #####:   62:                        parser.problem_mark.column+1);</font>
 71:        -:   63:            }
 72:<font color=red>    #####:   64:            break;</font>
 73:        -:   65:
 74:        -:   66:        case YAML_PARSER_ERROR:
 75:<font color=red>    #####:   67:            if (parser.context) {</font>
 76:<font color=red>    #####:   68:                plc_log( </font>
 77:        -:   69:                "Parser error:  at line 0, column 0"
 78:        -:   70:                        " at line 0, column 0", 
 79:        -:   71:                        parser.context,
 80:<font color=red>    #####:   72:                        parser.context_mark.line+1,</font>
 81:<font color=red>    #####:   73:                        parser.context_mark.column+1,</font>
 82:        -:   74:                        parser.problem, 
 83:<font color=red>    #####:   75:                        parser.problem_mark.line+1,</font>
 84:<font color=red>    #####:   76:                        parser.problem_mark.column+1);</font>
 85:        -:   77:            }
 86:        -:   78:            else {
 87:<font color=red>    #####:   79:                plc_log( </font>
 88:        -:   80:                "Parser error:  at line 0, column 0",
 89:        -:   81:                        parser.problem, 
 90:<font color=red>    #####:   82:                        parser.problem_mark.line+1,</font>
 91:<font color=red>    #####:   83:                        parser.problem_mark.column+1);</font>
 92:        -:   84:            }
 93:<font color=red>    #####:   85:            break;</font>
 94:        -:   86:
 95:        -:   87:        default:
 96:        -:   88:            /* Couldn't happen. */
 97:<font color=red>    #####:   89:            plc_log( </font>
 98:        -:   90:            "Internal error\n");
 99:<font color=red>    #####:   91:            break;</font>
100:        -:   92:    }
101:<font color=red>    #####:   93:}</font>
102:        -:   94:
103:function new_entry_int called 90 returned 1000locks executed 100%
104:       90:   95:static entry_t new_entry_int(int i, char * name) {
105:        -:   96:
106:       90:   97:	entry_t r = (entry_t)malloc(sizeof(struct entry));
107:       90:   98:	r-&gt;type_tag = ENTRY_INT;
108:       90:   99:	r-&gt;name = name;
109:       90:  100:	r-&gt;e.scalar_int = i;
110:        -:  101:
111:       90:  102:	return r;
112:        -:  103:}
113:        -:  104:
114:function new_entry_str called 40 returned 1000locks executed 100%
115:       40:  105:static entry_t new_entry_str(char * str, char * name) {
116:        -:  106:
117:       40:  107:	entry_t r = (entry_t)malloc(sizeof(struct entry));
118:       40:  108:	r-&gt;type_tag = ENTRY_STR;
119:       40:  109:	r-&gt;name = name;
120:       40:  110:	r-&gt;e.scalar_str = (char *)malloc(sizeof(str));
121:       40:  111:    sprintf(r-&gt;e.scalar_str, "", str);
122:       40:  112:	return r;
123:        -:  113:}
124:        -:  114:
125:function new_entry_map called 40 returned 1000locks executed 100%
126:       40:  115:static entry_t new_entry_map(config_t map, char * name) {
127:        -:  116:	
128:       40:  117:	entry_t r = (entry_t)malloc(sizeof(struct entry));
129:       40:  118:	r-&gt;type_tag = ENTRY_MAP;
130:       40:  119:	r-&gt;name = name;
131:       40:  120:	r-&gt;e.conf = map;
132:        -:  121:
133:       40:  122:	return r;
134:        -:  123:}
135:        -:  124:
136:function new_entry_seq called 80 returned 1000locks executed 100%
137:       80:  125:static entry_t new_entry_seq(sequence_t seq, char * name) {
138:        -:  126:	
139:       80:  127:	entry_t r = (entry_t)malloc(sizeof(struct entry));
140:       80:  128:	r-&gt;type_tag = ENTRY_SEQ;
141:       80:  129:	r-&gt;name = name;
142:       80:  130:	r-&gt;e.seq = seq;
143:        -:  131:
144:       80:  132:	return r;
145:        -:  133:}
146:        -:  134:
147:function new_entry_null called 0 returned 00locks executed 0%
148:<font color=red>    #####:  135:static entry_t new_entry_null() {</font>
149:<font color=red>    #####:  136:	entry_t r = (entry_t)malloc(sizeof(struct entry));</font>
150:<font color=red>    #####:  137:	r-&gt;type_tag = ENTRY_NONE;</font>
151:<font color=red>    #####:  138:	r-&gt;name = "";</font>
152:<font color=red>    #####:  139:	r-&gt;e.scalar_int = 0;</font>
153:        -:  140:
154:<font color=red>    #####:  141:	return r;</font>
155:        -:  142:}
156:        -:  143:
157:function update_entry called 250 returned 1000locks executed 80%
158:      250:  144:static config_t update_entry(
159:        -:  145:    unsigned int key, 
160:        -:  146:    const entry_t item,
161:        -:  147:    const config_t conf) {
162:        -:  148:    
163:      500:  149:    if( conf == NULL ||
164:      250:  150:        key &gt;= conf-&gt;size) {
165:        -:  151:    
166:<font color=red>    #####:  152:        return conf;</font>
167:        -:  153:    } else {
168:        -:  154:    
169:      250:  155:        config_t r = conf;
170:      250:  156:        r-&gt;map[key] = item;
171:        -:  157:        
172:      250:  158:        return r;
173:        -:  159:    }
174:        -:  160:}
175:        -:  161:
176:function get_entry called 100 returned 1000locks executed 100%
177:      100:  162:entry_t get_entry(int key, const config_t conf){
178:        -:  163:
179:      100:  164:    if(conf == NULL || 
180:       88:  165:        key &lt; 0 || 
181:       88:  166:        key &gt; conf-&gt;size) {
182:        -:  167:        
183:       12:  168:        return NULL;    
184:        -:  169:    }
185:        -:  170:    
186:       88:  171:    return conf-&gt;map[key];
187:        -:  172:}
188:        -:  173:
189:function get_numeric_entry called 4 returned 1000locks executed 100%
190:        4:  174:int get_numeric_entry(int key, const config_t conf){
191:        4:  175:    entry_t e = get_entry(key, conf);
192:        4:  176:    if(e && e-&gt;type_tag == ENTRY_INT){
193:        -:  177:    
194:        2:  178:        return e-&gt;e.scalar_int;
195:        -:  179:    } else {
196:        -:  180:    
197:        2:  181:        return CONF_ERR;    
198:        -:  182:    } 
199:        -:  183:}
200:        -:  184:
201:function get_string_entry called 4 returned 1000locks executed 100%
202:        4:  185:char * get_string_entry(int key, const config_t conf){
203:        -:  186:    
204:        4:  187:    entry_t e = get_entry(key, conf);
205:        4:  188:    if(e && e-&gt;type_tag == ENTRY_STR){
206:        -:  189:    
207:        2:  190:        return e-&gt;e.scalar_str;
208:        -:  191:    } else {
209:        -:  192:    
210:        2:  193:        return NULL;    
211:        -:  194:    }    
212:        -:  195:}
213:        -:  196:
214:function get_sequence_entry called 2 returned 1000locks executed 83%
215:        2:  197:sequence_t get_sequence_entry(int key, const config_t conf){
216:        2:  198:    entry_t e = get_entry(key, conf);
217:        2:  199:    if(e && e-&gt;type_tag == ENTRY_SEQ){
218:        -:  200:    
219:        2:  201:        return e-&gt;e.seq;
220:        -:  202:    } else {
221:        -:  203:    
222:<font color=red>    #####:  204:        return NULL;    </font>
223:        -:  205:    }    
224:        -:  206:}
225:        -:  207:
226:        -:  208://TODO: in a c++ impl. this would be a hashmap
227:function new_param called 12 returned 1000locks executed 100%
228:       12:  209:param_t new_param(const char * key, 
229:        -:  210:                     const char * val){
230:        -:  211:    
231:       12:  212:        param_t n = (param_t)malloc(sizeof(struct param));
232:       12:  213:        n-&gt;key = strdup(key);
233:       12:  214:        n-&gt;value = strdup(val);
234:       12:  215:        n-&gt;next = NULL;
235:        -:  216:        
236:       12:  217:        return n;        
237:        -:  218:}
238:        -:  219:
239:function get_param called 10 returned 1000locks executed 100%
240:       10:  220:param_t get_param(const char * key, const param_t params){
241:       10:  221:    param_t it = params;
242:       30:  222:    while(it && key){
243:       16:  223:        if(!strcmp(it-&gt;key, key)){
244:        -:  224:        
245:        6:  225:            return it;
246:        -:  226:        }
247:       10:  227:        it = it-&gt;next;            
248:        -:  228:    }
249:        -:  229:    
250:        4:  230:    return NULL;
251:        -:  231:}
252:        -:  232:
253:function get_param_val called 6 returned 1000locks executed 83%
254:        6:  233:char * get_param_val(const char * key, const param_t params){
255:        6:  234:    param_t it = get_param(key, params);
256:        -:  235:    
257:        6:  236:    return it?it-&gt;value:NULL;
258:        -:  237:}
259:        -:  238:
260:function append_param called 4 returned 1000locks executed 88%
261:        4:  239:param_t append_param(const param_t params, 
262:        -:  240:                     const char * key, 
263:        -:  241:                     const char * val){
264:        -:  242:        
265:        4:  243:    if(params == NULL){
266:        -:  244:        
267:<font color=red>    #####:  245:        return new_param(key, val);</font>
268:        -:  246:    } else {
269:        4:  247:        param_t ret = params;
270:        4:  248:        param_t it = params;
271:       10:  249:        while(it-&gt;next){
272:        2:  250:            it = it-&gt;next;
273:        -:  251:        }
274:        4:  252:        it-&gt;next = new_param(key, val);
275:        -:  253:                
276:        4:  254:        return ret;    
277:        -:  255:    }
278:        -:  256:}
279:        -:  257:
280:function update_param called 12 returned 1000locks executed 78%
281:       12:  258:param_t update_param(const param_t params, 
282:        -:  259:                     const char * key, 
283:        -:  260:                     const char * val){
284:        -:  261:        
285:       12:  262:    if(params == NULL){
286:        -:  263:        
287:        8:  264:        return new_param(key, val);         
288:        -:  265:    } else {
289:        4:  266:        param_t ret = params;
290:        4:  267:        param_t par = get_param(key, params);
291:        4:  268:        if(par){
292:<font color=red>    #####:  269:            par-&gt;value = strdup_r(par-&gt;value, val);</font>
293:        -:  270:        } else {
294:        -:  271:        //FIXME: ..and this is why we need a hashmap.
295:        4:  272:            ret = append_param(ret, key, val);  
296:        -:  273:        } 
297:        4:  274:        return ret;    
298:        -:  275:    }
299:        -:  276:}
300:        -:  277:
301:function get_key called 38 returned 1000locks executed 100%
302:       38:  278:int get_key(const char * name, const config_t where) {
303:       38:  279:     if(where != NULL){
304:        -:  280:    
305:      490:  281:        for(int i = 0; i &lt; where-&gt;size; i++) {
306:      710:  282:            if( where-&gt;map[i] != NULL &&
307:      230:  283:                !strcmp(name, where-&gt;map[i]-&gt;name)) {
308:        -:  284:                
309:       28:  285:                return i;
310:        -:  286:            }
311:        -:  287:        }
312:        -:  288:    }
313:        -:  289:    
314:       10:  290:    return CONF_ERR;  
315:        -:  291:}
316:        -:  292:
317:function new_config called 50 returned 1000locks executed 100%
318:       50:  293:config_t new_config(int size) {
319:       50:  294:    config_t r = (config_t)malloc(sizeof(struct config));
320:       50:  295:	memset(r, 0, sizeof(struct config));
321:       50:  296:	r-&gt;size = size;
322:       50:  297:	r-&gt;map = (entry_map_t)malloc(size*sizeof(struct entry));
323:       50:  298:    memset(r-&gt;map, 0, size*sizeof(struct entry));
324:        -:  299:    
325:       50:  300:	return r;
326:        -:  301:}
327:        -:  302:
328:function new_sequence called 80 returned 1000locks executed 100%
329:       80:  303:sequence_t new_sequence(int size) {
330:       80:  304:    sequence_t r = (sequence_t)malloc(size*sizeof(struct sequence));
331:       80:  305:	memset(r, 0, sizeof(struct sequence));
332:       80:  306:	r-&gt;size = size;
333:       80:  307:	r-&gt;vars = (variable_t)malloc(size*sizeof(struct variable));
334:       80:  308:	memset(r-&gt;vars, 0, size*sizeof(struct variable));
335:        -:  309:	
336:       80:  310:	return r;
337:        -:  311:}
338:        -:  312:
339:function init_config called 10 returned 1000locks executed 100%
340:       10:  313:config_t init_config(){
341:        -:  314: //TODO: in a c++ implementation this all can be done automatically 
342:        -:  315: //using a hashmap
343:       10:  316:    config_t conf = new_config(N_CONFIG_VARIABLES);
344:        -:  317:   
345:       10:  318:    config_t uspace = new_config(N_USPACE_VARS);
346:        -:  319:        
347:       10:  320:    uspace = update_entry(
348:        -:  321:        USPACE_BASE,
349:        -:  322:	    new_entry_int(50176, "USPACE_BASE"),
350:        -:  323:	    uspace);
351:        -:  324:	
352:       10:  325:	uspace = update_entry(
353:        -:  326:	    USPACE_WR, 
354:        -:  327:	    new_entry_int(0, "USPACE_WR"),
355:        -:  328:	    uspace);
356:        -:  329:	    
357:       10:  330:	uspace = update_entry(
358:        -:  331:	    USPACE_RD, 
359:        -:  332:	    new_entry_int(8, "USPACE_RD"),
360:        -:  333:	    uspace);
361:        -:  334:	
362:       10:  335:	config_t subdev = new_config(N_SUBDEV_VARS);
363:        -:  336:	
364:       10:  337:    subdev = update_entry(
365:        -:  338:        SUBDEV_IN,
366:        -:  339:	    new_entry_int(0, "SUBDEV_IN"),
367:        -:  340:	    subdev);
368:        -:  341:	    
369:       10:  342:	subdev = update_entry(
370:        -:  343:	    SUBDEV_OUT,
371:        -:  344:	    new_entry_int(1, "SUBDEV_OUT"),
372:        -:  345:	    subdev);
373:        -:  346:	    
374:       10:  347:    subdev = update_entry(
375:        -:  348:        SUBDEV_ADC, 
376:        -:  349:	    new_entry_int(2, "SUBDEV_ADC"),
377:        -:  350:	    subdev);
378:        -:  351:	    
379:       10:  352:	subdev = update_entry(
380:        -:  353:	    SUBDEV_DAC, 
381:        -:  354:	    new_entry_int(3, "SUBDEV_DAC"),
382:        -:  355:	    subdev);
383:        -:  356:	
384:       10:  357:	config_t comedi = new_config(N_COMEDI_VARS);
385:        -:  358:	
386:       10:  359:	comedi = update_entry(
387:        -:  360:	    COMEDI_FILE,
388:        -:  361:	    new_entry_int(0, "COMEDI_FILE"),
389:        -:  362:	    comedi);
390:        -:  363:	    
391:       10:  364:	comedi = update_entry(
392:        -:  365:	    COMEDI_SUBDEV, 
393:        -:  366:	    new_entry_map(subdev, "COMEDI_SUBDEV"),
394:        -:  367:	    comedi);
395:        -:  368:    
396:       10:  369:    config_t sim = new_config(N_SIM_VARS);
397:        -:  370:    
398:       10:  371:    sim = update_entry(
399:        -:  372:        SIM_INPUT,
400:        -:  373:        new_entry_str("sim.in", "SIM_INPUT"), 
401:        -:  374:        sim);
402:        -:  375:        
403:       10:  376:    sim = update_entry(
404:        -:  377:        SIM_OUTPUT,
405:        -:  378:        new_entry_str("sim.out", "SIM_OUTPUT"),
406:        -:  379:        sim);    
407:        -:  380:
408:       10:  381:    conf = update_entry(
409:        -:  382:        CONFIG_STEP,
410:        -:  383:        new_entry_int(1, "STEP"),
411:        -:  384:        conf);
412:        -:  385:    
413:       10:  386:    conf = update_entry(
414:        -:  387:        CONFIG_PIPE,
415:        -:  388:        new_entry_str("plcpipe", "PIPE"),
416:        -:  389:        conf);
417:        -:  390:    
418:       10:  391:    conf = update_entry(
419:        -:  392:        CONFIG_HW,
420:        -:  393:        new_entry_str("STDI/O", "HW"),
421:        -:  394:        conf);
422:        -:  395:        
423:       10:  396:    conf = update_entry(
424:        -:  397:        CONFIG_USPACE,
425:        -:  398:        new_entry_map(uspace, "USPACE"),
426:        -:  399:        conf);
427:        -:  400:    
428:       10:  401:    conf = update_entry(
429:        -:  402:        CONFIG_COMEDI,
430:        -:  403:        new_entry_map(comedi, "COMEDI"),
431:        -:  404:        conf);
432:        -:  405:    
433:       10:  406:    conf = update_entry(
434:        -:  407:        CONFIG_SIM,
435:        -:  408:        new_entry_map(sim, "SIM"),
436:        -:  409:        conf);
437:        -:  410:   /*******************************************/
438:        -:  411:   
439:       10:  412:    conf = update_entry(
440:        -:  413:        CONFIG_TIMER,
441:        -:  414:        new_entry_seq(new_sequence(4), "TIMERS"),
442:        -:  415:        conf);
443:        -:  416:    
444:       10:  417:    conf = update_entry(
445:        -:  418:        CONFIG_PULSE,
446:        -:  419:        new_entry_seq(new_sequence(4), "PULSES"),
447:        -:  420:        conf);
448:        -:  421:        
449:       10:  422:    conf = update_entry(
450:        -:  423:        CONFIG_MREG,
451:        -:  424:        new_entry_seq(new_sequence(4), "MREG"),
452:        -:  425:        conf);
453:        -:  426:        
454:       10:  427:    conf = update_entry(
455:        -:  428:        CONFIG_MVAR,
456:        -:  429:        new_entry_seq(new_sequence(4), "MVAR"),
457:        -:  430:        conf);
458:        -:  431:    
459:       10:  432:    conf = update_entry(
460:        -:  433:        CONFIG_DI,
461:        -:  434:        new_entry_seq(new_sequence(8), "DI"),
462:        -:  435:        conf);
463:        -:  436: 
464:       10:  437:    conf = update_entry(
465:        -:  438:        CONFIG_DQ,
466:        -:  439:        new_entry_seq(new_sequence(8), "DQ"),
467:        -:  440:        conf);
468:        -:  441:    
469:       10:  442:    conf = update_entry(
470:        -:  443:        CONFIG_AI,
471:        -:  444:        new_entry_seq(new_sequence(8), "AI"),
472:        -:  445:        conf);
473:        -:  446:    
474:       10:  447:    conf = update_entry(
475:        -:  448:        CONFIG_AQ,
476:        -:  449:        new_entry_seq(new_sequence(8), "AQ"),
477:        -:  450:        conf);
478:        -:  451:
479:       10:  452:    return conf;
480:        -:  453:}
481:        -:  454:
482:function clear_config called 4 returned 1000locks executed 100%
483:        4:  455:config_t clear_config(config_t c){
484:        -:  456:
485:        4:  457:    return (config_t)NULL;
486:        -:  458:}
487:        -:  459:
488:function log_yml_event called 0 returned 00locks executed 0%
489:<font color=red>    #####:  460:static int log_yml_event(yaml_event_t event){</font>
490:        -:  461:
491:<font color=red>    #####:  462:    switch(event.type){ </font>
492:        -:  463:    
493:        -:  464:        case YAML_NO_EVENT: 
494:<font color=red>    #####:  465:        	plc_log("No event!"); </font>
495:<font color=red>    #####:  466:            break;</font>
496:        -:  467:    /* Stream start/end */
497:        -:  468:        case YAML_STREAM_START_EVENT: 
498:<font color=red>    #####:  469:        	plc_log("STREAM START"); </font>
499:<font color=red>    #####:  470:            break;</font>
500:        -:  471:        case YAML_STREAM_END_EVENT: 
501:<font color=red>    #####:  472:        	plc_log("STREAM END");   </font>
502:<font color=red>    #####:  473:            break;</font>
503:        -:  474:    /* Block delimeters */
504:        -:  475:        case YAML_DOCUMENT_START_EVENT: 
505:<font color=red>    #####:  476:        	plc_log("Start Document"); </font>
506:<font color=red>    #####:  477:            break;</font>
507:        -:  478:        case YAML_DOCUMENT_END_EVENT: 
508:<font color=red>    #####:  479:        	plc_log("End Document");   </font>
509:<font color=red>    #####:  480:            break;</font>
510:        -:  481:        case YAML_SEQUENCE_START_EVENT: 
511:<font color=red>    #####:  482:        	plc_log("Start Sequence"); </font>
512:<font color=red>    #####:  483:            break;</font>
513:        -:  484:        case YAML_SEQUENCE_END_EVENT: 
514:<font color=red>    #####:  485:        	plc_log("End Sequence");</font>
515:<font color=red>    #####:  486:            break;</font>
516:        -:  487:        case YAML_MAPPING_START_EVENT: 
517:<font color=red>    #####:  488:        	plc_log("Start Mapping");         </font>
518:<font color=red>    #####:  489:            break;</font>
519:        -:  490:        case YAML_MAPPING_END_EVENT: 
520:<font color=red>    #####:  491:        	plc_log("End Mapping");      </font>
521:<font color=red>    #####:  492:            break;</font>
522:        -:  493:    /* Data */
523:        -:  494:        case YAML_ALIAS_EVENT:  
524:<font color=red>    #####:  495:        	plc_log("Got alias (anchor )", event.data.alias.anchor); </font>
525:<font color=red>    #####:  496:            break;</font>
526:        -:  497:        case YAML_SCALAR_EVENT: 
527:<font color=red>    #####:  498:        	plc_log("Got scalar (value )", event.data.scalar.value); </font>
528:<font color=red>    #####:  499:        	break;</font>
529:        -:  500:        default:
530:<font color=red>    #####:  501:            plc_log("default?");</font>
531:        -:  502:    }
532:<font color=red>    #####:  503:    return CONF_OK;</font>
533:        -:  504:}
534:        -:  505:
535:function store_value called 26 returned 1000locks executed 85%
536:       26:  506:config_t store_value(
537:        -:  507:            unsigned char key, 
538:        -:  508:            const char * value, 
539:        -:  509:            config_t config){
540:        -:  510:
541:        -:  511:    entry_t e; 
542:       26:  512:    if( config == NULL) {
543:        -:  513:    
544:<font color=red>    #####:  514:        return NULL;</font>
545:        -:  515:    }
546:        -:  516:    
547:       26:  517:    config_t conf = config;
548:       26:  518:    e = get_entry(key, conf);
549:        -:  519:    
550:       26:  520:    if(e == NULL) {
551:        2:  521:        conf-&gt;err = CONF_ERR;
552:        -:  522:        
553:        2:  523:        return conf;
554:        -:  524:    }
555:        -:  525:    
556:       24:  526:    switch(e-&gt;type_tag){
557:        -:  527:         case ENTRY_INT:
558:       16:  528:            e-&gt;e.scalar_int = atoi(value);
559:       16:  529:            break;
560:        -:  530:         
561:        -:  531:         case ENTRY_STR:
562:        -:  532:         
563:        8:  533:            e-&gt;e.scalar_str = strdup_r(e-&gt;e.scalar_str, value);
564:        8:  534:            break;
565:        -:  535:            
566:<font color=red>    #####:  536:         default: return conf;</font>
567:        -:  537:    }        
568:       24:  538:    conf-&gt;map[key] = e;
569:        -:  539:       
570:       24:  540:    return conf;
571:        -:  541:}
572:        -:  542:
573:function store_seq_value called 22 returned 1000locks executed 100%
574:       22:  543:config_t store_seq_value(
575:        -:  544:                    unsigned char seq,
576:        -:  545:                    unsigned char idx,  
577:        -:  546:                    const char * key,
578:        -:  547:                    const char * value, 
579:        -:  548:                    config_t config){
580:        -:  549:                    
581:       22:  550:    config_t conf = config;                
582:       22:  551:    entry_t s = conf-&gt;map[seq];
583:        -:  552:    
584:       22:  553:    if( s == NULL ||
585:       20:  554:        key == NULL || 
586:       18:  555:        value == NULL ||
587:       36:  556:        s-&gt;type_tag != ENTRY_SEQ ||
588:       18:  557:        idx &gt;= s-&gt;e.seq-&gt;size) {
589:        -:  558:        
590:        4:  559:        conf-&gt;err = CONF_ERR;
591:        -:  560:        
592:        4:  561:        return conf;
593:        -:  562:    }            
594:        -:  563:    
595:       54:  564:    variable_t var = &(conf-&gt;map[seq]
596:       18:  565:                            -&gt;e.seq
597:       36:  566:                            -&gt;vars[idx]);
598:        -:  567:    
599:       18:  568:    conf-&gt;map[seq]
600:       18:  569:        -&gt;e.seq
601:       18:  570:        -&gt;vars[idx].index = idx;
602:        -:  571:    
603:       18:  572:    if(!strcmp(key, "ID")){
604:        6:  573:         conf-&gt;map[seq]
605:        6:  574:             -&gt;e.seq
606:        6:  575:             -&gt;vars[idx].name = strdup_r(var-&gt;name, value);
607:        -:  576:    } else {
608:        -:  577:        
609:       12:  578:        conf-&gt;map[seq]
610:       12:  579:            -&gt;e.seq
611:       24:  580:            -&gt;vars[idx].params = update_param(
612:       12:  581:                conf-&gt;map[seq]
613:       12:  582:                    -&gt;e.seq
614:       12:  583:                    -&gt;vars[idx].params,
615:        -:  584:                key,
616:        -:  585:                value);    
617:        -:  586:    }   
618:        -:  587:        
619:       18:  588:    return conf;                       
620:        -:  589:}
621:        -:  590:
622:function process_seq_element called 10 returned 1000locks executed 100%
623:       10:  591:static config_t process_seq_element(
624:        -:  592:                   yaml_event_t event,
625:        -:  593:                   int sequence, 
626:        -:  594:                   const char * key,
627:        -:  595:                   int * idx,
628:        -:  596:                   config_t config){
629:        -:  597:    
630:       10:  598:    config_t conf = config;
631:       10:  599:    char * val = (char *)event.data.scalar.value;
632:        -:  600:                    
633:       10:  601:    if(!strcmp(key, "INDEX")){
634:        -:  602:                             
635:        2:  603:            *idx = atoi(val);
636:        -:  604:    } else {  
637:        -:  605:                             
638:        8:  606:            conf = store_seq_value(sequence, 
639:        8:  607:                                      *idx, 
640:        -:  608:                                      key, 
641:        -:  609:                                      val, 
642:        -:  610:                                      conf);       
643:        -:  611:    }                      
644:        -:  612:      
645:       10:  613:    return conf;                       
646:        -:  614:}
647:        -:  615:
648:function process_scalar called 16 returned 1000locks executed 100%
649:       16:  616:static config_t process_scalar(
650:        -:  617:                   yaml_event_t event,
651:        -:  618:                   const char * key,
652:        -:  619:                   config_t config){
653:        -:  620:    
654:       16:  621:    config_t conf = config;
655:       16:  622:    char * val = (char *)event.data.scalar.value;
656:        -:  623:               
657:       16:  624:    conf = store_value(
658:       16:  625:                    get_key(key, conf), 
659:        -:  626:                    val, 
660:        -:  627:                    conf);
661:        -:  628:                 
662:       16:  629:    return conf;                       
663:        -:  630:}
664:        -:  631:
665:function process_mapping called 16 returned 1000locks executed 100%
666:       16:  632:static config_t process_mapping(
667:        -:  633:                    const char * key,
668:        -:  634:                    int seq,
669:        -:  635:                    yaml_parser_t *parser,
670:        -:  636:                    config_t config){
671:        -:  637:    
672:       16:  638:    config_t conf = config;                
673:       16:  639:    int k = get_key(key, conf);
674:       16:  640:    entry_t c = get_entry(k, conf);
675:        -:  641:    
676:       24:  642:    if( c != NULL &&
677:        8:  643:        c-&gt;type_tag == ENTRY_MAP) {
678:        -:  644:                    
679:        6:  645:        c-&gt;e.conf = process(
680:        -:  646:                        seq, 
681:        -:  647:                        parser, 
682:        -:  648:                        c-&gt;e.conf);        
683:        6:  649:        conf-&gt;map[k] = c;
684:        -:  650:    } else {
685:        -:  651:                    
686:       10:  652:        conf = process(
687:        -:  653:            seq, 
688:        -:  654:            parser, 
689:        -:  655:            conf);
690:        -:  656:    }
691:        -:  657:    
692:       16:  658:    return conf;    
693:        -:  659:} 
694:        -:  660:
695:function process called 30 returned 1000locks executed 94%
696:       30:  661:config_t process(int sequence, 
697:        -:  662:            yaml_parser_t *parser, 
698:        -:  663:            config_t configuration){
699:        -:  664:             
700:       30:  665:    config_t config = configuration;
701:       30:  666:    unsigned char storage = STORE_KEY;   
702:       30:  667:    int done = CONF_F;
703:        -:  668:    char key[CONF_STR];
704:       30:  669:    int idx = CONF_ERR;
705:        -:  670:    yaml_event_t event;
706:       30:  671:    memset(&event, 0, sizeof(event));
707:       30:  672:    memset(key, 0, CONF_STR);
708:       30:  673:    if(config == NULL) {
709:        -:  674:     
710:        2:  675:        return NULL;
711:        -:  676:     }
712:        -:  677:     
713:       28:  678:     if(parser == NULL) {
714:        2:  679:        config-&gt;err = CONF_ERR;
715:        -:  680:     
716:        2:  681:        return config;
717:        -:  682:     }
718:        -:  683://     || parser-&gt;context == NULL 
719:        -:  684:           
720:      182:  685:     while(done == CONF_F){
721:        -:  686:     
722:      130:  687:        if (!yaml_parser_parse(parser, &event)){   
723:<font color=red>    #####:  688:                yaml_parser_error(*parser);</font>
724:<font color=red>    #####:  689:                config-&gt;err = CONF_ERR;</font>
725:        -:  690:        } else {
726:        -:  691:   
727:      130:  692:            switch(event.type){
728:        -:  693:                case YAML_SCALAR_EVENT: 
729:        -:  694://swap storage to process val after key and vice versa 
730:       60:  695:                    if(storage == STORE_KEY) {
731:       34:  696:                        memset(key, 0, CONF_STR);
732:       34:  697:                        sprintf(key, "", 
733:       34:  698:                            (char *)event.data.scalar.value);
734:        -:  699:                        
735:       34:  700:                        storage = STORE_VAL;
736:        -:  701:                    } else {
737:       26:  702:                        if(sequence &gt; CONF_ERR) {
738:        -:  703:                    
739:       10:  704:                            config = process_seq_element(
740:        -:  705:                                    event,
741:        -:  706:                                    sequence,
742:        -:  707:                                    key,
743:        -:  708:                                    &idx,
744:        -:  709:                                    config);
745:        -:  710:                        } else {
746:        -:  711:                            
747:       16:  712:                            config = process_scalar(
748:        -:  713:                                    event,
749:        -:  714:                                    key,
750:        -:  715:                                    config);
751:        -:  716:                        }
752:       26:  717:                        storage = STORE_KEY;            
753:        -:  718:                    }
754:       60:  719:                    break;
755:        -:  720:                
756:        -:  721:                case YAML_SEQUENCE_START_EVENT:
757:        -:  722:
758:        2:  723:                    sequence = get_key(key, config);
759:        2:  724:                    break;
760:        -:  725:                
761:        -:  726:                case YAML_SEQUENCE_END_EVENT:
762:        -:  727:
763:        2:  728:                    sequence = CONF_ERR;
764:        2:  729:                    break;
765:        -:  730:                
766:        -:  731:                case YAML_MAPPING_START_EVENT:
767:        -:  732:                
768:       16:  733:                    config = process_mapping(
769:        -:  734:                                key,
770:        -:  735:                                sequence,
771:        -:  736:                                parser,
772:        -:  737:                                config); 
773:       16:  738:                    storage = STORE_KEY;            
774:       16:  739:                    break;
775:        -:  740:                    
776:        -:  741:                case YAML_MAPPING_END_EVENT:
777:        -:  742:                case YAML_STREAM_END_EVENT:     
778:        -:  743:                    
779:       24:  744:                    done = CONF_T;
780:       24:  745:                    break;
781:        -:  746:                    
782:        -:  747:                case YAML_NO_EVENT:
783:        2:  748:                    config-&gt;err = CONF_ERR;
784:        2:  749:                    break;    
785:        -:  750:                    
786:       24:  751:                default: break;    
787:        -:  752:            }
788:        -:  753:         }
789:      130:  754:         if(config-&gt;err &lt; CONF_OK) {
790:        2:  755:             done = CONF_T;
791:        -:  756:             //log_yml_event(event);
792:        -:  757:         }                                              
793:      130:  758:         yaml_event_delete(&event);   
794:        -:  759:     }
795:        -:  760:     
796:       26:  761:     return config;
797:        -:  762:}
798:        -:  763:             
799:function load_config_yml called 0 returned 00locks executed 0%
800:<font color=red>    #####:  764:config_t load_config_yml(const char * filename, config_t conf) {</font>
801:        -:  765:    yaml_parser_t parser;
802:        -:  766:    
803:        -:  767:    FILE * fcfg;
804:        -:  768:    char path[CONF_STR];
805:        -:  769:
806:<font color=red>    #####:  770:    memset(path, 0, CONF_STR);</font>
807:<font color=red>    #####:  771:    sprintf(path, "", filename);</font>
808:        -:  772:    
809:<font color=red>    #####:  773:    memset(&parser, 0, sizeof(parser));</font>
810:        -:  774:    
811:<font color=red>    #####:  775:    config_t r = conf;</font>
812:        -:  776:    
813:<font color=red>    #####:  777:    if (!yaml_parser_initialize(&parser)) {</font>
814:        -:  778:    
815:<font color=red>    #####:  779:        yaml_parser_error(parser);    </font>
816:        -:  780:    }
817:<font color=red>    #####:  781:    if ((fcfg = fopen(path, "r"))) {</font>
818:<font color=red>    #####:  782:        plc_log("Looking for configuration from  ...", path);</font>
819:<font color=red>    #####:  783:        yaml_parser_set_input_file(&parser, fcfg);</font>
820:<font color=red>    #####:  784:        r = process(CONF_ERR, &parser, conf);</font>
821:<font color=red>    #####:  785:        if(r-&gt;err &lt; CONF_OK)</font>
822:<font color=red>    #####:  786:            plc_log( "Configuration error ");</font>
823:<font color=red>    #####:  787:        fclose(fcfg);</font>
824:        -:  788:    } else {
825:<font color=red>    #####:  789:        r-&gt;err = CONF_ERR;</font>
826:<font color=red>    #####:  790:        plc_log("Could not open file ", filename);</font>
827:        -:  791:    }
828:<font color=red>    #####:  792:    yaml_parser_delete(&parser);</font>
829:<font color=red>    #####:  793:    return r;</font>
830:        -:  794:}
831:        -:  795:
832:function emit_variable called 96 returned 1000locks executed 100%
833:       96:  796:static void emit_variable(variable_t var, yaml_emitter_t *emitter) {
834:        -:  797:    yaml_event_t evt;
835:       98:  798:    if(var-&gt;name != NULL &&
836:        2:  799:        var-&gt;name[0]) {
837:        -:  800:       
838:        -:  801:        char idx[4];
839:        2:  802:        memset(idx, 0, 4);
840:        -:  803:    
841:        2:  804:        yaml_mapping_start_event_initialize(
842:        -:  805:    			        &evt,
843:        -:  806:    			        NULL,
844:        -:  807:    			        NULL,
845:        -:  808:    			        CONF_F,
846:        -:  809:    			        YAML_BLOCK_MAPPING_STYLE);
847:        -:  810:    	 	    
848:        2:  811:        yaml_emitter_emit(emitter, &evt);
849:        -:  812:    		//log_yml_event(evt);
850:        -:  813:    		            
851:        2:  814:        yaml_scalar_event_initialize(
852:        -:  815:                        	&evt,
853:        -:  816:                    	    NULL,
854:        -:  817:                    		NULL,
855:        -:  818:                    		"INDEX",
856:        -:  819:                    		5,
857:        -:  820:                    		CONF_T,
858:        -:  821:                    		CONF_T, 
859:        -:  822:                    		YAML_PLAIN_SCALAR_STYLE); 
860:        2:  823:        yaml_emitter_emit(emitter, &evt);
861:        -:  824:                    		
862:        2:  825:        sprintf(idx, "0", var-&gt;index);		
863:        2:  826:        yaml_scalar_event_initialize(
864:        -:  827:                        	&evt,
865:        -:  828:                    	    NULL,
866:        -:  829:                    		NULL,
867:        -:  830:                    		(unsigned char *)idx,
868:        2:  831:                    		strlen(idx),
869:        -:  832:                    		CONF_T,
870:        -:  833:                    		CONF_T, 
871:        -:  834:                    		YAML_PLAIN_SCALAR_STYLE); 	
872:        2:  835:        yaml_emitter_emit(emitter, &evt);
873:        -:  836:    		            
874:        -:  837:   
875:        2:  838:        yaml_scalar_event_initialize(
876:        -:  839:                        	&evt,
877:        -:  840:                    	    NULL,
878:        -:  841:                    		NULL,
879:        -:  842:                    		"ID",
880:        -:  843:                    		2,
881:        -:  844:                    		CONF_T,
882:        -:  845:                    		CONF_T, 
883:        -:  846:                    		YAML_PLAIN_SCALAR_STYLE); 
884:        2:  847:        yaml_emitter_emit(emitter, &evt);
885:        -:  848:                    			
886:        4:  849:        yaml_scalar_event_initialize(
887:        -:  850:                        	&evt,
888:        -:  851:                    	    NULL,
889:        -:  852:                    		NULL,
890:        2:  853:                    		(unsigned char *)var-&gt;name,
891:        2:  854:                    		strlen(var-&gt;name),
892:        -:  855:                    		CONF_T,
893:        -:  856:                    		CONF_T, 
894:        -:  857:                    		YAML_PLAIN_SCALAR_STYLE); 	
895:        2:  858:        yaml_emitter_emit(emitter, &evt);
896:        -:  859:       
897:        2:  860:        param_t it = var-&gt;params;
898:        6:  861:        while(it){
899:        4:  862:            yaml_scalar_event_initialize(
900:        -:  863:                        	&evt,
901:        -:  864:                    	    NULL,
902:        -:  865:                    		NULL,
903:        2:  866:                    		(unsigned char *)it-&gt;key,
904:        2:  867:                    		strlen(it-&gt;key),
905:        -:  868:                    		CONF_T,
906:        -:  869:                    		CONF_T, 
907:        -:  870:                    		YAML_PLAIN_SCALAR_STYLE); 
908:        2:  871:            yaml_emitter_emit(emitter, &evt);
909:        -:  872:                    			
910:        4:  873:            yaml_scalar_event_initialize(
911:        -:  874:                        	&evt,
912:        -:  875:                    	    NULL,
913:        -:  876:                    		NULL,
914:        2:  877:                    		(unsigned char *)it-&gt;value,
915:        2:  878:                    		strlen(it-&gt;value),
916:        -:  879:                    		CONF_T,
917:        -:  880:                    		CONF_T, 
918:        -:  881:                    		YAML_PLAIN_SCALAR_STYLE); 	
919:        2:  882:            yaml_emitter_emit(emitter, &evt);
920:        2:  883:            it = it-&gt;next; 
921:        -:  884:        }    
922:        2:  885:        yaml_mapping_end_event_initialize(&evt); 
923:        -:  886:        	
924:        2:  887:        yaml_emitter_emit(emitter, &evt); 
925:        -:  888:    }
926:       96:  889:} 
927:        -:  890:
928:function emit_entry called 50 returned 1000locks executed 97%
929:       50:  891:static void emit_entry(entry_t entry, yaml_emitter_t *emitter) {
930:       50:  892:    int i = 0;
931:        -:  893:    yaml_event_t evt;
932:        -:  894:     
933:      100:  895:    yaml_scalar_event_initialize(
934:        -:  896:    	&evt,
935:        -:  897:	    NULL,
936:        -:  898:		NULL,
937:       50:  899:		(unsigned char *)entry-&gt;name,
938:       50:  900:		strlen(entry-&gt;name),
939:        -:  901:		CONF_T,
940:        -:  902:		CONF_T, 
941:        -:  903:		YAML_PLAIN_SCALAR_STYLE); 	
942:        -:  904:		
943:       50:  905:	yaml_emitter_emit(emitter, &evt);
944:        -:  906:	//log_yml_event(evt);
945:        -:  907:	char buf[CONF_NUM];
946:       50:  908:	memset(buf, 0, CONF_NUM);
947:       50:  909:	entry_t iter = NULL;
948:       50:  910:	variable_t viter = NULL;
949:        -:  911:	
950:       50:  912:	switch (entry-&gt;type_tag){
951:        -:  913:	
952:        -:  914:		case ENTRY_STR:
953:        -:  915:		
954:       16:  916:			yaml_scalar_event_initialize(
955:        -:  917:    		&evt,
956:        -:  918:	    	NULL,
957:        -:  919:         	NULL,
958:        8:  920:			(unsigned char *)entry-&gt;e.scalar_str,
959:        8:  921:			strlen(entry-&gt;e.scalar_str),
960:        -:  922:			CONF_T,
961:        -:  923:			CONF_T, 
962:        -:  924:			YAML_PLAIN_SCALAR_STYLE); 	
963:        -:  925:		
964:        8:  926:			yaml_emitter_emit(emitter, &evt); 
965:        -:  927:			//log_yml_event(evt);		
966:        8:  928:			break;
967:        -:  929:		
968:        -:  930:		case ENTRY_INT:
969:        -:  931:			
970:       18:  932:			sprintf(buf, "0", entry-&gt;e.scalar_int);
971:       18:  933:			yaml_scalar_event_initialize(
972:        -:  934:    		&evt,
973:        -:  935:	    	NULL,
974:        -:  936:			NULL,
975:        -:  937:			(unsigned char *)buf,
976:       18:  938:			strlen(buf),
977:        -:  939:			CONF_T,
978:        -:  940:			CONF_T, 
979:        -:  941:			YAML_PLAIN_SCALAR_STYLE); 	
980:        -:  942:		
981:       18:  943:			yaml_emitter_emit(emitter, &evt);
982:        -:  944:			//log_yml_event(evt); 		
983:       18:  945:			break;
984:        -:  946:				 
985:        -:  947:		case ENTRY_MAP:
986:        -:  948:		
987:        8:  949:		    yaml_mapping_start_event_initialize(
988:        -:  950:    			&evt,
989:        -:  951:    			NULL,
990:        -:  952:    			NULL,
991:        -:  953:    			CONF_F,
992:        -:  954:    			YAML_BLOCK_MAPPING_STYLE);
993:        -:  955:    	 	    
994:        8:  956:    		yaml_emitter_emit(emitter, &evt);
995:        -:  957:    		//log_yml_event(evt);
996:        8:  958:    		iter = *(entry-&gt;e.conf-&gt;map);
997:        -:  959:    		
998:       38:  960:			while(i &lt; entry-&gt;e.conf-&gt;size){
999:       22:  961:			    if(iter != NULL) {
1000:       22:  962:				    emit_entry(iter, emitter);  
1001:        -:  963:				}
1002:       22:  964:				iter = (entry-&gt;e.conf-&gt;map)[++i];
1003:        -:  965:			}	
1004:        8:  966:			yaml_mapping_end_event_initialize(&evt); 	
1005:        8:  967:    		yaml_emitter_emit(emitter, &evt); 
1006:        -:  968:    		//log_yml_event(evt);
1007:        8:  969:			break;
1008:        -:  970:		
1009:        -:  971:		case ENTRY_SEQ:
1010:       16:  972:		  yaml_sequence_start_event_initialize(
1011:        -:  973:    			&evt,
1012:        -:  974:    			NULL,
1013:        -:  975:    			NULL,
1014:        -:  976:    			CONF_T,
1015:        -:  977:    			YAML_BLOCK_SEQUENCE_STYLE);
1016:        -:  978:    		//log_yml_event(evt);
1017:       16:  979:    	    yaml_emitter_emit(emitter, &evt); 	
1018:        -:  980:		//emit size as int
1019:        -:  981:		  
1020:       16:  982:		    sprintf(buf, "0", entry-&gt;e.seq-&gt;size);
1021:       16:  983:			yaml_scalar_event_initialize(
1022:        -:  984:    		&evt,
1023:        -:  985:	    	NULL,
1024:        -:  986:			NULL,
1025:        -:  987:			(unsigned char *)buf,
1026:       16:  988:			strlen(buf),
1027:        -:  989:			CONF_T,
1028:        -:  990:			CONF_T, 
1029:        -:  991:			YAML_PLAIN_SCALAR_STYLE); 	
1030:        -:  992:		
1031:       16:  993:			yaml_emitter_emit(emitter, &evt);
1032:        -:  994:			//log_yml_event(evt); 		
1033:        -:  995:			//emit values as map
1034:       16:  996:			viter = entry-&gt;e.seq-&gt;vars;
1035:        -:  997:    		
1036:       16:  998:    		i = 0;
1037:      128:  999:			while(i &lt; entry-&gt;e.seq-&gt;size){
1038:       96: 1000:			    if(viter != NULL) {
1039:       96: 1001:				   emit_variable(viter, emitter);
1040:        -: 1002:				}
1041:       96: 1003:				*viter = (entry-&gt;e.seq-&gt;vars)[++i];
1042:        -: 1004:			}	
1043:        -: 1005:			
1044:       16: 1006:			yaml_sequence_end_event_initialize(&evt); 	
1045:       16: 1007:    		yaml_emitter_emit(emitter, &evt); 
1046:        -: 1008:    		//log_yml_event(evt);
1047:       16: 1009:			break;
1048:        -: 1010:			
1049:<font color=red>    #####: 1011:		default:break;</font>
1050:        -: 1012:	}
1051:        -: 1013:	
1052:       50: 1014:}
1053:        -: 1015:
1054:function emit called 2 returned 1000locks executed 100%
1055:        2: 1016:int emit(yaml_emitter_t *emitter, const config_t conf) {
1056:        2: 1017:    int r = CONF_OK;     
1057:        -: 1018:   
1058:        -: 1019:    yaml_event_t evt;
1059:        -: 1020:    char val[CONF_STR];
1060:        2: 1021:    memset(val,0,CONF_STR);
1061:        -: 1022:    //doc start
1062:        2: 1023:    yaml_document_start_event_initialize(&evt, NULL, NULL, NULL, CONF_F); 
1063:        2: 1024:	yaml_emitter_emit(emitter, &evt); 		
1064:        -: 1025:   // log_yml_event(evt);
1065:        -: 1026:    
1066:        2: 1027:    yaml_mapping_start_event_initialize(
1067:        -: 1028:    	&evt,
1068:        -: 1029:    	NULL,
1069:        -: 1030:    	NULL,
1070:        -: 1031:    	CONF_F,
1071:        -: 1032:    	YAML_BLOCK_MAPPING_STYLE);
1072:        -: 1033:    	 	    
1073:        2: 1034:    yaml_emitter_emit(emitter, &evt);
1074:        -: 1035:   // log_yml_event(evt);
1075:        -: 1036:    
1076:        2: 1037:    entry_map_t config_map = conf-&gt;map;
1077:        2: 1038:    entry_t iter = *config_map;
1078:        2: 1039:    int i = 0;
1079:       60: 1040:    while(i &lt; N_CONFIG_VARIABLES) {
1080:       56: 1041:        if(iter != NULL){
1081:       28: 1042:    	    emit_entry(iter, emitter);
1082:        -: 1043:    	}
1083:       56: 1044:    	iter = config_map[++i];
1084:        -: 1045:    }
1085:        -: 1046:   
1086:        -: 1047:    //mapping end
1087:        2: 1048:    yaml_mapping_end_event_initialize(&evt); 	
1088:        2: 1049:    yaml_emitter_emit(emitter, &evt); 		
1089:        -: 1050:    //log_yml_event(evt);
1090:        -: 1051:    
1091:        -: 1052:    //doc end
1092:        2: 1053:    yaml_document_end_event_initialize(&evt,CONF_F);
1093:        2: 1054:    yaml_emitter_emit(emitter, &evt);
1094:        -: 1055:    //log_yml_event(evt); 		
1095:        2: 1056:    yaml_event_delete(&evt); 	
1096:        2: 1057:    return r;
1097:        -: 1058:}
1098:        -: 1059:
1099:function save_config_yml called 0 returned 00locks executed 0%
1100:<font color=red>    #####: 1060:int save_config_yml(const char * filename, const config_t conf) {</font>
1101:        -: 1061:    
1102:        -: 1062:    yaml_emitter_t emitter;
1103:        -: 1063:    yaml_event_t event;
1104:        -: 1064:    
1105:        -: 1065:    FILE * fcfg;
1106:        -: 1066:    char path[CONF_STR];
1107:<font color=red>    #####: 1067:    int r = CONF_OK;</font>
1108:        -: 1068:    
1109:<font color=red>    #####: 1069:    memset(path, 0, CONF_STR);</font>
1110:<font color=red>    #####: 1070:    sprintf(path, "", filename);</font>
1111:        -: 1071:
1112:<font color=red>    #####: 1072:    if(!yaml_emitter_initialize(&emitter)){</font>
1113:<font color=red>    #####: 1073:        return CONF_ERR;    </font>
1114:        -: 1074:    }
1115:<font color=red>    #####: 1075:    if ((fcfg = fopen(path, "wb"))) {</font>
1116:<font color=red>    #####: 1076:         plc_log("Save configuration to  ...", path);</font>
1117:        -: 1077:         
1118:<font color=red>    #####: 1078:         yaml_emitter_set_output_file(&emitter, fcfg);</font>
1119:<font color=red>    #####: 1079:         yaml_stream_start_event_initialize(&event, YAML_UTF8_ENCODING);</font>
1120:        -: 1080:         
1121:<font color=red>    #####: 1081:         r = yaml_emitter_emit(&emitter, &event);</font>
1122:        -: 1082:         
1123:<font color=red>    #####: 1083:         if(r)</font>
1124:<font color=red>    #####: 1084:            r = emit(&emitter, conf);</font>
1125:<font color=red>    #####: 1085:         if(r){</font>
1126:<font color=red>    #####: 1086:            yaml_stream_end_event_initialize(&event);</font>
1127:<font color=red>    #####: 1087:            r = yaml_emitter_emit(&emitter, &event);   </font>
1128:        -: 1088:         }
1129:        -: 1089:            
1130:<font color=red>    #####: 1090:         if(r &lt; CONF_OK)</font>
1131:<font color=red>    #####: 1091:            plc_log( "Configuration error ");</font>
1132:        -: 1092:            
1133:<font color=red>    #####: 1093:         fclose(fcfg);</font>
1134:        -: 1094:    } else {
1135:<font color=red>    #####: 1095:        r = CONF_ERR;</font>
1136:<font color=red>    #####: 1096:        plc_log("Could not open file  for write", filename);</font>
1137:        -: 1097:    }
1138:<font color=red>    #####: 1098:    yaml_emitter_delete(&emitter);</font>
1139:<font color=red>    #####: 1099:    return r;</font>
1140:        -: 1100:}
1141:        -: 1101:
</pre><hr width=50%><hr><font color=green size=1>This report is produced by <i>coverage</i> &copy;Martti Lumme 2002</font></body></html>
